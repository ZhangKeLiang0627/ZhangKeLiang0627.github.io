<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【简易速记24.07】最近在学习网络编程...</title>
    <link href="/2024/07/14/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/README/"/>
    <url>/2024/07/14/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/README/</url>
    
    <content type="html"><![CDATA[<h3 id="【简易速记24-07】最近在学习网络编程…"><a href="#【简易速记24-07】最近在学习网络编程…" class="headerlink" title="【简易速记24.07】最近在学习网络编程…"></a>【简易速记24.07】最近在学习网络编程…</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><h3 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h3><p>一直有一个机器人梦啊，这回不能再gugubird啦。只不过刚好碰上忙时，知识点零散，一点点慢慢积累吧。</p><hr><h3 id="【2024-07-14】找到一个有趣且强大的网络工具Socat"><a href="#【2024-07-14】找到一个有趣且强大的网络工具Socat" class="headerlink" title="【2024&#x2F;07&#x2F;14】找到一个有趣且强大的网络工具Socat"></a>【2024&#x2F;07&#x2F;14】找到一个有趣且强大的网络工具<code>Socat</code></h3><p><strong>Socat</strong>或<strong>SOcket CAT</strong>是一个基于 Linux 命令行&#x2F;终端的实用程序，用于在两个双向字节流之间建立和传输数据。</p><p>在linux环境<code>(Debian/Ubuntu)</code>下安装socat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo apt-get update</span><br><br>sudo apt-get install socat<br></code></pre></td></tr></table></figure><ul><li><strong>1.接着可以尝试一个简单的TCP通信测试</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分别打开两个终端窗口</span><br><br><span class="hljs-comment"># 窗口1输入以下命令，监听端口5555</span><br>socat -d -d TCP-LISTEN:5555 -<br><br><span class="hljs-comment"># 窗口2输入以下命令，连接端口5555</span><br><span class="hljs-comment"># ip地址可以使用ifconfig指令查询</span><br><br><span class="hljs-comment"># 这条指令是全双工的</span><br><span class="hljs-comment"># 连接成功以后，可以在各自的窗口发言，信息会传送到对方的窗口！</span><br>socat -d -d TCP-CONNECT:192.168.26.163:5555 -<br><br><span class="hljs-comment"># 这条指令是单工的</span><br><span class="hljs-comment"># 连接成功以后，监听窗口只能听不能发，只有发送窗口可以发！</span><br>socat - TCP:192.168.26.163:5555<br><br><span class="hljs-comment"># 上述的所有TCP可以更换为UDP，就会得到UDP通信！</span><br></code></pre></td></tr></table></figure><p><img src="/images/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/image.png" alt="socat-TCP"></p><ul><li><strong>2.创建两个虚拟串口并转发数据</strong></li></ul><p>打开一个新终端窗口，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">socat -d -d pty,raw,<span class="hljs-built_in">echo</span>=0 pty,raw,<span class="hljs-built_in">echo</span>=0<br></code></pre></td></tr></table></figure><p>返回结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">2024/07/14 20:39:00 socat[2297] N PTY is /dev/pts/1<br>2024/07/14 20:39:00 socat[2297] N PTY is /dev/pts/2<br>2024/07/14 20:39:00 socat[2297] N starting data transfer loop with FDs [5,5] and [7,7]<br></code></pre></td></tr></table></figure><p>创建了<code>/dev/pts/1</code>和<code>/dev/pts/2</code>两个串口，并且将两个串口连接起来，此时打开两个终端，在终端1输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 去到对应的文件夹</span><br><span class="hljs-built_in">cd</span> /dev/pts/<br><span class="hljs-built_in">cat</span> &lt; 1<br></code></pre></td></tr></table></figure><p>在另一个新终端，终端2中输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 去到对应的文件夹</span><br><span class="hljs-built_in">cd</span> /dev/pts/<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abc&quot;</span> &gt; 2<br></code></pre></td></tr></table></figure><p>此时在终端1上就会显示<code>abc</code>数据，此时说明<code>/dev/pts/2</code>把数据传输到了<code>/dev/pts/1</code>.</p><p><img src="/images/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/image-1.png" alt="socat-UART"></p><p><strong>上面创建的串口，在不同的机器上名称可能不一致，对于调试、测试来讲很麻烦，下面给出解决方法！</strong></p><ul><li><strong>3.创建“固定名称”的串口</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用link即可把创建的虚拟的串口映射到任何你有权限的位置（这里是home目录）</span><br> socat -d -d pty,raw,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty1 pty,raw,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty2 <br></code></pre></td></tr></table></figure><p>返回内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">2024/07/14 20:57:47 socat[3041] N PTY is /dev/pts/1<br>2024/07/14 20:57:47 socat[3041] N PTY is /dev/pts/2<br>2024/07/14 20:57:47 socat[3041] N starting data transfer loop with FDs [5,5] and [7,7]<br></code></pre></td></tr></table></figure><p>创建串口并设置串口参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">socat -d -d pty,raw,b19200,csize=3,cstopb=1,parenb=1,parodd=1,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty1 pty,raw,b19200,csize=3,cstopb=1,parenb=1,parodd=1,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty2<br></code></pre></td></tr></table></figure><p>解释如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. b19200 <span class="hljs-comment"># 设置波特率为19200</span><br>2. csize3 <span class="hljs-comment"># 设置character size为8</span><br>3. cstopb=1 <span class="hljs-comment"># 设置两个停止位</span><br>4. parenb=1 <span class="hljs-comment"># 不进行奇偶检测</span><br>5. parodd=1 <span class="hljs-comment"># 奇校验</span><br></code></pre></td></tr></table></figure><p>类似参数还有很多很多，请查阅相关的帮助<a href="http://www.dest-unreach.org/socat/doc/socat.html">文档</a></p><p><img src="/images/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/image-2.png" alt="socat-UART"></p><hr><h3 id="【2024-07-16】浅薄地了解Cmake"><a href="#【2024-07-16】浅薄地了解Cmake" class="headerlink" title="【2024&#x2F;07&#x2F;16】浅薄地了解Cmake"></a>【2024&#x2F;07&#x2F;16】浅薄地了解<code>Cmake</code></h3><blockquote><p>最近要学习的东西用到很多makefile的知识，但是我横竖怎么写都不得心应手。那不如学学Cmake工具好了（其实是信号与系统学累了在摸鱼…</p></blockquote><p>找到一个关于<code>Cmake</code>的优良教程，阿里嘎多这位作者：<a href="https://subingwen.cn/cmake/CMake-primer/">教程戳我:)</a></p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>鸣谢文章的思路：<a href="https://blog.csdn.net/hitgavin/article/details/116162329">https://blog.csdn.net/hitgavin/article/details/116162329</a></li><li>鸣谢文章答疑解惑，我对此内容做了搬运：<a href="https://lianshaohua.blog.csdn.net/article/details/135709779">https://lianshaohua.blog.csdn.net/article/details/135709779</a></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Web</tag>
      
      <tag>简易速记</tag>
      
      <tag>Socat</tag>
      
      <tag>Cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ROS】ROS的搭建与安装</title>
    <link href="/2024/06/24/%E6%88%91%E7%9A%84ROS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/ROS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%AE%89%E8%A3%85/README/"/>
    <url>/2024/06/24/%E6%88%91%E7%9A%84ROS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/ROS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%AE%89%E8%A3%85/README/</url>
    
    <content type="html"><![CDATA[<h3 id="【ROS】ROS的搭建与安装"><a href="#【ROS】ROS的搭建与安装" class="headerlink" title="【ROS】ROS的搭建与安装"></a>【ROS】ROS的搭建与安装</h3><h3 id="【ROS】Setup-and-Installation"><a href="#【ROS】Setup-and-Installation" class="headerlink" title="【ROS】Setup and Installation"></a>【ROS】Setup and Installation</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><blockquote><p>PC端：Win11</p></blockquote><blockquote><p>虚拟机：VirturalBox<br>Ubuntu版本：20.04.6<br>ROS版本；noetic</p></blockquote><h3 id="虚拟机的准备"><a href="#虚拟机的准备" class="headerlink" title="虚拟机的准备"></a>虚拟机的准备</h3><p>virturalBox安装Ubuntu20.04的流程步骤：<a href="https://blog.csdn.net/xiangbing911/article/details/108614181">戳这里:)</a></p><p>virtualBox安装Ubuntu时看不到继续按钮的解决办法：<a href="https://blog.csdn.net/Ratib/article/details/128167397">戳这里:P</a></p><p>virtualBox共享文件夹解决方法：<a href="https://blog.csdn.net/qq_57209192/article/details/124697935">戳这儿:-0</a></p><ul><li>最最关键的就是在于增强功能包的安装，如果没有实现共享文件夹功能，请手动使用该命令重新安装增强功能包：<code>sudo apt-get install virtualbox-guest-dkms</code></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-ROS常规安装方法"><a href="#1-ROS常规安装方法" class="headerlink" title="1. ROS常规安装方法"></a>1. ROS常规安装方法</h3><p>ROS的安装主要是网络问题居多，以下找到一个手把手安装ROS的教程<a href="https://blog.csdn.net/qq_64671439/article/details/135287166">戳这里:)</a></p><p>解决<code>rosdep</code>安装时遇到的各种问题的方法<a href="https://blog.csdn.net/luoluonuoyasuolong/article/details/128999527">戳这里:0</a></p><h3 id="2-ROS安装的超快速方法-鱼香ROS"><a href="#2-ROS安装的超快速方法-鱼香ROS" class="headerlink" title="2. ROS安装的超快速方法 -&gt; 鱼香ROS"></a>2. ROS安装的超快速方法 -&gt; 鱼香ROS</h3><p>这个是最懒人的安装方法了，让我们齐说感谢大佬-&gt;<a href="https://blog.csdn.net/m0_73745340/article/details/135281023">教程戳这里:)</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>感谢以上教程的各位发布者！</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ROS</tag>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树莓派】YOLOv5实时识别loopy全流程😒</title>
    <link href="/2024/06/19/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8YOLOv5%E5%AE%9E%E6%97%B6%E8%AF%86%E5%88%ABloopy%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/06/19/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8YOLOv5%E5%AE%9E%E6%97%B6%E8%AF%86%E5%88%ABloopy%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="【树莓派】YOLOv5实时识别loopy全流程😒"><a href="#【树莓派】YOLOv5实时识别loopy全流程😒" class="headerlink" title="【树莓派】YOLOv5实时识别loopy全流程😒"></a>【树莓派】YOLOv5实时识别loopy全流程😒</h3><h3 id="【Raspberry-PI】-YOLOv5-identifies-the-loopy-in-real-time"><a href="#【Raspberry-PI】-YOLOv5-identifies-the-loopy-in-real-time" class="headerlink" title="【Raspberry PI】 YOLOv5 identifies the loopy in real time"></a>【Raspberry PI】 YOLOv5 identifies the loopy in real time</h3><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3><p><img src="/img/post/loopy1.png"><br><img src="/img/post/loopy2.png"></p><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><ul><li>PC：Win11, GTX3060(4GB)</li><li>硬件：Raspberry Pi 4B</li><li>摄像头：中星微摄像头（型号：USB301PL）</li><li>镜像版本：2022-09-22-raspios-bullseye-arm64.img</li><li>树莓派Python版本：<code>3.9.2</code></li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>请提前确认摄像头和OpenCV是否可以正常使用，详情请查看我从前的文章<code>【树莓派】OpenCV的环境安装与基本使用</code>。</p><h2 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h2><ul><li>关联的Github仓库<a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里</a>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">RaspberryPiDeployYOLOv5/<br>├─1.yolov5ForTrain <span class="hljs-comment"># 用于PC端进行模型训练</span><br>└─2.yolov5ForDetect <span class="hljs-comment"># 用于树莓派进行实时推理</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="一、准备运动"><a href="#一、准备运动" class="headerlink" title="一、准备运动"></a>一、准备运动</h2><h2 id="1-对树莓派"><a href="#1-对树莓派" class="headerlink" title="1. 对树莓派"></a>1. 对树莓派</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol><li><p>Pytorch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装torch</span><br>pip install torch==1.8.1<br><span class="hljs-comment"># 安装torchvision</span><br>pip install torchvision==0.9.1<br></code></pre></td></tr></table></figure></li><li><p>YOLOv5</p></li></ol><ul><li><a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里:)</a>下载YOLOv5的依赖，这是已经整理好适配此Python版本树莓派的包。</li><li>将下载完的<code>yolov5-master.zip</code>放到树莓派文件路径<code>home/pi/Download/</code>中，并输入命令<code>unzip yolov5-master.zip</code>将压缩包解压到当前目录。</li><li>解压完成后，<code>cd yolov5-master/</code>进入文件夹。</li><li>使用命令<code>pip install -r requirement.txt</code>安装依赖，时间会比较长，最终看见<code>Successfully</code>类似字样则表示安装成功。</li></ul><h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><ul><li>下载：<a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里:)</a>下载<code>yolov5s.pt</code>，这是YOLOv5的预训练权重文件，后续将使用此模型来进行示例测试。</li><li>文件传输：将此模型复制到之前解压好的<code>yolov5-master</code>文件夹当中。</li><li>运行代码：在<code>yolov5-master</code>文件夹中，运行命令<code>python detect.py</code>，倘若出现<code>Results saved to run/detect/expX</code>，代表代码执行成功，你可以前往此路径查看预测结果图片。</li></ul><h2 id="2-对Windows端PC"><a href="#2-对Windows端PC" class="headerlink" title="2. 对Windows端PC"></a>2. 对Windows端PC</h2><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n yolov5_60 python=3.8<br><br>conda activate yolov5_60<br></code></pre></td></tr></table></figure><h3 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol><li><p>Pytorch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118<br></code></pre></td></tr></table></figure></li><li><p>YOLOv5</p></li></ol><ul><li><a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里:)</a>下载YOLOv5的依赖，这是在PC端训练使用的包，此包中已经含有<code>yolov5s.pt</code>。</li><li>解压完成后，进入文件夹。</li><li>使用命令<code>pip install -r requirement.txt</code>安装依赖，时间会比较长，最终看见<code>Successfully</code>类似字样则表示安装成功。发生报错不要紧，要是模块没有当前的版本，我们就挑一个稍微靠近的版本就行。</li><li>训练模型：<code>train.py</code>中的参数已经手动进行修改，使用命令<code>python train.py</code>，训练完成会在<code>runs/train/expX/weight</code>中生成训练好的模型，我们将<code>test.pt</code>扔到树莓派解压后的文件夹中即可。</li></ul><blockquote><p>常见报错</p><ul><li>报错：RuntimeError: result type Float can’t be cast to the desired output type __int64 -&gt; <a href="https://blog.csdn.net/qq_43573527/article/details/132963466">解决方法</a></li><li>报错：cache文件已存在 -&gt; 解决方法：前往<code>data/loopy/labels</code>删除所有文件后缀<code>.cache</code>的文件即可。</li></ul></blockquote><hr><h2 id="二、推理运动"><a href="#二、推理运动" class="headerlink" title="二、推理运动"></a>二、推理运动</h2><h3 id="1-对树莓派-1"><a href="#1-对树莓派-1" class="headerlink" title="1. 对树莓派"></a>1. 对树莓派</h3><p><code>cd home/pi/Download/yolov5-master/</code>，输入命令<code>python3 detect.py --weight best_loopy.pt --source 0</code>，注意<code>best_loopy.pt</code>即为我们在PC端训练好的模型！<code>--source 0</code>表示使用摄像头实时进行识别。</p><h3 id="2-对PC端"><a href="#2-对PC端" class="headerlink" title="2. 对PC端"></a>2. 对PC端</h3><p><code>python detect.py --weight best_loopy.pt --source 0</code></p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>可可爱爱的loopy来自这里<a href="https://github.com/ZhangKeLiang0627/YOLOv8-loopy">数据集来源</a>。</li><li>关联的Github仓库<a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里</a>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RaspberryPi</tag>
      
      <tag>OpenCV</tag>
      
      <tag>YOLOv5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树莓派】OpenCV的环境安装与基本使用</title>
    <link href="/2024/06/17/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84OpenCV%E7%9A%84%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/17/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84OpenCV%E7%9A%84%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="【树莓派】OpenCV的环境安装与基本使用"><a href="#【树莓派】OpenCV的环境安装与基本使用" class="headerlink" title="【树莓派】OpenCV的环境安装与基本使用"></a>【树莓派】OpenCV的环境安装与基本使用</h3><h3 id="【Raspberry-PI】-OpenCV-environment-installation-and-basical-usage"><a href="#【Raspberry-PI】-OpenCV-environment-installation-and-basical-usage" class="headerlink" title="【Raspberry PI】 OpenCV environment installation and basical usage"></a>【Raspberry PI】 OpenCV environment installation and basical usage</h3><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><ul><li>硬件：Raspberry Pi 4B</li><li>摄像头：中星微摄像头（型号：USB301PL）</li><li>镜像版本：2022-09-22-raspios-bullseye-arm64.img</li><li>Python版本：<code>3.9.2</code></li></ul></blockquote><hr><h2 id="摄像头安装"><a href="#摄像头安装" class="headerlink" title="摄像头安装"></a>摄像头安装</h2><p>我这里使用的是某宝随便淘来的<strong>linux免驱动USB摄像头</strong>，下面讲解几个安装摄像头时的注意事项：</p><ul><li>先将摄像头连接上树莓派，再将树莓派上电开机，不然树莓派无法识别设备。</li><li>输入<code>lsusb</code>命令查看当前的USB总线上面有没有挂载Camera字样的设备，如果有就说明摄像头连接成功了。</li><li>如果不是USB摄像头，可以输入<code>ls /dev/video*</code>命令，查看是否有<code>/dev/video0</code>设备。如果设备存在，则说明摄像头挂载成功。</li></ul><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装opencv</span><br>pip install opencv-python<br><br><span class="hljs-comment"># 由于opencv只支持 numpy v1.x 版本</span><br><span class="hljs-comment"># 这里进行numpy版本的统一</span><br>pip install numpy==1.19.3<br></code></pre></td></tr></table></figure><h2 id="环境验证"><a href="#环境验证" class="headerlink" title="环境验证"></a>环境验证</h2><ol><li><p>使用命令行<code>python3</code>，打开Python交互模式。</p></li><li><p>在Python交互模式中输入以下命令，对cv2模块进行验证，如果没有报错并显示出当前的cv2版本则环境已经安装成功。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>cv2.__version__<br></code></pre></td></tr></table></figure></li><li><p>在路径 <code>/home/pi/Downloads</code> 创建一个<code>testCV2.py</code>文件，并填入下方代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 调用摄像头‘0’一般是打开电脑自带摄像头，‘1’是打开外部摄像头（只有一个摄像头的情况）</span><br>width = <span class="hljs-number">1280</span><br>height = <span class="hljs-number">960</span><br>cap.<span class="hljs-built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, width)  <span class="hljs-comment"># 设置图像宽度</span><br>cap.<span class="hljs-built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, height)  <span class="hljs-comment"># 设置图像高度</span><br><span class="hljs-comment"># 显示图像</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <br>    ret, frame = cap.read()  <span class="hljs-comment"># 读取图像(frame就是读取的视频帧，对frame处理就是对整个视频的处理)</span><br>    <span class="hljs-comment"># print(ret)</span><br>    <span class="hljs-comment"># 例如将图像灰度化处理</span><br>    img=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)  <span class="hljs-comment"># 转灰度图</span><br>    <br>    cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)<br>    <span class="hljs-comment"># 图像不处理的情况</span><br>    cv2.imshow(<span class="hljs-string">&quot;frame&quot;</span>, frame)    <br> <br>    input_str = cv2.waitKey(<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">if</span> input_str == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):  <span class="hljs-comment"># 如过输入的是q就break，结束图像显示，鼠标点击视频画面输入字符</span><br>        <span class="hljs-keyword">break</span><br>    <br>cap.release()  <span class="hljs-comment"># 释放摄像头</span><br>cv2.destroyAllWindows()  <span class="hljs-comment"># 销毁窗口</span><br></code></pre></td></tr></table></figure></li><li><p>最后在<strong>VNC远程登录模式</strong>或者在<strong>树莓派图形界面操作系统</strong>下，在命令行中输入指令<code>cd /home/pi/Downloads/</code>，接着执行指令<code>python3 testCV2.py</code>。幸运的话，你会看到摄像头捕捉到的原画面和经过处理的灰度画面两个窗口，按下<code>q</code>键即可退出代码程序。到这里OpenCV的环境安装和基本使用就完成啦！</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RaspberryPi</tag>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32S3接入百度在线语音合成</title>
    <link href="/2024/03/26/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/"/>
    <url>/2024/03/26/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32S3接入百度在线语音合成"><a href="#ESP32S3接入百度在线语音合成" class="headerlink" title="ESP32S3接入百度在线语音合成"></a>ESP32S3接入百度在线语音合成</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>使用ESP32S3接入百度在线语音合成，其实是为我后面的某个小项目做铺垫啦！这里记录一下实现的过程。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>主控：ESP32S3N16R8</li><li>平台：Arduino + PlatformIO + VScode</li></ul><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><blockquote><p>大部分内容都和语音识别那趴差不多，百度的语音识别和语音合成是共用同一个应用的，如果创建过了就直接使用相同的就行，密钥和token都是共用的，我就直接搬过来了，只有在POST的时候稍微有些区别，我也贴出了具体的代码和示例。</p></blockquote><ol><li>在百度智能云控制端选择<code>语音技术</code>并创建应用获取<code>API Key</code>和<code>Secret Key</code></li><li>根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></li><li>在ESP32S3中发送POST请求API</li></ol><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="1-创建语音合成应用"><a href="#1-创建语音合成应用" class="headerlink" title="1. 创建语音合成应用"></a>1. 创建语音合成应用</h3><p>登录百度智能云的云账号，选择语音识别，创建一个新应用。<strong>（注意：分清楚百度账号还是云账号，这两个不一样的）</strong><br>百度智能云：<a href="https://login.bce.baidu.com/?redirect=https://console.bce.baidu.com/ai/#/ai/speech/app/list">https://login.bce.baidu.com/?redirect=https%3A%2F%2Fconsole.bce.baidu.com%2Fai%2F#/ai/speech/app/list</a></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-1.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-2.png"></p><h3 id="2-根据创建应用生成的API-Key和Secret-Key来获取access-token"><a href="#2-根据创建应用生成的API-Key和Secret-Key来获取access-token" class="headerlink" title="2. 根据创建应用生成的API Key和Secret Key来获取access_token"></a>2. 根据创建应用生成的API Key和Secret Key来获取access_token</h3><p>创建好应用，在应用列表里会出现你刚刚创建的应用，当然<code>API Key</code>和<code>Secret Key</code>也有啦</p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-3.png"></p><p>有了<code>API Key</code>和<code>Secret Key</code>，下面我们可以在ESP32S3上进行GET请求得到access_token的代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 获取token */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gainToken</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>   </span><br><span class="hljs-function"></span>&#123;<br>    HTTPClient http_client; <span class="hljs-comment">// #include &lt;HTTPClient.h&gt;</span><br>    <span class="hljs-comment">//注意，要把下面网址中的your_apikey和your_secretkey替换成自己的API Key和Secret Key</span><br>    http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=your_apikey&amp;client_secret=your_secretkey&quot;</span>);<br>    <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">GET</span>();<br><br>    <span class="hljs-keyword">if</span>(httpResponseCode == HTTP_CODE_OK)<br>    &#123;<br>        String response = http_client.<span class="hljs-built_in">getString</span>();<br>        Serial.<span class="hljs-built_in">println</span>(response);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    http_client.<span class="hljs-built_in">end</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>请求成功会返回如下数据，我们主要关注<code>access_token</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;public wise_adapt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_secret&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dfac94a3489fe9fca7c3221cbf7525ff&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>access_token</code>对应的值就是可用的token，每次申请的<code>token</code>有效期限为30天，过期就需要重新申请。所以咱定时更新<code>access_token</code>就行，不用每次调用语音识别或合成都申请一遍。</li></ul><h3 id="3-发送文本数据，通过POST请求发送到语音合成API上"><a href="#3-发送文本数据，通过POST请求发送到语音合成API上" class="headerlink" title="3. 发送文本数据，通过POST请求发送到语音合成API上"></a>3. 发送文本数据，通过POST请求发送到语音合成API上</h3><p>下面是数据上传的格式说明：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-4.png"></p><p>下面是ESP32S3的具体实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> payload[<span class="hljs-number">8000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">/* 在线语音合成 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speechSynthesis</span><span class="hljs-params">(String inputText)</span></span><br><span class="hljs-function"></span>&#123;<br>  HTTPClient http_client;<br><br>  _LOG(<span class="hljs-string">&quot;[Synthesis] Start Synthesis!\r\n&quot;</span>);<br><br>  <span class="hljs-built_in">memset</span>(payload, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in">strlen</span>(payload)); <span class="hljs-comment">// 将数组清空</span><br><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;tex=&quot;</span>); <span class="hljs-comment">// 合成的文本，UTF-8编码格式</span><br>  <span class="hljs-built_in">strcat</span>(payload, inputText.<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 合成的文本，UTF-8编码格式</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;lan=zh&quot;</span>); <span class="hljs-comment">// 语言选择，目前只有中英文混合模式，填写固定值zh</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;cuid=hugokkl&quot;</span>); <span class="hljs-comment">// 识别码，随便几个字符，但最好唯一</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;ctp=1&quot;</span>); <span class="hljs-comment">// 客户端类型选择，web端填写固定值1</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;spd=7&quot;</span>); <span class="hljs-comment">// 语速，取值0-15，默认为5中语速</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;pit=5&quot;</span>); <span class="hljs-comment">// 音调，取值0-15，默认为5中语调</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;vol=15&quot;</span>); <span class="hljs-comment">// 音量，基础音库取值0-9，精品音库取值0-15，默认为5中音量</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;per=5118&quot;</span>); <span class="hljs-comment">// 基础音库，度丫丫=4，精品音库，度小鹿=5118</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;aue=5&quot;</span>); <span class="hljs-comment">// 3为mp3格式(默认)；4为pcm-16k；5为pcm-8k；6为wav（内容同pcm-16k）</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;tok=24.fc3481a177dfe90487fa0c3ce0892530.2592000.1713939400.282335-57684431&quot;</span>); <span class="hljs-comment">// access_token</span><br><br>  http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;http://tsn.baidu.com/text2audio&quot;</span>);<br><br>  http_client.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 5s超时时间</span><br>  <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">POST</span>(payload);<br><br>  <span class="hljs-keyword">if</span> (httpResponseCode == HTTP_CODE_OK)<br>  &#123;<br>    WiFiClient response;<br>    <span class="hljs-type">uint32_t</span> streamLength = http_client.<span class="hljs-built_in">getSize</span>();<br>    _LOG(<span class="hljs-string">&quot;streamSize:%d\r\n&quot;</span>, streamLength);<br><br>    response = http_client.<span class="hljs-built_in">getStream</span>();<br><br>    <span class="hljs-keyword">while</span> (!response.<span class="hljs-built_in">available</span>()) <span class="hljs-comment">// 等待数据流可获取</span><br>    &#123;<br>    &#125;<br><br>    streamLength = <span class="hljs-built_in">min</span>(streamLength, _samples * <span class="hljs-number">2</span>);<br><br>    response.<span class="hljs-built_in">readBytes</span>((<span class="hljs-type">char</span> *)_rawData, streamLength);<br><br>    Speaker.<span class="hljs-built_in">playRaw</span>((<span class="hljs-type">int16_t</span> *)_rawData, streamLength / <span class="hljs-number">2</span>, <span class="hljs-number">8000</span>);<br><br>    _LOG(<span class="hljs-string">&quot;[Synthesis] All done!\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    _LOG(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>  &#125;<br>  http_client.<span class="hljs-built_in">end</span>();<br><br>  _LOG(<span class="hljs-string">&quot;[Synthesis] Synthesis complete!\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>access_token默认有效期30天，单位是秒，生产环境注意及时刷新。刷新了旧的也能用（只要不超时）</li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>这次没看教程（主要是搞语音合成的教程比较少）。所以！感谢我自己辛勤的劳作😋</p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>语音合成</tag>
      
      <tag>Speaker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32S3接入文心一言</title>
    <link href="/2024/03/25/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/"/>
    <url>/2024/03/25/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32S3接入文心一言"><a href="#ESP32S3接入文心一言" class="headerlink" title="ESP32S3接入文心一言"></a>ESP32S3接入文心一言</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>使用ESP32S3接入文心一言，其实是为我后面的某个小项目做铺垫啦！这里记录一下实现的过程。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>主控：ESP32S3N16R8</li><li>平台：Arduino + PlatformIO + VScode</li></ul><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><ol><li>在百度智能云的云千帆控制台并创建应用获取<code>API Key</code>和<code>Secret Key</code></li><li>根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></li><li>在ESP32S3中发送POST请求API</li></ol><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="1-在百度智能云的云千帆控制台并创建应用获取API-Key和Secret-Key"><a href="#1-在百度智能云的云千帆控制台并创建应用获取API-Key和Secret-Key" class="headerlink" title="1. 在百度智能云的云千帆控制台并创建应用获取API Key和Secret Key"></a>1. 在百度智能云的云千帆控制台并创建应用获取<code>API Key</code>和<code>Secret Key</code></h3><p>首先要使用云账号登录百度智能云，然后进入千帆大模型平台，创建一个新应用。<strong>（注意：分清楚百度账号还是云账号，这两个不一样的）</strong></p><p>百度智能云千帆控制台：<a href="https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application">https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application</a></p><p>创建新应用：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image.png"></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-1.png"></p><p>创建好应用以后就可以得到<code>API Key</code>和<code>Secret Key</code>！<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-2.png"></p><h3 id="2-根据创建应用生成的API-Key和Secret-Key来获取access-token"><a href="#2-根据创建应用生成的API-Key和Secret-Key来获取access-token" class="headerlink" title="2. 根据创建应用生成的API Key和Secret Key来获取access_token"></a>2. 根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></h3><p>进入API代码调试界面：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-3.png"></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-4.png"></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-5.png"></p><p>应用列表选择自己创建的ESP32S3智能语音助手<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-6.png"></p><p>获取<code>access_token</code><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-7.png"></p><p>指令格式：<code>&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:&quot;介绍一下名侦探柯南这部动画&quot;</code><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-8.png"></p><p>调试结果如下：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-9.png"></p><h3 id="3-在ESP32S3中发送POST请求API"><a href="#3-在ESP32S3中发送POST请求API" class="headerlink" title="3. 在ESP32S3中发送POST请求API"></a>3. 在ESP32S3中发送POST请求API</h3><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String apiERNIEbotUrl = <span class="hljs-string">&quot;https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions?access_token=xxxxxxxxx&quot;</span>; <span class="hljs-comment">// 把申请的access_token填上去</span><br>String inputText = <span class="hljs-string">&quot;你好！&quot;</span>;<br><br><span class="hljs-comment">/* 文心一言 */</span><br><span class="hljs-function">String <span class="hljs-title">getGPTResponse</span><span class="hljs-params">(String inputText)</span></span><br><span class="hljs-function"></span>&#123;<br>  HTTPClient http_client;<br><br>  http_client.<span class="hljs-built_in">begin</span>(apiERNIEbotUrl);<br>  http_client.<span class="hljs-built_in">addHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br>  http_client.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">20000</span>); <span class="hljs-comment">// 20s的超时时间</span><br><br>  String payload = <span class="hljs-string">&quot;&#123;\&quot;messages\&quot;:[&#123;\&quot;role\&quot;: \&quot;user\&quot;,\&quot;content\&quot;: \&quot;&quot;</span> + inputText + <span class="hljs-string">&quot;\&quot;&#125;],\&quot;disable_search\&quot;: false,\&quot;enable_citation\&quot;: false&#125;&quot;</span>;<br><br>  <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">POST</span>(payload);<br><br>  <span class="hljs-keyword">if</span> (httpResponseCode == HTTP_CODE_OK)<br>  &#123;<br>    String response = http_client.<span class="hljs-built_in">getString</span>();<br><br>    http_client.<span class="hljs-built_in">end</span>();<br>    _LOG(<span class="hljs-string">&quot;\r\n%s\r\n&quot;</span>, response.<span class="hljs-built_in">c_str</span>());<br><br>    <span class="hljs-comment">// Parse JSON response</span><br>    <span class="hljs-function">DynamicJsonDocument <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-number">2048</span>)</span></span>;<br>    <span class="hljs-built_in">deserializeJson</span>(doc, response);<br><br>    String outPutText = doc[<span class="hljs-string">&quot;result&quot;</span>];<br>    <span class="hljs-keyword">return</span> outPutText;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    _LOG(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    http_client.<span class="hljs-built_in">end</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[HTTP] GET... failed, error!&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>意外的顺利耶！Yapi😘</p><ul><li>要注意的是，文心一言的API新用户第一个月可以获得一张20元的优惠券有效期1个月，1个月以后就要付费使用文心一言啦！</li><li>access_token默认有效期30天，单位是秒，生产环境注意及时刷新。刷新了旧的也能用（只要不超时）</li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>项目教程：<a href="https://blog.csdn.net/vor234/article/details/135372118">https://blog.csdn.net/vor234/article/details/135372118</a></p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>文心一言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32S3接入百度在线语音识别</title>
    <link href="/2024/03/24/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    <url>/2024/03/24/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32S3接入百度在线语音识别"><a href="#ESP32S3接入百度在线语音识别" class="headerlink" title="ESP32S3接入百度在线语音识别"></a>ESP32S3接入百度在线语音识别</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>使用ESP32S3接入百度智能云实现在线语音识别，记录中间遇到的问题和实现流程。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>主控：ESP32S3N16R8</li><li>平台：Arduino + PlatformIO + VScode</li></ul><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><ol><li>在百度智能云控制端选择<code>语音识别</code>并创建应用获取<code>API Key</code>和<code>Secret Key</code></li><li>根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></li><li>采集音频数据，打包数据，通过http协议将打包的数据（payload）POST请求发送语音识别的API上</li><li>接收返回的数据（response）</li></ol><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="1-创建语音识别应用"><a href="#1-创建语音识别应用" class="headerlink" title="1. 创建语音识别应用"></a>1. 创建语音识别应用</h3><p>登录百度智能云的云账号，选择语音识别，创建一个新应用。<strong>（注意：分清楚百度账号还是云账号，这两个不一样的）</strong><br>百度智能云：<a href="https://login.bce.baidu.com/?redirect=https://console.bce.baidu.com/ai/#/ai/speech/app/list">https://login.bce.baidu.com/?redirect=https%3A%2F%2Fconsole.bce.baidu.com%2Fai%2F#/ai/speech/app/list</a></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image-1.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image-2.png"></p><h3 id="2-根据创建应用生成的API-Key和Secret-Key来获取access-token"><a href="#2-根据创建应用生成的API-Key和Secret-Key来获取access-token" class="headerlink" title="2. 根据创建应用生成的API Key和Secret Key来获取access_token"></a>2. 根据创建应用生成的API Key和Secret Key来获取access_token</h3><p>创建好应用，在应用列表里会出现你刚刚创建的应用，当然<code>API Key</code>和<code>Secret Key</code>也有啦</p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image-3.png"></p><p>有了<code>API Key</code>和<code>Secret Key</code>，下面我们可以在ESP32S3上进行GET请求得到access_token的代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 获取token */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gainToken</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>   </span><br><span class="hljs-function"></span>&#123;<br>    HTTPClient http_client; <span class="hljs-comment">// #include &lt;HTTPClient.h&gt;</span><br>    <span class="hljs-comment">//注意，要把下面网址中的your_apikey和your_secretkey替换成自己的API Key和Secret Key</span><br>    http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=your_apikey&amp;client_secret=your_secretkey&quot;</span>);<br>    <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">GET</span>();<br><br>    <span class="hljs-keyword">if</span>(httpResponseCode == HTTP_CODE_OK)<br>    &#123;<br>        String response = http_client.<span class="hljs-built_in">getString</span>();<br>        Serial.<span class="hljs-built_in">println</span>(response);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    http_client.<span class="hljs-built_in">end</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>请求成功会返回如下数据，我们主要关注<code>access_token</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;public wise_adapt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_secret&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dfac94a3489fe9fca7c3221cbf7525ff&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>access_token</code>对应的值就是可用的token，每次申请的<code>token</code>有效期限为30天，过期就需要重新申请。所以咱定时更新<code>access_token</code>就行，不用每次调用语音识别都申请一遍。</li></ul><h3 id="3-采集数据，通过POST请求发送到语音识别API上"><a href="#3-采集数据，通过POST请求发送到语音识别API上" class="headerlink" title="3. 采集数据，通过POST请求发送到语音识别API上"></a>3. 采集数据，通过POST请求发送到语音识别API上</h3><p>数据上传POST的方式有两种：JSON格式和RAW格式。这里我们使用JSON格式，下图为JSON格式上传的一些必要的参数说明：</p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">可需</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">format</td><td align="center">String</td><td align="center">必填</td><td align="left">语音文件的格式，pcm&#x2F;wav&#x2F;amr&#x2F;m4a。不区分大小写。推荐pcm文件！</td></tr><tr><td align="center">rate</td><td align="center">int</td><td align="center">必填</td><td align="left">采样率，16000、8000，固定值</td></tr><tr><td align="center">channel</td><td align="center">int</td><td align="center">必填</td><td align="left">声道数，仅支持单声道，请填固定值1</td></tr><tr><td align="center">cuid</td><td align="center">String</td><td align="center">必填</td><td align="left">用户唯一标识，用来区分用户，计算UV值。建议填写能区分用户的机器MAC地址或IMEI码，长度为60字符以内。</td></tr><tr><td align="center">token</td><td align="center">String</td><td align="center">必填</td><td align="left">开放平台获取到的开发者[access_token]</td></tr><tr><td align="center">dev_pid</td><td align="center">int</td><td align="center">选填</td><td align="left">不填写lan参数生效，都不填写就默认1537（普通话，输入法模型）</td></tr><tr><td align="center">lm_id</td><td align="center">int</td><td align="center">选填</td><td align="left">自训练平台模型id，填dev_id &#x3D; 8001 或 8002 生效</td></tr><tr><td align="center">lan</td><td align="center">String</td><td align="center">选填，废弃参数</td><td align="left">历史兼容参数，已不再使用</td></tr><tr><td align="center">speech</td><td align="center">String</td><td align="center">必填</td><td align="left">本地语音文件的二进制语音数据，需要进行 base64 编码，与len参数一起使用</td></tr><tr><td align="center">len</td><td align="center">int</td><td align="center">必填</td><td align="left">本地语音文件的字节数，单位是字节（byte）</td></tr></tbody></table><p>图中对数据类型和内容说的很明确了，只需要按照这个格式打包好数据然后发送就行，下面是ESP32S3的具体实现代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> payload[<span class="hljs-number">160000</span>];<br><br><span class="hljs-comment">/* 在线语音识别 */</span><br><span class="hljs-function">String <span class="hljs-title">speechRecognition</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  HTTPClient http_client; <span class="hljs-comment">// #include &lt;HTTPClient.h&gt;</span><br><br>  _LOG(<span class="hljs-string">&quot;[Recognition] Start recognition!\r\n&quot;</span>);<br><br>  result = Mic.<span class="hljs-built_in">record</span>(_rawData, _samples); <span class="hljs-comment">// 录制声音</span><br>  _LOG(<span class="hljs-string">&quot;[Mic] record:%s\r\n&quot;</span>, (result == <span class="hljs-literal">true</span> ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>));<br>  <span class="hljs-keyword">while</span> (Mic.<span class="hljs-built_in">isRecording</span>()); <span class="hljs-comment">// 当录制完成时</span><br>  _LOG(<span class="hljs-string">&quot;[Mic] record is done!\r\n&quot;</span>);<br><br>  <span class="hljs-built_in">memset</span>(payload, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in">strlen</span>(payload)); <span class="hljs-comment">// 将数组清空</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&#123;&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;format\&quot;:\&quot;pcm\&quot;,&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;rate\&quot;:16000,&quot;</span>); <span class="hljs-comment">// 采样率，如果采样率改变了，记得修改该值，只有16000、8000两个固定采样率</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;dev_pid\&quot;:1537,&quot;</span>); <span class="hljs-comment">// 中文普通话</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;channel\&quot;:1,&quot;</span>); <span class="hljs-comment">// 单声道</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;cuid\&quot;:\&quot;hugozkl\&quot;,&quot;</span>); <span class="hljs-comment">// 识别码，随便打几个字符，但最好唯一</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;token\&quot;:\&quot;24.ba06cf95edb0b0aee7bfb016209e5948.2592000.1713715897.282335-57684431\&quot;,&quot;</span>); <span class="hljs-comment">// token，这里需要修改成自己申请到的token</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;len\&quot;:65536,&quot;</span>); <span class="hljs-comment">// 数据长度，如果传输的数据长度改变了，记得修改该值，该值是ADC采集的数据字节数，不是base64编码后的长度</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;speech\&quot;:\&quot;&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, base64::<span class="hljs-built_in">encode</span>((<span class="hljs-type">uint8_t</span> *)_rawData, <span class="hljs-number">65536</span>).<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// base64编码数据 // #include &quot;base64.h&quot;</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&#125;&quot;</span>);<br><br>  <span class="hljs-comment">// HTTP POST</span><br>  <span class="hljs-type">int</span> httpResponseCode;<br>  http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;http://vop.baidu.com/server_api&quot;</span>);<br>  http_client.<span class="hljs-built_in">addHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>  http_client.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 5s超时时间</span><br>  httpResponseCode = http_client.<span class="hljs-built_in">POST</span>(payload);<br><br>  <span class="hljs-keyword">if</span> (httpResponseCode == HTTP_CODE_OK)<br>  &#123;<br>    String response = http_client.<span class="hljs-built_in">getString</span>();<br><br>    http_client.<span class="hljs-built_in">end</span>();<br>    _LOG(<span class="hljs-string">&quot;\r\n%s\r\n&quot;</span>, response.<span class="hljs-built_in">c_str</span>());<br><br>    <span class="hljs-comment">// Parse JSON response</span><br>    <span class="hljs-function">DynamicJsonDocument <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-number">2048</span>)</span></span>; <span class="hljs-comment">// #include &lt;ArduinoJson.h&gt;</span><br>    <span class="hljs-built_in">deserializeJson</span>(doc, response);<br><br>    String outPutText = doc[<span class="hljs-string">&quot;result&quot;</span>];<br>    <span class="hljs-comment">// 去掉首尾的[&quot;&quot;]</span><br>    outPutText = outPutText.<span class="hljs-built_in">substring</span>(<span class="hljs-number">2</span>);<br>    outPutText = outPutText.<span class="hljs-built_in">substring</span>(<span class="hljs-number">0</span>, outPutText.<span class="hljs-built_in">length</span>() - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> outPutText;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    _LOG(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    http_client.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;error&gt;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>POST发送数据有一个固定头部：<code>Content-Type:application/json</code>，POST前需要设置一下，代码中已经有展示。</p><h3 id="4-接收数据"><a href="#4-接收数据" class="headerlink" title="4. 接收数据"></a>4. 接收数据</h3><p>在上一步代码中实现了接收数据，这里列一下返回的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;corpus_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;7349831540333925029&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;success.&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;你好，你是谁？&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sn&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;593363272001711266008&quot;</span><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;corpus_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;7349831596084473860&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;success.&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;现在多少点？&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sn&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;671001951581711266021&quot;</span><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;corpus_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;7349831639168589351&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;success.&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;深圳天气如何？&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sn&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;13152229661711266031&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>数据发送成功则会返回正确的识别数据，当然声音信号不好时返回的语音识别也会不准确。</li><li>谨记，返回的语音识别结果是<code>UTF-8</code>方式编码，所以代码的编码最好也改为<code>UTF-8</code>编码格式。</li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>百度智能云的语音识别服务是可以免费领取到一定使用次数的，15万次，足够我们测试使用，记得开始测试前先领取一下，不然会出现返回<code>报错：&#123;&#39;err_msg&#39;: &#39;request pv too much&#39;, &#39;err_no&#39;: 3305, &#39;sn&#39;: &#39;876137091191590632079&#39; &#125;</code>，报错原因多半是免费次数没领取或者用完了要开通付费功能。</li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>项目教程：<a href="https://blog.csdn.net/wojueburenshu/article/details/119244390">https://blog.csdn.net/wojueburenshu/article/details/119244390</a></p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>语音识别</tag>
      
      <tag>Mic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lvgl添加自定义字体和图片</title>
    <link href="/2024/03/21/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/"/>
    <url>/2024/03/21/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Lvgl添加自定义字体和图片"><a href="#Lvgl添加自定义字体和图片" class="headerlink" title="Lvgl添加自定义字体和图片"></a>Lvgl添加自定义字体和图片</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>仅仅保证对于<code>X-TRACK</code>项目的自定义字体和图片的有效使用哦！</p><hr><h2 id="Font-convert-字体格式转换成-c文件"><a href="#Font-convert-字体格式转换成-c文件" class="headerlink" title="Font convert 字体格式转换成.c文件"></a>Font convert 字体格式转换成.c文件</h2><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>首先我们要去到Lvgl官方网站上的<strong>Online Font Converter</strong><br>网址：<a href="https://lvgl.io/tools/fontconverter">https://lvgl.io/tools/fontconverter</a></p><p>然后我们会看到以下页面！<br><img src="/images/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/image.png"></p><blockquote><ol><li>Name</li></ol></blockquote><p>填写.c文件的名字，如<code>font_smliey_36</code>，36表示字号大小，这样就清晰明了！</p><blockquote><ol start="2"><li>Size</li></ol></blockquote><p>填写字号大小，刚刚我们名字写了<code>font_smliey_36</code>，字号是36，那我们这里就填写36px的字号大小。</p><blockquote><ol start="3"><li>Bpp(bit-per-piel)</li></ol></blockquote><p>填写Bpp为4，这个值会让字体看起来更顺滑而且占据的内存空间相对不大（填别的也行，自己尝试对比一下</p><blockquote><ol start="4"><li>Fallback</li></ol></blockquote><p>这里填写和Name一样的<code>font_smliey_36</code>就行啦！</p><blockquote><ol start="5"><li>三个选项框都不要点！反正在X-TRACK没法用！</li></ol></blockquote><blockquote><ol start="6"><li>TTF&#x2F;WOFF file</li></ol></blockquote><p>在这里选择我们准备好的字体文件，推荐用<code>ttf</code>格式。</p><blockquote><ol start="7"><li>Range</li></ol></blockquote><p>这里是设置范围来选择你的.c文件需要包含哪些文字（Symbols），我们不用这个，这里空着，我们直接在下面的Symbols栏里面写我们需要的字。</p><blockquote><ol start="8"><li>Symbols</li></ol></blockquote><p>在这里我们填入希望在Lvgl里使用的文字，比方说我想要在Lvgl里显示<code>鸡你太美</code>，那我就需要在这个栏里填入<code>鸡你太美</code>。</p><blockquote><ol start="9"><li>点击红色的Convert按钮等待.c文件的渲染和下载即可！</li></ol></blockquote><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>首先打开刚刚生成的.c文件，如<code>font_smiley_36.c</code></p><ol><li>找到注释<code>KERNING</code>和注释<code>ALL CUSTOM DATA</code>之间的一大串，注释掉或者删掉！</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 里面注释掉或者删掉！</span><br><span class="hljs-comment">/*-----------------</span><br><span class="hljs-comment"> *    KERNING</span><br><span class="hljs-comment"> *----------------*/</span><br><br><br><span class="hljs-comment">/*Map glyph_ids to kern left classes*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> kern_left_class_mapping[] =<br>&#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<br>    <span class="hljs-number">7</span><br>&#125;;<br><br><span class="hljs-comment">/*Map glyph_ids to kern right classes*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> kern_right_class_mapping[] =<br>&#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>,<br>    <span class="hljs-number">6</span><br>&#125;;<br><br><span class="hljs-comment">/*Kern values between classes*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int8_t</span> kern_class_values[] =<br>&#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-12</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-17</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>,<br>    <span class="hljs-number">-12</span>, <span class="hljs-number">0</span><br>&#125;;<br><br><br><span class="hljs-comment">/*Collect the kern class&#x27; data in one place*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">lv_font_fmt_txt_kern_classes_t</span> kern_classes =<br>&#123;<br>    .class_pair_values   = kern_class_values,<br>    .left_class_mapping  = kern_left_class_mapping,<br>    .right_class_mapping = kern_right_class_mapping,<br>    .left_class_cnt      = <span class="hljs-number">7</span>,<br>    .right_class_cnt     = <span class="hljs-number">6</span>,<br>&#125;;<br><br><span class="hljs-comment">/*--------------------</span><br><span class="hljs-comment"> *  ALL CUSTOM DATA</span><br><span class="hljs-comment"> *--------------------*/</span><br></code></pre></td></tr></table></figure><ol start="2"><li>将注释<code>ALL CUSTOM DATA</code>和注释<code>PUBLIC FONT</code>之间的一大坨，用以下代码替换掉！</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用它们替换掉原来的一大坨！</span><br><span class="hljs-comment">/*--------------------</span><br><span class="hljs-comment"> *  ALL CUSTOM DATA</span><br><span class="hljs-comment"> *--------------------*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_VERSION_CHECK(8, 0, 0)</span><br><span class="hljs-comment">/*Store all the custom data of the font*/</span><br><span class="hljs-type">static</span>  <span class="hljs-type">lv_font_fmt_txt_glyph_cache_t</span> cache;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">lv_font_fmt_txt_dsc_t</span> font_dsc = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_font_fmt_txt_dsc_t</span> font_dsc = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    .glyph_bitmap = glyph_bitmap,<br>    .glyph_dsc = glyph_dsc,<br>    .cmaps = cmaps,<br>    .kern_dsc = <span class="hljs-literal">NULL</span>,<br>    .kern_scale = <span class="hljs-number">0</span>,<br>    .cmap_num = <span class="hljs-number">1</span>,<br>    .bpp = <span class="hljs-number">4</span>,<br>    .kern_classes = <span class="hljs-number">0</span>,<br>    .bitmap_format = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_VERSION_CHECK(8, 0, 0)</span><br>    .cache = &amp;cache<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/*-----------------</span><br><span class="hljs-comment"> *  PUBLIC FONT</span><br><span class="hljs-comment"> *----------------*/</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>最后，删除注释<code>PUBLIC FONT</code>下的<code>.fallback</code>和<code>.user_data</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 删除以下两条！</span><br><span class="hljs-comment">/*-----------------</span><br><span class="hljs-comment"> *  PUBLIC FONT</span><br><span class="hljs-comment"> *----------------*/</span><br><br>    <span class="hljs-comment">// ...</span><br><br>    .fallback = &amp;font_smiley_36,<br>    .user_data = <span class="hljs-literal">NULL</span>,<br></code></pre></td></tr></table></figure><ol start="4"><li>最后拿去Lvgl跑一下，基本上没有问题啦！</li></ol><h2 id="Pictures-convert-图片格式转换成-c文件"><a href="#Pictures-convert-图片格式转换成-c文件" class="headerlink" title="Pictures convert 图片格式转换成.c文件"></a>Pictures convert 图片格式转换成.c文件</h2><ul><li><strong>未完待续</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lvgl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Power By Hugo@kkl</title>
    <link href="/2024/01/01/WelcomePage/hello-world/"/>
    <url>/2024/01/01/WelcomePage/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h1><h1 id="Welcome-to-MyBlog"><a href="#Welcome-to-MyBlog" class="headerlink" title="Welcome to MyBlog"></a>Welcome to MyBlog</h1><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3><h3 id="Wallpaper-Source-kelvinLi"><a href="#Wallpaper-Source-kelvinLi" class="headerlink" title="Wallpaper Source: kelvinLi"></a>Wallpaper Source: kelvinLi</h3>]]></content>
    
    
    
    <tags>
      
      <tag>SayHi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树莓派】远程登录方法</title>
    <link href="/2023/12/28/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E6%B3%95/"/>
    <url>/2023/12/28/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="My-Raspberry-Pi"><a href="#My-Raspberry-Pi" class="headerlink" title="My Raspberry Pi"></a>My Raspberry Pi</h1><h1 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h1><hr><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><ul><li>硬件：raspberry Pi 4B</li><li>镜像版本：2022-09-22-raspios-bullseye-arm64.img</li></ul></blockquote><hr><h2 id="镜像烧录"><a href="#镜像烧录" class="headerlink" title="镜像烧录"></a>镜像烧录</h2><ul><li>这步就是平常的烧录过程，推荐使用官方的烧录工具，这样前期可以排很多坑（这些坑后面我们会逐一提到）</li></ul><hr><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul><li><strong>初次登录的时，这个地方有个大坑！</strong></li></ul><blockquote><p>最新版的树莓派系统（2022年4月以及以后发布的），<strong>没有了初始化的用户名和密码</strong>，以前用户名是pi，密码是raspberry，但是这次需要进系统之后才能设置。</p></blockquote><blockquote><p>意思就是，你如果初次登录，如果没有用图形化界面，无法创建你的个人用户，你也无法像以前一样直接使用默认账号密码进行登录。</p></blockquote><blockquote><p><strong>解决方法</strong>：</p><ul><li>使用官方的烧录工具，烧录的时候会让你配置初始账号密码。</li><li>外接屏幕、键鼠，使用图形化界面开机配置。</li></ul></blockquote><ul><li>我们重点来了解一下第三种方法，<strong>使用串口无屏幕的登录</strong>。</li></ul><ol><li>往烧录好镜像的SD卡根目录下新建一个文件<code>userconf.txt</code></li><li>文件内写入<code>pi:$6$/4.VdYgDm7RJ0qM1$FwXCeQgDKkqrOU3RIRuDSKpauAbBvP11msq9X58c8Que2l1Dwq3vdJMgiZlQSbEXGaY5esVHGBNbCxKLVNqZW1</code><blockquote><p>这一段意思就是告诉系统，新建一个用户<br>用户名：pi<br>密码：raspberry</p></blockquote></li><li>最后把SD卡插回到树莓派上，重新上电，就可以用这个用户密码登录啦！</li></ol><h3 id="串口登录"><a href="#串口登录" class="headerlink" title="串口登录"></a>串口登录</h3><ul><li><p>串口登录我们需要准备一个USB-TTL Link！</p></li><li><p>排针连接图（<strong>此时TypeC口朝向我们时，即USB-A口朝向右手边时</strong>）：</p><blockquote><p><strong>&#x2F; * * G T R * * * * * * * * * * * * * * &#x2F;</strong><br><strong>&#x2F; * * * * * * * * * * * * * * * * * * * &#x2F;</strong><br><strong>G-&gt;GND &#x2F; T-&gt;TXD &#x2F; R-&gt;RXD</strong></p></blockquote></li><li><p>接着检查烧录好镜像的SD卡根目录下的<code>cmdline.txt</code></p><blockquote><p>如果没有<code>console=serial0,115200</code>就自己在最前面加上去，用一个空格隔开和其他的指令就行</p></blockquote></li><li><p>接着修改烧录好镜像的SD卡根目录下的<code>config.txt</code></p><blockquote><p>在该文件的最后一行加上<code>dtoverlay=pi3-miniuart-bt</code></p></blockquote></li><li><p>这时连接串口就会打印login页面信息啦，记得串口连接选择<strong>波特率为115200，无流控模式</strong>噢！</p></li><li><p>如果没有任何东西显示出来，回去逐一检查，检查硬件是不是插错啦，要<strong>Link的Tx对Pi的Rx，Link的Rx对Pi的Tx</strong>！</p></li></ul><h3 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h3><p>树莓派初次配置SSH登录其实也挺麻烦的，下面演示一下配置步骤。</p><ul><li><p>在烧录好镜像的SD卡根目录下新建文件<code>ssh</code>，空文件就行，命名好以后不用去动它</p></li><li><p>同样的在根目录下再新建一个空文件<code>wpa_supplicant.conf</code></p></li><li><p>使用编译器打开，我这里使用<code>Vscode</code></p></li><li><p>打开以后输入以下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs conf">country=CN<br>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>update_config=1<br> <br>network=&#123;<br>    ssid=&quot;EMMA&quot;<br>    psk=&quot;12345678&quot;<br>    priority=1<br>&#125;<br> <br>network=&#123;<br>    ssid=&quot;HUGO&quot;<br>    psk=&quot;12345678&quot;<br>    priority=2<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下：<br><code>ssid</code>是将要连接的wifi的名字，不能有中文！<br><code>psk</code>是将要连接的wifi的密码<br><code>priority</code>是连接的优先级，优先级数字大的wifi优先连接<br>你可以按照格式来记录多个wifi，注意优先级不要都相同。</p></blockquote></li><li><p>上述步骤完成以后，把SD卡插回树莓派中运行，<code>ssh</code>和<code>wpa_supplicant.conf</code>文件都会自动被写入系统，写入成功后再次用电脑打开SD卡这两个文件会消失不见。如果你要添加或者修改wifi，你需要把<code>wpa_supplicant.conf</code>文件重新写一遍，重复上述操作，新的文件会自动覆盖旧的；<code>ssh</code>不用重新创建，之前创建过了就可以了。</p></li><li><p>重新给树莓派上电进入系统以后，你可能会发现以下问题警告<code>Wi-Fi is currently blocked by rfkill. Use raspi-config to set the country before use.</code></p></li><li><p>这是我们没有设置无线局域网所在国家，于是我们输入指令<code>sudo raspi-config nonint do_wifi_country CN</code>，顺利的话再输入指令<code>ifconfig</code>会查看到wlan0已经被分配了ip地址！</p></li><li><p>如果平时在同一局域网下我们不知道树莓派ip地址是多少，我们可以在Windows<code>win+R</code>输入cmd打开命令行，输入指令<code>ping raspberrypi -4</code>，可以查询同一局域网当中的树莓派的ip地址。</p></li><li><p>拿到ip地址就可以愉快的远程访问啦！</p></li></ul><h3 id="VNC远程桌面登录"><a href="#VNC远程桌面登录" class="headerlink" title="VNC远程桌面登录"></a>VNC远程桌面登录</h3><ul><li>问题1：VNC Viewer显示<code>Cannot currently show the desktop</code></li></ul><blockquote><p><strong>问题分析</strong>：</p></blockquote><p>出现这个无法显示远程桌面的问题，其实是树莓派配置分辨率的关系，树莓派默认使用了最小分辨率，然后VNC不支持这么小的，咱改一下就行。</p><blockquote><p><strong>解决方法</strong>：</p></blockquote><ul><li><code>sudo raspi-config</code>打开设置界面</li><li>按方向键向下选择到<code>Display Options</code></li><li>接着继续选择<code>VNC Resolution</code></li><li>接着选择除了<code>640x480</code>以外的分辨率</li><li>然后回车确定，方向键左右选择<code>finish</code>退出，然后确认reboot重启，选择<code>yes</code></li><li>最后等待重启就行啦！</li></ul><hr><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>请参照<strong>登录</strong>章节当中的<strong>SSH登录</strong>！</p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RaspberryPi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Linux驱动学习笔记</title>
    <link href="/2023/12/13/MyLinuxLearningGuide/MyLinuxLearningGuide/"/>
    <url>/2023/12/13/MyLinuxLearningGuide/MyLinuxLearningGuide/</url>
    
    <content type="html"><![CDATA[<h1 id="我的Linux驱动学习笔记"><a href="#我的Linux驱动学习笔记" class="headerlink" title="我的Linux驱动学习笔记"></a>我的Linux驱动学习笔记</h1><h1 id="MyLinuxLearningGuide"><a href="#MyLinuxLearningGuide" class="headerlink" title="MyLinuxLearningGuide"></a>MyLinuxLearningGuide</h1><h2 id="By-kkl"><a href="#By-kkl" class="headerlink" title="By @kkl"></a>By @kkl</h2><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>话不多说，直接开整</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h2 id="配网"><a href="#配网" class="headerlink" title="配网"></a>配网</h2><ul><li><p><code>cd /etc/</code>去到此文件夹当中</p></li><li><p>编写<code>wpa_supplicant.conf</code></p><blockquote><p>ctrl_interface&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant<br>update_config&#x3D;1</p><p>network&#x3D;{<br> ssid&#x3D;”MagicEyes”<br> psk&#x3D;”12345678”<br>}</p></blockquote></li><li><p><code>vi wpa_supplicant.conf</code>用vim打开这个文件配置你的网络</p></li><li><p><code>wpa_supplicant -D wext -c /etc/wpa_supplicant.conf -i wlan0 &amp;</code></p></li><li><p><code>udhcpc -i wlan0</code></p></li><li><p>更加详细的内容在<strong>驱动开发指南P1765</strong></p></li></ul><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><ul><li><p><code>Uboot</code>和内核的编译步骤：</p><blockquote><ol><li><code>distclean</code>清理工程</li><li><code>make xxx_defconfig</code>使用默认配置文件配置工程</li><li><code>make menuconfig</code>打开配置界面，进行配置</li><li><code>make -j12</code>编译所有文件，<code>-j12</code>表示十二核编译</li></ol><ul><li>编译的时间会比较长</li></ul></blockquote></li><li><p>Plus:</p><blockquote><p><strong>内核的解压和编译绝对不可以在共享文件夹里进行！</strong><br>否则会出现无法软链接的情况，比如<code>ln: failed to create symbolic link &#39;./dt-bindings&#39;: Operation not permitted</code><br>因为共享文件夹是windows和linux的的共享目录，而windows下的文件系统，不支持linux的<code>symbolic link</code>!</p></blockquote></li><li><p>这里的编译的内核选用<code>linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7.tar.bz2</code>即正点原子imx6ull的出厂镜像</p></li><li><p>解压方法：<code>tar -vxjf xxx.tar.bz2</code></p></li><li><p>注意！编译内核时，请先安装Poky交叉编译工具链（具体参照<strong>用户快速体验P115</strong>）</p></li><li><p>最后请使用<strong>04、正点原子MFG_TOOL出厂固件烧录工具</strong>进行开发板的烧录哦！</p></li></ul><h2 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h2><ul><li>Linux驱动有<strong>两种运行方式</strong>，<strong>第一种</strong>就是将驱动<strong>编译进Linux内核</strong>中，这样当Linux内核启动的时候就会自动运行驱动程序。<strong>第二种</strong>就是<strong>将驱动编译成模块</strong>(Linux下模块扩展名为.ko)，在Linux内核启动以后使用<code>insmod</code>或<code>modprobe</code>命令加载驱动模块，使用<code>rmmod</code>或<code>modprobe -r</code>命令卸载驱动模块。</li></ul><h3 id="驱动模块的加载与卸载"><a href="#驱动模块的加载与卸载" class="headerlink" title="驱动模块的加载与卸载"></a>驱动模块的加载与卸载</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>Linux的驱动程序可以编译到<code>kernel</code>里面（也就是<code>zImage</code>），也可以编译为模块<code>.ko</code>。测试的时候只需要加载<code>.ko</code>模块就可以。</li><li>编写驱动时的注意事项<blockquote><ul><li>编译驱动的时候需要用到Linux内核源码！因此要解压缩Linux内核源码，编译Linux内核源码！编译完成会得到<code>zImage</code>和<code>.dtb</code>设备树。需要使用编译后得到的<code>zImage</code>和<code>.dtb</code>启动系统。</li></ul></blockquote></li></ul><h4 id="驱动模块的Makefile"><a href="#驱动模块的Makefile" class="headerlink" title="驱动模块的Makefile"></a>驱动模块的Makefile</h4><ul><li>Makefile的通用写法<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">KERNELDIR := /home/embedfire/kl_files/linux/IMX6ULL/linux<br>CURRENT_PATH := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br>obj-m := chrdevbase.o<br><br>build : kernel_modules<br><br><span class="hljs-section">kernel_modules:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> modules<br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> clean<br></code></pre></td></tr></table></figure></li><li>注意要修改<code>c_cpp_properties.json</code>当中的路径哦！（修改了你就可以写代码的时候有补全，不管它对模块的编译和应用没影响）</li></ul><h4 id="驱动模块的编译"><a href="#驱动模块的编译" class="headerlink" title="驱动模块的编译"></a>驱动模块的编译</h4><ul><li><p><code>make</code>在Makefile存放的目录下执行该命令进行编译，编译完成后生成<code>.ko</code>模块</p></li><li><p><code>make clean</code>用于清理编译生成的模块等文件</p></li><li><p>请在使用<code>make</code>命令之前先使用此命令选择交叉工具链<code>source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi</code></p></li><li><p>编译应用<code>arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</code></p></li></ul><h4 id="模块加载和卸载命令"><a href="#模块加载和卸载命令" class="headerlink" title="模块加载和卸载命令"></a>模块加载和卸载命令</h4><blockquote><p>模块的加载</p></blockquote><ul><li><code>insmod</code>具体用法：<code>insmod xxx.ko</code></li><li><code>modprobe</code>具体用法：<code>modprobe xxx</code>，记得使用之前用<code>depmod</code>刷新当前的模块变量哦！</li><li>加载完成可以使用<code>cat \proc\devices</code>查看模块的设备号哦！</li></ul><blockquote><p>模块的卸载</p></blockquote><ul><li><code>rmmod</code>具体用法：<code>rmmod xxx.ko</code></li><li><code>modprobe -r</code>具体用法：<code>modprobe -r xxx</code></li></ul><hr><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="打开有管理员权限的文件管理器"><a href="#打开有管理员权限的文件管理器" class="headerlink" title="打开有管理员权限的文件管理器"></a>打开有管理员权限的文件管理器</h3><ul><li><code>sudo nautilus</code></li></ul><h3 id="删除非空文件夹"><a href="#删除非空文件夹" class="headerlink" title="删除非空文件夹"></a>删除非空文件夹</h3><ul><li><code>rm -r xxx</code>-r的意思就是递归操作，将会删除该文件夹下的所有子文件夹和文件！</li></ul><h3 id="查看dmesg日志信息"><a href="#查看dmesg日志信息" class="headerlink" title="查看dmesg日志信息"></a>查看dmesg日志信息</h3><ul><li><code>dmesg</code>把从启动开始到当前是所有日志都打印出来</li><li><code>dmesg | tail</code>默认打印最近的十条日志</li><li><code>dmesg | tail -20</code>打印最近的二十条日志</li></ul><h3 id="挂载SD卡"><a href="#挂载SD卡" class="headerlink" title="挂载SD卡"></a>挂载SD卡</h3><ol><li>通过<code>fdisk -l</code>确定sd卡的存在</li><li>创建一个空文件夹，我选择<code>/mnt/mmc</code></li><li>挂载sd卡到新创建的空文件夹<code>mount /dev/mmcblk0p1 /mnt/mmc</code></li></ol><ul><li>卸载可以使用<code>umount /mnt/mmc</code>，注意卸载的时候你所在的当前目录不能是&#x2F;mnt，否则会卸载失败的。</li></ul><h3 id="复制非空文件夹"><a href="#复制非空文件夹" class="headerlink" title="复制非空文件夹"></a>复制非空文件夹</h3><ul><li><code>cp -r /home/packageA/* /home/packageB/</code> 或者<code>cp /home/packageA/* /home/packageB/</code>是把packageA中的文件都复制到packageB中</li><li><code>cp -r /home/packageA/ /home/cp/packageB/</code> 是直接把packageA文件夹复制到packageB中</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的FreeRTOS使用指南</title>
    <link href="/2023/12/09/MyFreeRTOSLearningGuide/MyFreeRTOSLearningGuide/"/>
    <url>/2023/12/09/MyFreeRTOSLearningGuide/MyFreeRTOSLearningGuide/</url>
    
    <content type="html"><![CDATA[<h1 id="我的FreeRTOS使用指南"><a href="#我的FreeRTOS使用指南" class="headerlink" title="我的FreeRTOS使用指南"></a>我的FreeRTOS使用指南</h1><h1 id="MyFreeRTOS-LearningGuide"><a href="#MyFreeRTOS-LearningGuide" class="headerlink" title="MyFreeRTOS-LearningGuide"></a>MyFreeRTOS-LearningGuide</h1><h2 id="By-kkl"><a href="#By-kkl" class="headerlink" title="By @kkl"></a>By @kkl</h2><hr><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote><p>本指南着重于FreeRTOS的API从入门到入土的所有用法（Maybe<br>不会太深究底层的内核实现，可能有一些相关性强的会Q一下<br>会讲一些我学习RTOS的时候卡关的地方，或者是觉得莫名其妙的、理解困难的点<br>主张一个，看着就能用，或者是看着看着就会用，而且用的还一溜一溜的FreeRTOS指南</p></blockquote><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>MCU: STM32F405（现在是二三年十二月，最近才十元钱每片，以前单价十多元我还傻乎乎地买了好多…悲</li><li>工程: 标准库 + VScode + Keil（标准开局</li><li>版本: FreeRTOSv9.0.0</li></ul><hr><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>讲讲我们提前必须要知道的一些知识点和概念，不然后面看到代码会直接懵圈。</li></ul><blockquote><p><strong>1.堆栈</strong></p><ul><li>简单来说就是内存动态分配的问题，比方说你代码跑起来之后，会在某函数里面创建<code>临时变量</code>（也叫<code>局部变量</code>）的时候，就会用上堆栈。</li><li>**栈(Stack)**：就是在某个函数创建的<code>临时变量</code>的内存是编译器自动给你分配的。当这个函数执行完毕，编译器自动帮你释放了这个<code>临时变量</code>的内存。</li><li>栈也用在触发中断的时候，用于保护现场（当前函数地址啊寄存器值啊，方便从中断回来的时候还原现场哈。</li><li>当然栈的使用还包括你函数参数<code>eg: void Func(int Temp[256])</code>这里的变量<code>Temp[256]</code>也是编译器自动帮你申请内存。所以为啥有时候移植一些大型库的时候你什么都配置好了函数也没有出错编译器却报错，原因可能是库当中的某些函数申请的<code>局部变量</code>太大，而你的栈分配的太小导致的。</li><li>**堆(Heap)**：就是malloc或者new，简单说就是malloc，你自己分配内存，当然也要你自己去释放free，生命周期结束不释放内存，会造成内存泄漏。</li><li>**静态区(Static)**：就是你放<code>全局变量</code>或者<code>static修饰的变量</code>的地方啦。<blockquote><ul><li>那么在FreeRTOS中各个任务都有自己的堆栈，一般呢我们只管写这个任务需要多大的堆栈，FreeRTOS会自动帮我们从RAM中申请内存。包括信号量、队列这些都是。</li><li><code>configSUPPORT_STATIC_ALLOCATION</code>为0的时候，FreeRTOS会使用<code>heap_x.c(x为 1~5)</code>中的动态内存管理函数来自动申请RAM；当此宏定义为1的时候，用户可以给FreeRTOS指定一块静态RAM内存，你就可以执行类似<code>xTaskCreateStatic</code>的函数啦。一般咱们写0就行（默认也是写0的</li><li><code>configTOTAL_HEAP_SIZE</code></li><li><code>#define XXX_STK_SIZE 256</code>意思是设置XXX任务的堆栈大小为256*4(字&#x2F;byte</li></ul></blockquote></li></ul></blockquote><blockquote><p><strong>2.字和字节</strong></p><ul><li><strong>字节(bit)</strong></li><li><strong>字(Byte)</strong> ：1 byte &#x3D; 4 bits</li><li>在单片机中可以简单的把<code>byte</code>理解成<code>char</code>类型或者<code>unsigned char</code>类型</li></ul></blockquote><blockquote><p><strong>3.钩子</strong></p><ul><li>ChatGPT说，FreeRTOS的钩子函数(Hooks)是一组可由用户自定义的回调函数</li></ul></blockquote><blockquote><p><strong>4.优先级</strong></p><ul><li>使用FreeRTOS最好把优先级分组选择为<code>NVIC_PriorityGroup_4</code>，寄存器的4位字节都设置为抢占优先级，这样就有 0~15 共16个抢占优先级可供选择。因为FreeRTOS的中断配置里不能处理亚优先级（排队优先级）的这种情况。</li><li>任务优先级</li><li>FreeRTOS的任务优先级是0最不优先，越大越优先，和中断优先级相反的哈！</li></ul></blockquote><hr><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-1-中断屏蔽"><a href="#1-1-中断屏蔽" class="headerlink" title="1.1 中断屏蔽"></a>1.1 中断屏蔽</h3><ul><li><code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>此宏用来设置FreeRTOS系统可以管理的最大优先级。可以自由设置，正点原子设置为5，我也设置为5。也就是说抢占优先级小于5的中断不归FreeRTOS管理。</li><li><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>此宏用来设置FreeRTOS系统可以管理的最小优先级。可以自由设置，正点原子和我都设置成15。也就是说抢占优先级大于15的中断不归FreeRTOS管理，当然STM32的优先级只有 0~15 哈。</li><li>所以上述两个宏加起来的意思就是，<strong>抢占优先级为 0-4 的中断不归FreeRTOS调度，抢占优先级 5-15 的中断服从FreeRTOS的调度。</strong></li><li><em>Plus: 不归FreeRTOS调度的中断，不可以调用FreeRTOS的API哦，不可以哦！打咩！</em></li></ul><h3 id="1-2-开关中断"><a href="#1-2-开关中断" class="headerlink" title="1.2 开关中断"></a>1.2 开关中断</h3><h3 id="1-3-临界段代码（临界区）"><a href="#1-3-临界段代码（临界区）" class="headerlink" title="1.3 临界段代码（临界区）"></a>1.3 临界段代码（临界区）</h3><h4 id="1-3-1-任务级临界段代码保护"><a href="#1-3-1-任务级临界段代码保护" class="headerlink" title="1.3.1 任务级临界段代码保护"></a>1.3.1 任务级临界段代码保护</h4><ul><li>函数<code>taskENTER_CRITICAL()</code>进入临界区和<code>taskEXIT_CRITICAL()</code>退出临界区，是任务级的临界段代码保护。保护这两个函数包夹的区域不会受到中断的打扰。</li><li><strong>Important1: 这两个函数是成对使用的哦！不可以只用其中一个，它们必须成双成对的出现！就是说，你调用了多少次进入临界段，你就要调用多少次退出临界段来抵消！否则中断会一直被屏蔽！</strong></li><li><strong>Important2: 临界区的代码一定要精简！因为进入了临界区意味着关闭了FreeRTOS可以调度的所有中断，你不精简一点，噼里啪啦一大长串，执行好几秒，可能会导致这些中断得不到及时的响应！</strong></li><li>使用场景：任务创建、硬件层初始化、重要的实时性高的代码段…</li><li>任务级临界段代码保护的使用方法如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">testFunction</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        taskENTER_CRITICAL(); <span class="hljs-comment">// 进入临界区</span><br><br>        <span class="hljs-comment">// 你的代码段...</span><br>        <span class="hljs-comment">// 这里是临界区，代码不会受到中断的打断...</span><br><br>        taskEXIT_CRITICAL(); <span class="hljs-comment">// 退出临界区</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-3-2-中断级临界段代码保护"><a href="#1-3-2-中断级临界段代码保护" class="headerlink" title="1.3.2 中断级临界段代码保护"></a>1.3.2 中断级临界段代码保护</h4><ul><li>函数<code>taskENTER_CRITICAL_FROM_ISR()</code>进入中断临界区和<code>taskEXIT_CRITICAL_FROM_ISR(x)</code>退出中断临界区，是中断级临界段代码保护。</li><li>和任务级临界段代码保护差不多，只不过这里呢，<strong>进入中断临界区函数</strong>会返回一个Value，执行<strong>退出中断临界区函数</strong>的时候要把得到的Value传给它。Value记录的就是你屏蔽的其他的中断的优先级。<strong>反正你要记住进入中断临界段时接收这个Value，并在退出中断临界段的时候把这个Value放回去！</strong></li><li><strong>Important: 也是讲究成双成对出现的！一定要注意！</strong></li><li>运用场景：实时性要求最高的代码段（你看，你在中断里打开临界区，屏蔽了自己以外的所有FreeRTOS管理的中断，防止了中断嵌套的情况发生，保护在中断临界区的代码不被打扰</li><li>中断级临界段代码保护的使用方法如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定时器3中断服务函数 </span><br><span class="hljs-comment">// 假设定时器3的抢占优先级在FreeRTOS的调度范围内</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM3_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(TIM_GetITStatus(TIM3, TIM_IT_Update) == SET)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> Status_Value = taskENTER_CRITICAL_FROM_ISR();<br><br>        <span class="hljs-comment">// 你的代码段...</span><br>        <span class="hljs-comment">// 这里是中断临界区，屏蔽所有可被FreeRTOS调度的中断...</span><br><br>        taskEXIT_CRITICAL_FROM_ISR(Status_Value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="2-1-任务状态"><a href="#2-1-任务状态" class="headerlink" title="2.1 任务状态"></a>2.1 任务状态</h3><ul><li>运行态</li><li>就绪态</li><li>阻塞态</li><li>挂起态</li></ul><hr><h3 id="2-2-任务的创建"><a href="#2-2-任务的创建" class="headerlink" title="2.2 任务的创建"></a>2.2 任务的创建</h3><h4 id="2-2-1-任务创建的API函数"><a href="#2-2-1-任务创建的API函数" class="headerlink" title="2.2.1 任务创建的API函数"></a>2.2.1 任务创建的API函数</h4><blockquote><p>函数 <strong><code>xTaskCreate()</code></strong> ，又名你会用的最多的函数。</p><ul><li>用于动态创建一个任务，RAM会自行从FreeRTOS的堆中分配出来。</li></ul></blockquote><ul><li><code>xTaskCreate()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值 pdPASS-&gt;任务创建成功 / errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY-&gt;堆内存不足，创建任务失败</span><br>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t          pxTaskCode, <span class="hljs-comment">// 任务函数</span></span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span>      pcName, <span class="hljs-comment">// 任务名字</span></span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span>          usStackDepth, <span class="hljs-comment">// 任务堆栈大小，实际申请到的堆栈是usStackDepth的4倍</span></span><br><span class="hljs-params">                        <span class="hljs-type">void</span> * <span class="hljs-type">const</span>            pvParameters, <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">                        UBaseType_t             uxPriority, <span class="hljs-comment">// 任务优先级</span></span><br><span class="hljs-params">                        TaskHandle_t * <span class="hljs-type">const</span>    pxCreatedTask <span class="hljs-comment">// 任务句柄</span></span><br><span class="hljs-params">                        )</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-任务删除的API函数"><a href="#2-2-2-任务删除的API函数" class="headerlink" title="2.2.2 任务删除的API函数"></a>2.2.2 任务删除的API函数</h4><blockquote><p>函数 <strong><code>xTaskDelete()</code></strong></p><ul><li>删除一个用<code>xTaskCreate()</code>或者<code>xTaskCreateStatic()</code>创建的任务。</li><li>任务被删除之后，任务不复存在，关于被删除的任务的句柄不能再被使用，除非这个任务重新创建起来。</li><li>如果任务是由<code>xTaskCreate()</code>创建的（由动态方法创建），那么任务被删除以后，任务的堆栈将在<strong>空闲任务</strong>中得到<strong>释放</strong>，所以删除动态方法创建的任务以后要给空闲任务一些时间来释放空间哦！</li></ul></blockquote><ul><li><code>xTaskDelete()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无返回值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span> <span class="hljs-comment">// xTaskToDelete是要被删除的任务的任务句柄</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3-任务创建与删除的程序示例（动态方法）"><a href="#2-2-3-任务创建与删除的程序示例（动态方法）" class="headerlink" title="2.2.3 任务创建与删除的程序示例（动态方法）"></a>2.2.3 任务创建与删除的程序示例（动态方法）</h4><ul><li>简单的总结分析一下此例程的流程，因为这是我们使用 FreeRTOS 写的第一个程序，很多习惯是我们后面要用到的。比如使用任务宏定义任务优先级，堆栈大小等，一般有关一个任务的东西我们的放到一起，比如任务堆栈、任务句柄、任务函数声明等，这样方便修改。这些东西可以放到一个.h 头文件里面去，只是例程里面任务数比较少，所以就直接放到 main.c 文件里面了，要是工程比较大的话最好做一个专用的头文件来管理。</li></ul><h4 id="2-2-4-任务创建与删除的程序示例（静态方法）"><a href="#2-2-4-任务创建与删除的程序示例（静态方法）" class="headerlink" title="2.2.4 任务创建与删除的程序示例（静态方法）"></a>2.2.4 任务创建与删除的程序示例（静态方法）</h4><ul><li>和动态方法比较不同的是，想要使用静态方法，你必须自己实现两个接口函数<code>vApplicationGetIdleTaskMemory()</code>和<code>vApplicationGetTimerTaskMemory()</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 空闲任务任务堆栈 // 分配了静态的RAM啦</span><br><span class="hljs-type">static</span> StackType_t IdleTaskStack[configMINIMAL_STACK_SIZE];<br><span class="hljs-comment">// 空闲任务控制块</span><br><span class="hljs-type">static</span> StaticTask_t IdleTaskTCB;<br><br><span class="hljs-comment">// 定时器服务任务堆栈 // 分配了静态的RAM啦</span><br><span class="hljs-type">static</span> StackType_t TimerTaskStack[configTIMER_TASK_STACK_DEPTH];<br><span class="hljs-comment">// 定时器服务任务控制块</span><br><span class="hljs-type">static</span> StaticTask_t TimerTaskTCB;<br><br><span class="hljs-comment">// 获取空闲任务地任务堆栈和任务控制块内存，因为本例程使用的</span><br><span class="hljs-comment">// 静态内存，因此空闲任务的任务堆栈和任务控制块的内存就应该</span><br><span class="hljs-comment">// 有用户来提供，FreeRTOS提供了接口函数vApplicationGetIdleTaskMemory()</span><br><span class="hljs-comment">// 实现此函数即可。</span><br><span class="hljs-comment">// ppxIdleTaskTCBBuffer:任务控制块内存</span><br><span class="hljs-comment">// ppxIdleTaskStackBuffer:任务堆栈内存</span><br><span class="hljs-comment">// pulIdleTaskStackSize:任务堆栈大小</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationGetIdleTaskMemory</span><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer,</span><br><span class="hljs-params">    StackType_t **ppxIdleTaskStackBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> *pulIdleTaskStackSize)</span><br>&#123;<br>*ppxIdleTaskTCBBuffer = &amp;IdleTaskTCB;<br>*ppxIdleTaskStackBuffer = IdleTaskStack;<br>*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;<br>&#125;<br><br><span class="hljs-comment">// 获取定时器服务任务的任务堆栈和任务控制块内存</span><br><span class="hljs-comment">// ppxTimerTaskTCBBuffer:任务控制块内存</span><br><span class="hljs-comment">// ppxTimerTaskStackBuffer:任务堆栈内存</span><br><span class="hljs-comment">// pulTimerTaskStackSize:任务堆栈大小</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationGetTimerTaskMemory</span><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer,</span><br><span class="hljs-params">    StackType_t **ppxTimerTaskStackBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> *pulTimerTaskStackSize)</span><br>&#123;<br>*ppxTimerTaskTCBBuffer = &amp;TimerTaskTCB;<br>*ppxTimerTaskStackBuffer = TimerTaskStack;<br>*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-x-x-任务控制块"><a href="#2-x-x-任务控制块" class="headerlink" title="2.x.x 任务控制块"></a>2.x.x 任务控制块</h4><h4 id="2-x-x-任务堆栈"><a href="#2-x-x-任务堆栈" class="headerlink" title="2.x.x 任务堆栈"></a>2.x.x 任务堆栈</h4><hr><h3 id="2-3-任务挂起和恢复"><a href="#2-3-任务挂起和恢复" class="headerlink" title="2.3 任务挂起和恢复"></a>2.3 任务挂起和恢复</h3><h4 id="2-3-1-任务挂起的API函数"><a href="#2-3-1-任务挂起的API函数" class="headerlink" title="2.3.1 任务挂起的API函数"></a>2.3.1 任务挂起的API函数</h4><blockquote><p>函数 <strong><code>vTaskSuspend()</code></strong></p><ul><li>该函数用于将某个任务设置为挂起态，任务挂起以后就不会被运行，直到使用<code>vTaskResume()</code>或者<code>xTaskResumeFromISR()</code>结束任务的挂起态。</li></ul></blockquote><ul><li><code>vTaskSuspend()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无返回值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span> <span class="hljs-comment">// xTaskToSuspend将要被挂起任务的任务句柄 </span><br>                                                 <span class="hljs-comment">// 注意！如果参数为NULL，表示挂起任务自己。</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-任务恢复的API函数"><a href="#2-3-2-任务恢复的API函数" class="headerlink" title="2.3.2 任务恢复的API函数"></a>2.3.2 任务恢复的API函数</h4><blockquote><p>函数 <strong><code>vTaskResume()</code></strong> ，在主程序中调用</p><ul><li>该函数可以也只可以将先前使用<code>vTaskSuspend()</code>函数挂起的任务恢复到就绪态。</li></ul></blockquote><ul><li><code>vTaskResume()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无返回值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span> <span class="hljs-comment">// 将要被恢复任务的任务句柄</span><br></code></pre></td></tr></table></figure><blockquote><p>函数 <strong><code>xTaskResumeFromISR()</code></strong> ，在中断函数中调用</p><ul><li>该函数是<code>vTaskResume()</code>函数的中断版本，需要在中断里调用哈。</li><li>该函数可以也只可以将先前使用<code>vTaskSuspend()</code>函数挂起的任务恢复到就绪态。</li></ul></blockquote><ul><li><code>xTaskResumeFromISR()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdTRUE-&gt;恢复的任务优先级 &gt;= 当前任务的优先级，所以在退出中断函数后要进行一次上下文切换</span><br><span class="hljs-comment">// 返回值：pdFALSE-&gt;恢复的任务优先级 &lt; 当前任务的优先级，所以在退出中断函数后不需要进行一次上下文切换</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span> <span class="hljs-comment">// 将要被恢复任务的任务句柄</span><br></code></pre></td></tr></table></figure><h4 id="2-3-3-任务挂起和恢复程序示例"><a href="#2-3-3-任务挂起和恢复程序示例" class="headerlink" title="2.3.3 任务挂起和恢复程序示例"></a>2.3.3 任务挂起和恢复程序示例</h4><hr><h3 id="3-1-列表和列表项"><a href="#3-1-列表和列表项" class="headerlink" title="3.1 列表和列表项"></a>3.1 列表和列表项</h3><h4 id="3-1-1-列表"><a href="#3-1-1-列表" class="headerlink" title="3.1.1 列表"></a>3.1.1 列表</h4><p>为啥要有列表？不是已经可以创建任务运行任务了吗？我的理解是，在做一些大型项目的时候，往往要根据不同的场景执行不同的任务，有时任务比较多了，创建任务和删除任务这些操作就变得弯弯绕绕了。这个时候把任务们归类进不同的列表中，那我切换运用场景的时候，直接切换目前正在执行的列表就行啦！就不用一个一个对任务进行操作，避免了麻烦。</p><ul><li>列表，是FreeRTOS中的一个数据结构，和链表有点像，是被用做跟踪FreeRTOS中的任务的</li><li>列表项就是存放在列表当中的项目</li><li>列表相当于链表，列表项相当于节点，FreeRTOS中的列表是一个双向环形链表</li><li>常见的列表包括：就绪列表、阻塞列表、挂起列表（目前自己做列表的情况比较少，都是RTOS自动帮我们做好的）</li></ul><h4 id="3-1-2-列表项"><a href="#3-1-2-列表项" class="headerlink" title="3.1.2 列表项"></a>3.1.2 列表项</h4><ul><li>列表项，就是存放在列表中的项目。</li><li>FreeRTOS提供了两种列表项：列表项和迷你列表项。</li></ul><hr><h3 id="4-1-调度器"><a href="#4-1-调度器" class="headerlink" title="4.1 调度器"></a>4.1 调度器</h3><blockquote><p>函数 <strong><code>vTaskStartScheduler()</code></strong> ，开启任务调度器</p><ul><li>在<code>main()</code>函数里，创建好所需的任务后，即可调用<code>vTaskStartScheduler()</code>让任务开始运行吧。</li></ul></blockquote><blockquote><p>函数 <strong><code>vTaskEndScheduler()</code></strong> ，关闭任务调度器</p></blockquote><blockquote><p>函数 <strong><code>vTaskSuspendAll()</code></strong> ，挂起任务调度器，就是挂起所有任务</p></blockquote><blockquote><p>函数 <strong><code>vTaskResumeAll()</code></strong> ，恢复任务调度器，就是恢复所有任务</p></blockquote><h3 id="4-2-空闲任务"><a href="#4-2-空闲任务" class="headerlink" title="4.2 空闲任务"></a>4.2 空闲任务</h3><blockquote><ul><li>调用<code>vTaskStartScheduler()</code>时候，此函数会自动创建一个名为<code>IDLE</code>的任务，这个就是空闲任务！它是FreeRTOS系统自动创建的，不需要用户手动创建。而且任务调动器启动以后必须至少有一个任务在运行中，所以这也是空闲任务存在的意义之一。</li><li>空闲任务的优先级最低，是0！任务函数为<code>prvIdleTask()</code>（是啥？</li><li>空闲任务的作用如下：<blockquote><ul><li>如果系统有任务被删除，被删除的任务的堆栈和任务控制块的内存会在空闲任务中得到释放哦！</li><li>运行用户设置的空闲任务钩子函数（？啥是钩子</li><li>判断是否开启低功耗tickless模式，如果开启的话还需要做相应的处理（？</li></ul></blockquote></li></ul></blockquote><h3 id="4-3-延时函数"><a href="#4-3-延时函数" class="headerlink" title="4.3 延时函数"></a>4.3 延时函数</h3><blockquote><p>函数 <strong><code>xTaskDelay()</code></strong> ，延时多少时间，用于固定延时（常用的普通的延时函数）</p></blockquote><blockquote><p>函数 <strong><code>xTaskDelayUntil()</code></strong> ，每隔多少时间执行一次函数，用于周期性执行</p></blockquote><hr><h3 id="5-1-队列"><a href="#5-1-队列" class="headerlink" title="5.1 队列"></a>5.1 队列</h3><ul><li>队列是任务到任务、任务到中断、中断到任务数据交流的一种机制（消息传递</li><li>写队列和读队列的api函数都会自动进入临界区操作的</li><li>在队列中可以存储数量有限、大小固定的数据。队列中的每一个数据叫做“队列项目”，队列能够存储“队列项目”的最大数量成为队列的长度</li></ul><h3 id="5-2-二值信号量"><a href="#5-2-二值信号量" class="headerlink" title="5.2 二值信号量"></a>5.2 二值信号量</h3><ul><li><p>二值信号量：其实就是一个只有一个队列项的队列，这个特殊的队列要么是满的，要么是空的，这正好是二值！</p></li><li><p>任务和中断使用这个特殊队列不用在乎队列中存的是什么消息，只需要知道这个队列是满的还是空的，就可以利用这个机制来完成任务与中断之间的同步！</p></li></ul><h4 id="5-2-1-二值信号量创建的API函数"><a href="#5-2-1-二值信号量创建的API函数" class="headerlink" title="5.2.1 二值信号量创建的API函数"></a>5.2.1 二值信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateBinary()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateBinary()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;信号量创建失败；其他-&gt;创建成功的信号量的句柄</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinary</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br></code></pre></td></tr></table></figure><h4 id="5-2-2-二值信号量释放的API函数"><a href="#5-2-2-二值信号量释放的API函数" class="headerlink" title="5.2.2 二值信号量释放的API函数"></a>5.2.2 二值信号量释放的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreGive()</code></strong> ，任务级信号量释放函数<br>函数 <strong><code>xSemaphoreGiveISR()</code></strong> ，中断级信号量释放函数</p></blockquote><ul><li><code>xSemaphoreGive()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：errQUEUE_FULL-&gt;信号量释放失败；pdPASS-&gt;信号量释放成功</span><br><span class="hljs-comment">// 参数： xSemaphore-&gt;要释放的信号量句柄</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGive</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore )</span> <br></code></pre></td></tr></table></figure><ul><li><code>xSemaphoreGiveISR()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：errQUEUE_FULL-&gt;信号量释放失败；pdPASS-&gt;信号量释放成功</span><br><span class="hljs-comment">// 参数：xSemaphore-&gt;要释放的信号量句柄</span><br><span class="hljs-comment">// 参数：pxHigherPriorityTaskWoken-&gt;标记退出此函数是否进行任务切换，用户要做的就是</span><br><span class="hljs-comment">// 提供一个变量来保存这个值，在退出中断函数前判断一下这个变量，当这个值为pdTRUE时</span><br><span class="hljs-comment">// 在退出中断函数之前一定要做一次任务切换taskYIELD()！</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGiveISR</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore, BaseType_t* pxHigherPriorityTaskWoken )</span> <br></code></pre></td></tr></table></figure><h4 id="5-2-3-二值信号量获取的API函数"><a href="#5-2-3-二值信号量获取的API函数" class="headerlink" title="5.2.3 二值信号量获取的API函数"></a>5.2.3 二值信号量获取的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreTake()</code></strong> ，任务级信号量释放函数<br>函数 <strong><code>xSemaphoreTakeISR()</code></strong> ，中断级信号量释放函数</p></blockquote><ul><li><code>xSemaphoreTake()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFALSE-&gt;信号量获取失败；pdTRUE-&gt;信号量获取成功</span><br><span class="hljs-comment">// 参数： xSemaphore-&gt;要释放的信号量句柄</span><br><span class="hljs-comment">// 参数：xBlockTime-&gt;阻塞时间</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTake</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore, TickType_t xBlockTime )</span> <br></code></pre></td></tr></table></figure><ul><li><code>xSemaphoreTakeISR()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFALSE-&gt;信号量获取失败；pdTRUE-&gt;信号量获取成功</span><br><span class="hljs-comment">// 参数：xSemaphore-&gt;要获取信号量句柄</span><br><span class="hljs-comment">// 参数：pxHigherPriorityTaskWoken-&gt;标记退出此函数是否进行任务切换，用户要做的就是</span><br><span class="hljs-comment">// 提供一个变量来保存这个值，在退出中断函数前判断一下这个变量，当这个值为pdTRUE时</span><br><span class="hljs-comment">// 在退出中断函数之前一定要做一次任务切换taskYIELD()！</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTakeISR</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore, BaseType_t* pxHigherPriorityTaskWoken )</span> <br></code></pre></td></tr></table></figure><h3 id="5-3-计数型信号量"><a href="#5-3-计数型信号量" class="headerlink" title="5.3 计数型信号量"></a>5.3 计数型信号量</h3><ul><li>计数型信号量就是读取这个队列项的数值，获取信号量的时候自减，释放信号量的时候自增，本质就是一个带值的二值信号量</li></ul><h4 id="5-3-1-计数型信号量创建的API函数"><a href="#5-3-1-计数型信号量创建的API函数" class="headerlink" title="5.3.1 计数型信号量创建的API函数"></a>5.3.1 计数型信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateCounting()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateCounting()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;计数型信号量创建失败；其他-&gt;创建成功的计数型信号量的句柄</span><br><span class="hljs-comment">// 参数：uxMaxCount-&gt;计数信号量的最大值，当信号量值等于此值时，释放信号量会失败，因为已经满了</span><br><span class="hljs-comment">// 参数：uxInitialCount-&gt;计数信号量的初值</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCounting</span><span class="hljs-params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span> <br></code></pre></td></tr></table></figure><h4 id="5-3-2-计数型信号量释放与获取的API函数"><a href="#5-3-2-计数型信号量释放与获取的API函数" class="headerlink" title="5.3.2 计数型信号量释放与获取的API函数"></a>5.3.2 计数型信号量释放与获取的API函数</h4><p><strong>计数型信号量的释放和获取与二值信号量相同！请看5.2.2和5.2.3！</strong></p><h3 id="5-4-互斥信号量"><a href="#5-4-互斥信号量" class="headerlink" title="5.4 互斥信号量"></a>5.4 互斥信号量</h3><ul><li>但是呢，使用二值信号量可能会导致优先级反转的问题，这个时候我们可以使用！互斥信号量！</li><li>互斥信号量其实就是一个拥有优先级继承的二值信号量。</li><li>注意：创建互斥信号量时，会主动释放一次信号量！就是你可以直接获取到！而二值信号量和计数型信号量不行，它们需要手动释放第一次信号量。</li><li><strong>互斥信号量有优先级继承机制，所以只能用在任务中，不能用于中断服务函数中！</strong></li></ul><h4 id="5-4-1-互斥信号量创建的API函数"><a href="#5-4-1-互斥信号量创建的API函数" class="headerlink" title="5.4.1 互斥信号量创建的API函数"></a>5.4.1 互斥信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateMutex()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateMutex()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;信号量创建失败；其他-&gt;创建成功的信号量的句柄</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br></code></pre></td></tr></table></figure><h4 id="5-4-2-互斥信号量释放与获取的API函数"><a href="#5-4-2-互斥信号量释放与获取的API函数" class="headerlink" title="5.4.2 互斥信号量释放与获取的API函数"></a>5.4.2 互斥信号量释放与获取的API函数</h4><p><strong>互斥信号量的释放和获取与二值信号量相同！请看5.2.2和5.2.3！</strong></p><h3 id="5-5-递归互斥信号量"><a href="#5-5-递归互斥信号量" class="headerlink" title="5.5 递归互斥信号量"></a>5.5 递归互斥信号量</h3><ul><li>递归互斥信号量可以看作一个特殊的互斥信号量，已经获取了互斥信号量的任务就不能再次获取这个互斥信号量，但是递归互斥信号量不同，已经获取了递归互斥信号量的任务可以再次获取这个递归互斥任务而且次数不限！一个任务使用函数xSemaphoreTakeRecursive()成功的获取了多少次递归互斥信号量就得使用函数xSemaphoreGiveRecursive()释放多少次！</li><li>注意：要使用递归互斥信号量的话宏configUSE_RECURSIVE_MUTEXES必须为1！</li></ul><h4 id="5-5-1-递归互斥信号量创建的API函数"><a href="#5-5-1-递归互斥信号量创建的API函数" class="headerlink" title="5.5.1 递归互斥信号量创建的API函数"></a>5.5.1 递归互斥信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateRecursiveMutex()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateRecursiveMutex()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;信号量创建失败；其他-&gt;创建成功的信号量的句柄</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateRecursiveMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br></code></pre></td></tr></table></figure><h4 id="5-5-2-递归互斥信号量释放的API函数"><a href="#5-5-2-递归互斥信号量释放的API函数" class="headerlink" title="5.5.2 递归互斥信号量释放的API函数"></a>5.5.2 递归互斥信号量释放的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreGiveRecursive()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreGiveRecursive()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFAIL-&gt;信号量释放失败；pdPASS-&gt;信号量释放成功</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGiveRecursive</span><span class="hljs-params">( QueueHandle_t xMutex )</span> <br></code></pre></td></tr></table></figure><h4 id="5-5-3-递归互斥信号量获取的API函数"><a href="#5-5-3-递归互斥信号量获取的API函数" class="headerlink" title="5.5.3 递归互斥信号量获取的API函数"></a>5.5.3 递归互斥信号量获取的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreTakeRecursive()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreTakeRecursive()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFAIL-&gt;信号量获取失败；pdPASS-&gt;信号量获取成功</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTakeRecursive</span><span class="hljs-params">( QueueHandle_t xMutex, TickType_t xTicksTowait )</span> <br></code></pre></td></tr></table></figure><hr><h3 id="6-1-任务通知"><a href="#6-1-任务通知" class="headerlink" title="6.1 任务通知"></a>6.1 任务通知</h3><blockquote><p>任务通知的优势</p></blockquote><ul><li><strong>效率更高</strong>！如果使用任务通知来模拟二值信号量，速度快45%（官方测试）！</li><li><strong>使用内存更小</strong>，使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体</li></ul><blockquote><p>任务通知的劣势</p></blockquote><ul><li><strong>无法在中断服务函数中获得任务通知</strong>，你只能在中断服务函数中发送任务通知</li><li><strong>无法广播给多个任务（只能一个）</strong>，任务通知只能是被指定的一个任务接收并处理</li><li><strong>无法缓存多个数据（只能一个）</strong>，任务通知是通过更新任务通知值来发送数据的，任务结构体中只有一个任务通知值，只能保持一个数据</li></ul><h4 id="6-1-1-任务通知模拟二值信号量"><a href="#6-1-1-任务通知模拟二值信号量" class="headerlink" title="6.1.1 任务通知模拟二值信号量"></a>6.1.1 任务通知模拟二值信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br>xTaskNotifyGive(yourTaskHandler);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 接收任务成功后pdTRUE-&gt;任务通知值清零，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        <span class="hljs-keyword">if</span>(ulTaskNotifyTake(pdTRUE, portMAX_DELAY))<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-任务通知模拟计数型信号量"><a href="#6-1-2-任务通知模拟计数型信号量" class="headerlink" title="6.1.2 任务通知模拟计数型信号量"></a>6.1.2 任务通知模拟计数型信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br>xTaskNotifyGive(yourTaskHandler);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> rev = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 接收任务成功后pdFALSE-&gt;任务通知值自减，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        rev = ulTaskNotifyTake(pdFALSE, portMAX_DELAY);<br>        <span class="hljs-keyword">if</span>(rev)<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-3-任务通知模拟消息邮箱（传值）"><a href="#6-1-3-任务通知模拟消息邮箱（传值）" class="headerlink" title="6.1.3 任务通知模拟消息邮箱（传值）"></a>6.1.3 任务通知模拟消息邮箱（传值）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br><span class="hljs-comment">// valForTransfer-&gt;你想要传送的变量值，eSetValueWithOverwrite-&gt;设置成可覆写模式</span><br>xTaskNotify(yourTaskHandler, valForTransfer, eSetValueWithOverwrite);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> notifyVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 接收任务成功后，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span><span class="hljs-comment">/*传入值不改变*/</span>, <span class="hljs-number">0xFFFFFFFF</span><span class="hljs-comment">/*退出函数后传入值清零*/</span>, &amp;notifyVal, portMAX_DELAY);<br>        <span class="hljs-keyword">switch</span>(notifyVal)<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-4-任务通知模拟事件标志组"><a href="#6-1-4-任务通知模拟事件标志组" class="headerlink" title="6.1.4 任务通知模拟事件标志组"></a>6.1.4 任务通知模拟事件标志组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br><span class="hljs-comment">// EVENTBIT_X-&gt;你想要通知的第几个bit，eSetBits-&gt;设置成事件标志组模式</span><br>xTaskNotify(yourTaskHandler, EVENTBIT_0<span class="hljs-comment">/* 通知bit0 */</span>, eSetBits);<br><br>xTaskNotify(yourTaskHandler, EVENTBIT_1<span class="hljs-comment">/* 通知bit1 */</span>, eSetBits);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> notifyVal = <span class="hljs-number">0</span>, eventBit = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 接收任务成功后，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span><span class="hljs-comment">/*传入值不改变*/</span>, <span class="hljs-number">0xFFFFFFFF</span><span class="hljs-comment">/*退出函数后传入值清零*/</span>, &amp;notifyVal, portMAX_DELAY);<br>        <span class="hljs-keyword">if</span>(notifyVal &amp; EVENTBIT_0)<br>        &#123;<br>            eventBit |= EVENTBIT_0;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(notifyVal &amp; EVENTBIT_1)<br>        &#123;<br>            eventBit |= EVENTBIT_1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(eventBit == (EVENTBIT_0 | EVENTBIT_1))<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内核控制函数"><a href="#内核控制函数" class="headerlink" title="内核控制函数"></a>内核控制函数</h3><h4 id="任务切换的API函数"><a href="#任务切换的API函数" class="headerlink" title="任务切换的API函数"></a>任务切换的API函数</h4><blockquote><p>函数 <strong><code>taskYIELD()</code></strong> ，此函数用于进行任务切换，用的最多的就是出中断的优先级切换时</p></blockquote><h4 id="进入、退出临界区的API函数"><a href="#进入、退出临界区的API函数" class="headerlink" title="进入、退出临界区的API函数"></a>进入、退出临界区的API函数</h4><blockquote><p>函数 <strong><code>taskENTER_CRITICAL()</code></strong> ，进入临界区，用于任务级</p></blockquote><blockquote><p>函数 <strong><code>taskENTER_CRITICAL_FROM_ISR()</code></strong> ，进入临界区，用于中断级</p></blockquote><blockquote><p>函数 <strong><code>taskEXIT_CRITICAL()</code></strong> ，退出临界区，用于任务级</p></blockquote><blockquote><p>函数 <strong><code>taskEXIT_CRITICAL_FROM_ISR()</code></strong> ，退出临界区，用于中断级</p></blockquote><h4 id="中断打开、关闭的API函数"><a href="#中断打开、关闭的API函数" class="headerlink" title="中断打开、关闭的API函数"></a>中断打开、关闭的API函数</h4><blockquote><p>函数 <strong><code>taskENABLE_INTERRUPTS()</code></strong> ，打开中断</p></blockquote><blockquote><p>函数 <strong><code>taskDISABLE_INTERRUPTS()</code></strong> ，关闭中断</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git与VScode联合使用的源代码管理指南</title>
    <link href="/2023/12/09/GitxVScode-CodeManageGuide/GitxVScode-CodeManageGuide/"/>
    <url>/2023/12/09/GitxVScode-CodeManageGuide/GitxVScode-CodeManageGuide/</url>
    
    <content type="html"><![CDATA[<h1 id="GitxVScode-CodeManageGuide"><a href="#GitxVScode-CodeManageGuide" class="headerlink" title="GitxVScode-CodeManageGuide"></a>GitxVScode-CodeManageGuide</h1><h1 id="Git与VScode联合使用的源代码管理指南"><a href="#Git与VScode联合使用的源代码管理指南" class="headerlink" title="Git与VScode联合使用的源代码管理指南"></a>Git与VScode联合使用的源代码管理指南</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h2><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>建议有一点Git管理基础的人使用！至少你得Github有号吧，是吧！</li><li>这些指令其实并不常用，我们只是稍作理解，剩下的交给Vscode点点点吧！</li></ul><hr><h2 id="相关插件"><a href="#相关插件" class="headerlink" title="相关插件"></a>相关插件</h2><ul><li><p>Git Graph</p><ul><li>可以清晰地看到存储仓库的每一次提交(Commit)，每一个分支(Branch)，和每一次合并的记录，非常nice！</li><li>同时可以很方便的查询每一次的记录，进行文件代码比对。</li></ul></li><li><p>GitLens</p><ul><li>可以直接在源代码里看到每一行代码的更改时间！</li></ul></li><li><p>GitHistory</p><ul><li>和Git Graph功能类似，细节注重点不太一样。</li></ul></li></ul><hr><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><strong>提交(Commit)</strong><ul><li><code>git add .</code>添加所有被修改文件到暂存更改区</li><li><code>git commit -m &quot;massage&quot;</code> 提交暂存更改区的内容作为一个新版本，<code>massage</code>为该版本的关键字</li><li><code>-m</code>的作用就是可以不弹窗直接写关键字，如果你只输入<code>git commit</code>就会弹出一个窗口让你填写该版本的关键字。</li></ul></li></ul><blockquote><p>这个操作我们使用VScode自带的源代码管理来完成。<br>暂存我们所需的修改之后点击提交，接着会跳转到<code>COMMIT_EDITMSG</code>文件页面，顾名思义就是提交编辑信息。<br>你可以在这个文件最顶部写一些你这次提交的一些消息备注。写完保存，关掉这个文件页面，即可完成一次提交！</p></blockquote><ul><li><strong>推送(Push)</strong></li></ul><blockquote><p>这个操作需要我们的VScode关联自己的Github仓库后才可以使用。<br>提交之后，提交记录会暂存在我们本地的仓库内，如果想要把提交记录推送至Github，我们只需要在VScode的源代码管理里选择推送即可。<br>如果你Github没有创建相关的仓库，VScode也会弹窗让你创建的！</p></blockquote><ul><li><strong>签出到(Checkout)</strong></li></ul><blockquote><ul><li><code>git checkout branch_name</code>切换分支。 </li><li>切换分支的时候要保证当前暂存区没有需要修改的文件哦！可以用<code>git status</code>确保现在的状态是<code>clean</code>，否则就会切换分支失败了。</li></ul></blockquote><ul><li><strong>版本回退(Reset)</strong></li></ul><blockquote><p>有3种常用的回退方式，分别是<code>soft</code>, <code>mixed</code>, <code>hard</code></p></blockquote><blockquote><p>1.<code>git reset --soft &lt;Hash&gt;</code>（这里<code>&lt;Hash&gt;</code>是你的版本号哈！<br><code>soft</code>回退方式只会把Head指针往回指到你回退的版本，然后你仓库里的文件不会发生任何的增删，状态大概就是你已经commit了，但是没有push的状态。（？不知道理解的对不对</p></blockquote><blockquote><p>2.<code>git reset --mixed &lt;Hash&gt;</code><br><code>mixed</code>回退方式，会把Head指针往回指到我们希望回退到的版本，然后仓库里的文件也不会发生任何的增删（暂时），为什么说是暂时呢？因为它把你这个回退版本之后所有的commit都放回了暂存更改区，你就可以在暂存更改区里决定要恢复什么文件，恢复什么代码啦！</p></blockquote><blockquote><p>3.<code>git reset --hard &lt;Hash&gt;</code><br><code>hard</code>回退方式，会把Head指针往回指到我们希望回退到的版本，然后该版本号以后的版本统统都会不见使用<code>git log</code>时就看不见当前回退版本以后的版本号了（所以要谨慎！</p><ul><li>这种回退方式会简单粗暴的把你本地仓库回退版本的什么文件啊什么代码原封不动地一字不拉地归还它的原样！</li><li>当然，你仍然可以通过<code>git reflog</code>找回从前的版本号，然后使用<code>git reset --hard &lt;Hash&gt;</code>跳回去，<strong>理论上，你的代码不会丢，</strong> nice！</li><li><code>git reset --hard HEAD^</code>表示硬回退到<strong>上一个</strong>版本</li><li>同理<code>HEAD^^</code>表示<strong>上上个</strong>版本，<code>HEAD^^^</code>表示<strong>上上上个</strong>版本，而且你也可以用<code>HEAD~3</code>表示<strong>上上上个</strong>版本噢！</li></ul></blockquote><h2 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h2><h3 id="记录查看"><a href="#记录查看" class="headerlink" title="记录查看"></a>记录查看</h3><ul><li><code>git log</code></li></ul><blockquote><ul><li><code>git log</code>用来查看commit提交历史记录。</li><li><code>git log --graph</code>这条命令使用了就会有优雅的树状图可以看啦（也不算是树状图，反正就是图形化显示</li><li>在终端按<code>Q</code>键退出日志哦！</li></ul></blockquote><ul><li><code>git reflog</code></li></ul><blockquote><p>用来查看Git仓库的所有git命令操作的历史记录，比如你用过的<code>reset</code>, <code>checkout</code>, <code>commit</code>, <code>push</code> 的记录都能在这里看到。</p></blockquote><ul><li><code>git status</code></li></ul><blockquote><p>用来查看本地仓库状态。</p></blockquote><h3 id="分支查找"><a href="#分支查找" class="headerlink" title="分支查找"></a>分支查找</h3><ul><li><code>git branch</code></li></ul><blockquote><ul><li><code>git branch</code>用来查看当前所在的分支。</li><li><code>git branch -v</code>用来查看当前所在分支最后一次提交的版本号和版本关键字。</li><li><code>git branch branch_name</code>用来创建名字为<code>branch_name</code>的新分支。</li></ul></blockquote><h3 id="远程仓库克隆"><a href="#远程仓库克隆" class="headerlink" title="远程仓库克隆"></a>远程仓库克隆</h3><ul><li><code>git clone</code></li></ul><blockquote><ul><li><code>git clone &lt;address&gt;</code>老熟人了，打开一个文件夹，打开它的命令行窗口，你就敲上面的命令，<code>&lt;address&gt;</code>是被克隆的远程仓库的地址。就这个命令可以完成目前所有开源项目90%的克隆。</li><li><code>git clone --recursive &lt;address&gt;</code>剩下的10%就比较专业一点，可能人家远程代码库里运用了别人的子项目，你直接克隆下来就是个空文件夹，所以你就需要用这个命令来<strong>递归</strong>克隆！把别人子项目的内容也可以克隆下来！</li></ul></blockquote><h3 id="本地仓库初始化"><a href="#本地仓库初始化" class="headerlink" title="本地仓库初始化"></a>本地仓库初始化</h3><ul><li><code>git init</code></li></ul><blockquote><p>在该文件夹下初始化git仓库</p></blockquote><h3 id="本地仓库全局配置"><a href="#本地仓库全局配置" class="headerlink" title="本地仓库全局配置"></a>本地仓库全局配置</h3><ul><li><code>git config</code></li></ul><blockquote><p>在初始化完成Git本地仓库后，开始正式使用前，是需要有一些全局设置的，如用户名、邮箱等</p><ul><li><code>git config --global user.name &quot;your name&quot;</code>用于设置全局用户名</li><li><code>git config --global uer.email &quot;your email&quot;</code>用于设置全局邮箱<br>其中，<code>--global</code>指定全局配置，不使用该参数，则为当前所在仓库配置。</li></ul></blockquote><blockquote><p>我的Github用户名和邮箱：</p></blockquote><script >function checkPassword() {  var password = document.getElementById("password").value;  if (password === "0000") {  document.getElementById("user").style.display = "block";  } else {  alert("不准偷看！！！");  document.getElementById("user").style.display = "none";  }}</script><body title="哒咩">  口令是什么？  <input type="password" id="password">  <button onclick="checkPassword()" style="border-radius: 5px;">确认</button>  <div id="user" style="display: none;">    <p>俺滴Github用户名：ZhangKeLiang0627</p>    <p>俺滴Github邮箱：111654293+ZhangKeLiang0627@users.noreply.github.com</p>  </div></body><style>  input[type="password"] {    padding: 3px;    margin: 5px;    border: 1px solid #ccc;    border-radius: 5px;  }  #user {    display: none;    background-color: #f4f4f4;    padding: 5px;    margin-top: 10px;    border-radius: 5px;    box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);  }</style><blockquote><p>注意我的不是你的哦🫸</p></blockquote><blockquote><p>于是可以如下配置：<br><code>git config --global user.name &quot;xxx&quot;</code><br><code>git config --global uer.email &quot;xxx.example.com&quot;</code></p></blockquote><blockquote><p>可以输入以下两条指令，检查用户名和邮箱是否输入正确。<br><code>git config user.name</code><br><code>git config user.email</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在单片机环境下移植Lua</title>
    <link href="/2023/11/14/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/"/>
    <url>/2023/11/14/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/</url>
    
    <content type="html"><![CDATA[<h1 id="在单片机环境下移植Lua🤗"><a href="#在单片机环境下移植Lua🤗" class="headerlink" title="在单片机环境下移植Lua🤗"></a>在单片机环境下移植Lua🤗</h1><h2 id="软件：keil"><a href="#软件：keil" class="headerlink" title="软件：keil"></a>软件：keil</h2><h2 id="所需环境：Malloc、Fatfs"><a href="#所需环境：Malloc、Fatfs" class="headerlink" title="所需环境：Malloc、Fatfs"></a>所需环境：Malloc、Fatfs</h2><ul><li>声明这里使用的是正点原子家的源码，感谢！</li><li>上述环境是为了实现Lua能够从外置存储介质读取文件所准备的，如果没有需求可以不用</li></ul><h2 id="主控：STM32F401RET6"><a href="#主控：STM32F401RET6" class="headerlink" title="主控：STM32F401RET6"></a>主控：STM32F401RET6</h2><ul><li>运行频率：84MHz</li><li>ROM:512KB</li><li>RAM:96KB</li></ul><h2 id="移植版本：Lua-v5-3"><a href="#移植版本：Lua-v5-3" class="headerlink" title="移植版本：Lua-v5.3"></a>移植版本：Lua-v5.3</h2><h3 id="lua-lua-at-v5-3-github-com"><a href="#lua-lua-at-v5-3-github-com" class="headerlink" title="(lua&#x2F;lua at v5.3 (github.com))"></a><strong>(<a href="https://github.com/lua/lua/tree/v5.3">lua&#x2F;lua at v5.3 (github.com)</a>)</strong></h3><ul><li>具体版本是Lua-v5.3.5</li></ul><h2 id="关于Lua"><a href="#关于Lua" class="headerlink" title="关于Lua"></a>关于Lua</h2><p>Lua 语言是由巴西里约热内卢天主教大学 ([Pontifical Catholic University of Rio de janeiro ) 里的一个研究小组与 1993年开发的一种<strong>轻量小巧</strong>的<strong>脚本（弱语言）语言</strong>，用标准 C 语言编写，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p>作为一种扩展语言，Lua 没有“主”程序的概念：它嵌入在宿主客户端中运行，称为嵌入程序或简称为宿主。（通常这个宿主是单机lua程序） <strong>宿主程序可以调用函数执行一段Lua代码，可以读写Lua变量，可以注册Lua代码调用的C函数</strong>。通过使用 C 函数，可以增强 Lua 以应对广泛的不同领域，从而创建共享语法框架的定制编程语言。</p><ul><li>简单来说，Lua是一种轻量级的基于C编写的运行高效的脚本语言（解释性语言like：Python、shell、Matlab等。</li><li>在单片机环境下移植Lua，因为Lua和C的超级无敌兼容性，相当于你同时拥有了两种语言加持（C和Lua），你可以直接用Lua内部提供的几个简单的API，使得C内运行Lua脚本，特别方便，避免了重复烧录的麻烦。</li><li><strong>Lua解释器的移植，最小占用ROM: 70KB，占用RAM: 7.5KB(很小很小)</strong></li><li>简单的lua程序跟C程序效率比是1：100。而lua运算量越大。与C程序效率差距就越小。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>在github上拉取Lua-v5.3的版本库(<a href="https://github.com/lua/lua/tree/v5.3">lua&#x2F;lua at v5.3 (github.com)</a>)</li><li>建立一个基于主控STM32F401RET6的Keil文件(已经有的话就不需要，直接哐哐移植)</li></ol><h2 id="开始移植"><a href="#开始移植" class="headerlink" title="开始移植"></a>开始移植</h2><h4 id="移植Lua库文件"><a href="#移植Lua库文件" class="headerlink" title="移植Lua库文件"></a>移植Lua库文件</h4><ol><li>将github上拉取的 lua-5.3 文件夹移入工程文件夹。</li><li>打开Keil，点击魔术棒，将..\lua-5.3 相对路径添加到环境变量。</li><li>点击三个盒子，创建一个文件夹命名为Lua，将..\lua-5.3 相对路径下的所有.c文件（除了Lua.c和Luac.c以外，如果有的话，没有就不管）添加到其中。</li><li>更改 loslib.c 文件下部分内容：</li></ol><blockquote><ol><li>将 <strong>os_exit(lua_State * L)</strong> 函数中 <strong>if(L) exit(status)</strong> 注释，并添加 <strong>status&#x3D;status</strong> 语句。</li><li>添加 <strong>time(time_t *time)</strong> 和 <strong>system(const char * string)</strong> 。</li><li>将魔术棒里的 <strong>Use MicroLIB</strong> 模式关闭（不打勾！）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">os_exit</span> <span class="hljs-params">(lua_State *L)</span> &#123;<br>  <span class="hljs-type">int</span> status;<br>  <span class="hljs-keyword">if</span> (lua_isboolean(L, <span class="hljs-number">1</span>))<br>    status = (lua_toboolean(L, <span class="hljs-number">1</span>) ? EXIT_SUCCESS : EXIT_FAILURE);<br>  <span class="hljs-keyword">else</span><br>    status = (<span class="hljs-type">int</span>)luaL_optinteger(L, <span class="hljs-number">1</span>, EXIT_SUCCESS);<br>  <span class="hljs-keyword">if</span> (lua_toboolean(L, <span class="hljs-number">2</span>))<br>    lua_close(L);<br><span class="hljs-comment">/* &#x27;if&#x27; to avoid warnings for unreachable &#x27;return&#x27; */</span><br>  <span class="hljs-comment">//if (L) exit(status);  </span><br><br>  status=status;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-type">time_t</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> *time)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">system</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-built_in">string</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>最后可以去<strong>linit.c</strong>注释一些用不到的Lua库，当然，不注释也不会影响太大。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">** these libs are loaded by lua.c and are readily available to any Lua</span><br><span class="hljs-comment">** program</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> luaL_Reg loadedlibs[] = &#123;<br>  &#123;<span class="hljs-string">&quot;_G&quot;</span>, luaopen_base&#125;,<br>  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,<br>  &#123;LUA_COLIBNAME, luaopen_coroutine&#125;,<br>  &#123;LUA_TABLIBNAME, luaopen_table&#125;,<br><span class="hljs-comment">//  &#123;LUA_IOLIBNAME, luaopen_io&#125;,</span><br><span class="hljs-comment">//  &#123;LUA_OSLIBNAME, luaopen_os&#125;,</span><br>  &#123;LUA_STRLIBNAME, luaopen_string&#125;,<br>  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,<br>  &#123;LUA_UTF8LIBNAME, luaopen_utf8&#125;,<br><span class="hljs-comment">//  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LUA_COMPAT_BITLIB)</span><br>  &#123;LUA_BITLIBNAME, luaopen_bit32&#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="添加retarget-c"><a href="#添加retarget-c" class="headerlink" title="添加retarget.c"></a>添加retarget.c</h4><blockquote><ul><li>放哪随意，我基于正点原子的工程放在了system的文件夹中</li><li>引进这个库的目的是为了实现Lua从外置的存储介质中获取文件内容，我们需要用Fatfs的API去实现Lua所需的fopen、fclose、fread等函数（如果没有这个需求，可以跳过此步骤）</li><li>声明本次移植使用的Fatfs，来自正点原子的Fatfs实验源码，好用爱用，给个好评。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rt_sys.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;usart.h&quot;</span></span><br><br><span class="hljs-comment">// 是否将fopen与FatFS关联起来</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FATFS_EN 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ff.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// #pragma import(__use_no_semihosting) // 禁用半主机模式 //已经在usart.c中定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> import(__use_no_semihosting_swi) <span class="hljs-comment">// 即不使用半主机模式，防止程序进入软件中断</span></span><br><span class="hljs-comment">// #pragma import(_main_redirection)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDIN 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDOUT 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDERR 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_STD(fh) ((fh) &gt;= 0 &amp;&amp; (fh) &lt;= 2)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These names are used during library initialization as the</span><br><span class="hljs-comment"> * file names opened for stdin, stdout, and stderr.</span><br><span class="hljs-comment"> * As we define _sys_open() to always return the same file handle,</span><br><span class="hljs-comment"> * these can be left as their default values.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __stdin_name[] = <span class="hljs-string">&quot;:kkl&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __stdout_name[] = <span class="hljs-string">&quot;kkl&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __stderr_name[] = <span class="hljs-string">&quot;kkl&quot;</span>;<br><br>FILEHANDLE _sys_open(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> openmode)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    BYTE mode;<br>    FIL *fp;<br>    FRESULT fr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (name == __stdin_name)<br>        <span class="hljs-keyword">return</span> STDIN;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == __stdout_name)<br>    &#123;<br>        uart_init(<span class="hljs-number">115200</span>); <span class="hljs-comment">// 初始化串口 (在main函数执行前执行)</span><br>        <span class="hljs-keyword">return</span> STDOUT;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == __stderr_name)<br>        <span class="hljs-keyword">return</span> STDERR;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(FILEHANDLE) &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *))<br>    &#123;<br>        USART1_SendBuf(<span class="hljs-string">&quot;sizeof(FILEHANDLE) should be no less than sizeof(void *)!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    fp = ff_memalloc(<span class="hljs-keyword">sizeof</span>(FIL)); <span class="hljs-comment">// 使用自己的malloc函数替换</span><br>    <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">/* http://elm-chan.org/fsw/ff/doc/open.html */</span><br>    <span class="hljs-keyword">if</span> (openmode &amp; OPEN_W)<br>    &#123;<br>        mode = FA_CREATE_ALWAYS | FA_WRITE;<br>        <span class="hljs-keyword">if</span> (openmode &amp; OPEN_PLUS)<br>            mode |= FA_READ;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (openmode &amp; OPEN_A)<br>    &#123;<br>        mode = FA_OPEN_APPEND | FA_WRITE;<br>        <span class="hljs-keyword">if</span> (openmode &amp; OPEN_PLUS)<br>            mode |= FA_READ;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mode = FA_READ;<br>        <span class="hljs-keyword">if</span> (openmode &amp; OPEN_PLUS)<br>            mode |= FA_WRITE;<br>    &#125;<br><br>    fr = f_open(fp, name, mode);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">uintptr_t</span>)fp;<br><br>    ff_memfree(fp); <span class="hljs-comment">// 使用自己的free函数替换</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> _sys_close(FILEHANDLE fh)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (IS_STD(fh))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fh == STDOUT)<br>            <span class="hljs-comment">// usart_deinit();</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    fr = f_close((FIL *)fh);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>    &#123;<br>        ff_memfree((<span class="hljs-type">void</span> *)fh);<span class="hljs-comment">// 使用自己的free函数替换</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> _sys_write(FILEHANDLE fh, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">unsigned</span> len, <span class="hljs-type">int</span> mode)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br>    UINT bw;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (fh == STDIN)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (fh == STDOUT || fh == STDERR)<br>    &#123;<br>        USART1_SendBuf((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)buf);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    fr = f_write((FIL *)fh, buf, len, &amp;bw);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>        <span class="hljs-keyword">return</span> len - bw;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> _sys_read(FILEHANDLE fh, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">unsigned</span> len, <span class="hljs-type">int</span> mode)<br>&#123;<br>    <span class="hljs-comment">// char ch;</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br>    UINT br;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (fh == STDIN)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; len)<br>        &#123;<br>            <span class="hljs-comment">//     ch = usart_receive(); // 这里需要实现串口收到字符串传入buf的功能</span><br>            <span class="hljs-comment">//     if (isprint(ch))</span><br>            <span class="hljs-comment">//     &#123;</span><br>            <span class="hljs-comment">//         buf[i++] = ch;</span><br>            <span class="hljs-comment">//         usart_send(ch);</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">//     else if (ch == &#x27;\r&#x27;)</span><br>            <span class="hljs-comment">//     &#123;</span><br>            <span class="hljs-comment">//         buf[i++] = &#x27;\n&#x27;;</span><br>            <span class="hljs-comment">//         usart_send(&#x27;\n&#x27;);</span><br>            <span class="hljs-comment">//         break;</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">//     else if (i &gt; 0 &amp;&amp; ch == &#x27;\b&#x27;)</span><br>            <span class="hljs-comment">//     &#123;</span><br>            <span class="hljs-comment">//         i--;</span><br>            <span class="hljs-comment">//         usart_send_string(&quot;\b \b&quot;, 3);</span><br>            <span class="hljs-comment">//     &#125;</span><br>            i--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> len - i;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fh == STDOUT || fh == STDERR)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    fr = f_read((FIL *)fh, buf, len, &amp;br);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>        <span class="hljs-keyword">return</span> len - br;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 检查句柄是否为终端</span><br><span class="hljs-type">int</span> _sys_istty(FILEHANDLE fh)<br>&#123;<br>    <span class="hljs-keyword">return</span> IS_STD(fh);<br>&#125;<br><br><span class="hljs-type">int</span> _sys_seek(FILEHANDLE fh, <span class="hljs-type">long</span> pos)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br><br>    <span class="hljs-keyword">if</span> (!IS_STD(fh))<br>    &#123;<br>        fr = f_lseek((FIL *)fh, pos);<br>        <span class="hljs-keyword">if</span> (fr == FR_OK)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 刷星句柄关联的缓冲区</span><br><span class="hljs-type">int</span> _sys_ensure(FILEHANDLE fh)<br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回文件当前长度</span><br><span class="hljs-type">long</span> _sys_flen(FILEHANDLE fh)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    <span class="hljs-keyword">if</span> (!IS_STD(fh))<br>        <span class="hljs-keyword">return</span> f_size((FIL *)fh);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 在usart.c中定义了，注释防止重复定义</span><br><span class="hljs-comment">// void _sys_exit(int status)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">////while(1);</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-type">int</span> _sys_tmpnam(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> fileno, <span class="hljs-type">unsigned</span> maxlength)<br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 将一个字符写入控制台</span><br><span class="hljs-type">void</span> _ttywrch(<span class="hljs-type">int</span> ch)<br>&#123;<br>    USART1_SendChar(ch);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span><br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newname)</span><br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义main函数argv的内容</span><br><span class="hljs-type">char</span> *_sys_command_string(<span class="hljs-type">char</span> *cmd, <span class="hljs-type">int</span> len)<br>&#123;<br>    <span class="hljs-comment">// 可以把命令行内容放入大小为len的cmd缓存区然后返回</span><br>    <span class="hljs-comment">// 也可以直接返回一个字符串</span><br>    <span class="hljs-comment">// return &quot;./foo -f bar&quot;;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 在loslib.c中已有定义，防止重复定义，这里注释掉</span><br><span class="hljs-comment">// time_t time(time_t * time)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//return 0;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-type">clock_t</span> <span class="hljs-title function_">clock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="排查错误"><a href="#排查错误" class="headerlink" title="排查错误"></a>排查错误</h2><p>因为我用的是正点原子的USART的代码，它们家是没有勾<strong>Use MicroLIB</strong> 模式的，一些配置会重复，所以我们要自己改一些东西，不然编译没法通过。</p><ul><li>打开usart.c，更改以下部分内容：</li></ul><blockquote><ol><li>注释<strong>FILE __stdout;</strong></li></ol></blockquote><p>因为移植了Lua解释器，所以我们的<strong>堆栈分配</strong>应该相应的分配更大一些。</p><ul><li>打开启动文件（<strong>startup_stm32f40_41xxx.s</strong>），更改以下部分内容：</li></ul><blockquote><ol><li>修改栈：<strong>Stack_Size      EQU     0x00001000 &#x2F;&#x2F;4k &#x2F;&#x2F;不行就改成0x00004000</strong></li><li>修改堆：<strong>Heap_Size       EQU     0x00002c00 &#x2F;&#x2F;11k &#x2F;&#x2F;不行就改成0x00004000</strong></li></ol></blockquote><ul><li>打开<strong>luaconf.h</strong></li></ul><blockquote><ol><li>添加 <strong>#define LUA_32BITS</strong></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You</span><br><span class="hljs-comment">** can also define LUA_32BITS in the make file, but changing here you</span><br><span class="hljs-comment">** ensure that all software connected to Lua will be compiled with the</span><br><span class="hljs-comment">** same configuration.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/* #define LUA_32BITS */</span><br> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LUA_32BITS</span><br></code></pre></td></tr></table></figure><p>OK！这时候再编译应该不会有报错，是可以通过的！</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将C函数注册成Lua可调用的函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_led_on</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br>LED0 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 将C函数注册成Lua可调用的函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_print_hello</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello this is lua!\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 将C函数注册成Lua可调用的函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">luaL_Reg</span> <span class="hljs-title">mylib</span>[] =</span><br>&#123;<br>&#123;<span class="hljs-string">&quot;led_on&quot;</span>,lua_led_on&#125;,<br>&#123;<span class="hljs-string">&quot;print_hello&quot;</span>,lua_print_hello&#125;,<br>&#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">/* 编写Lua脚本 */</span><br><span class="hljs-comment">/* 这个程序中，我们点亮了led，同时打印了Hello this is lua!\r\n */</span><br><span class="hljs-comment">/* 接着，程序的主导权就会归还给c继续执行c程序 */</span><br><span class="hljs-comment">/* 当然你也可以直接在这里写个 while 循环，这样后面的c程序都不再执行，直至退出循环 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> LUA_SCRIPT_GLOBAL_ON[]=<span class="hljs-string">&quot;\</span><br><span class="hljs-string">led_on()\</span><br><span class="hljs-string">print_hello()\</span><br><span class="hljs-string">&quot;</span>;<br><br><span class="hljs-comment">/* 运行Lua脚本 */</span><br><span class="hljs-comment">/* 将这个函数丢到程序里面去，比方说main函数里头 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_file_script</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>lua_State *L;<br>L = luaL_newstate();<br>luaopen_base(L);<br>luaL_setfuncs(L, mylib, <span class="hljs-number">0</span>); <span class="hljs-comment">// 使我们注册的函数生效</span><br>luaL_dostring(L, LUA_SCRIPT_GLOBAL_ON); <span class="hljs-comment">// 执行我们写的Lua文本脚本程序</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lua还有更多的可玩性，上面的仅仅只是其中一种（<strong>luaL_dostring</strong>）！</p><p>下面再介绍一种（<strong>luaL_dofile</strong>）！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_led_on</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br>LED0 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_print_hello</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello this is lua!\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">luaL_Reg</span> <span class="hljs-title">mylib</span>[] =</span><br>&#123;<br>&#123;<span class="hljs-string">&quot;led_on&quot;</span>,lua_led_on&#125;,<br>&#123;<span class="hljs-string">&quot;print_hello&quot;</span>,lua_print_hello&#125;,<br>&#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_file_script</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> res;<br>lua_State *L;<br>L = luaL_newstate(); <span class="hljs-comment">//创建Lua虚拟机</span><br>luaopen_base(L); <span class="hljs-comment">// 配置基本环境</span><br>luaL_openlibs(L); <span class="hljs-comment">// 注册所使用到的各种Lua库</span><br>luaL_setfuncs(L, mylib, <span class="hljs-number">0</span>); <span class="hljs-comment">// 注册函数</span><br><br>res = luaL_dofile(L, <span class="hljs-string">&quot;1:/test.lua&quot;</span>); <span class="hljs-comment">// 这里我事先把test.lua存储到了外部flash里，所以这里可以写具体位置去读取并运行这个文件</span><br><span class="hljs-keyword">if</span>(res) <span class="hljs-comment">// 返回1，说明读取失败，返回0，为读取成功</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;err\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ok\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Lua调用C函数的注意事项：<br>对于可被Lua调用的C函数而言，其接口必须遵循Lua要求的形式，即<br><strong>typedef int (lua_CFunction)(lua_State* L);</strong><br>接收一个参数Lua_State*，即Lua的状态，返回值表示压入栈中的结果个数。</p></blockquote><p>如果想要注册有传入参数且有返回值的函数，可以参考以下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(lua_State *L)</span><br>&#123;<br><span class="hljs-type">int</span> count;<br><span class="hljs-type">int</span> x,y,res;<br><br>x = lua_tointeger(L,<span class="hljs-number">1</span>);<span class="hljs-comment">//获取Lua传递的参数</span><br>y = lua_tointeger(L,<span class="hljs-number">2</span>);<br><br>res = x + y;<span class="hljs-comment">//计算x+y</span><br><br>lua_pushnumber(L,res);<span class="hljs-comment">//结果压入栈中，供Lua提取</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//返回参数个数！！这是通知LUA调用者有一个值返回</span><br>&#125;<br><br><span class="hljs-comment">//Lua中调用</span><br>local res<br>res = Add(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>print(<span class="hljs-string">&quot;Result = &quot;</span>,res)<br></code></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
