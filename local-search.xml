<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【耐背王】计算机网络🤓📖！</title>
    <link href="/2024/08/20/%E8%80%90%E8%83%8C%E7%8E%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/README/"/>
    <url>/2024/08/20/%E8%80%90%E8%83%8C%E7%8E%8B%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/README/</url>
    
    <content type="html"><![CDATA[<h3 id="【耐背王】计算机网络🤓📖！"><a href="#【耐背王】计算机网络🤓📖！" class="headerlink" title="【耐背王】计算机网络🤓📖！"></a>【耐背王】计算机网络🤓📖！</h3><h4 id="作为一名专业的攻城狮，理论张口就来应该是家常便饭！背书就要笑着背！"><a href="#作为一名专业的攻城狮，理论张口就来应该是家常便饭！背书就要笑着背！" class="headerlink" title="作为一名专业的攻城狮，理论张口就来应该是家常便饭！背书就要笑着背！"></a>作为一名专业的攻城狮，理论张口就来应该是家常便饭！背书就要笑着背！</h4><h4 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h4><hr><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>心血来潮，开了这份新坑，原意是为了复习上学期学习的计算机网络的知识，不要学完考完试就跟过眼云烟一样，以后工作可是实打实会用到的，需要重视起来！</p><hr><h2 id="等待施工…"><a href="#等待施工…" class="headerlink" title="等待施工…"></a>等待施工…</h2><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>等待施工…</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>耐背王</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【简易速记24.08】你说，要多多设想代码之外...</title>
    <link href="/2024/08/12/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/8%E6%9C%88/README/"/>
    <url>/2024/08/12/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/8%E6%9C%88/README/</url>
    
    <content type="html"><![CDATA[<h3 id="【简易速记24-08】你说，要多多设想代码之外…"><a href="#【简易速记24-08】你说，要多多设想代码之外…" class="headerlink" title="【简易速记24.08】你说，要多多设想代码之外…"></a>【简易速记24.08】你说，要多多设想代码之外…</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><h3 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h3><p>和朋友也聊过许多回这件在目前的年龄来看并不重要的事情，多想想代码之外的世界是怎么样的吧？</p><p>比方说，程序员的35岁危机，学历贬值带来的技术贬值，或者很多公众号常提到的穷人活该干一辈子技术之类的话，还有程序员得学会人情世故才可以向上晋升等…</p><p>这目前看起来确实危言耸听，但是也给我自身拉响了长鸣的警钟，人生不能没用技术，也不能只有技术，如何平衡？这似乎非常关键。</p><p>那么，要如何发展代码之外的世界呢。</p><hr><h3 id="【2024-08-12】等待施工…"><a href="#【2024-08-12】等待施工…" class="headerlink" title="【2024&#x2F;08&#x2F;12】等待施工…"></a>【2024&#x2F;08&#x2F;12】等待施工…</h3><p>看看未来的我会给出什么样的答案吧？</p><h3 id="【2024-8-20】我治好了自己的鹅足肌腱炎，一次稀里糊涂的自救"><a href="#【2024-8-20】我治好了自己的鹅足肌腱炎，一次稀里糊涂的自救" class="headerlink" title="【2024&#x2F;8&#x2F;20】我治好了自己的鹅足肌腱炎，一次稀里糊涂的自救"></a>【2024&#x2F;8&#x2F;20】我治好了自己的鹅足肌腱炎，一次稀里糊涂的自救</h3><p>八月初，某天起床发现膝盖内侧开始出现酸痛和撕裂的痛楚。</p><p>起初以为是前两天运动的时候意外挫伤膝盖导致的，没有太多注意这回事，因为不影响正常的走路，也就没有当一回事了。</p><p>起床当天中午，长时间坐在工位上，突然想要起身去倒水，膝盖一用力就出现了一阵突如其来的疼痛，让我在座位上缓了很久才可以颤颤巍巍地扶着撑桌子起身，一瘸一拐地走起路来…</p><blockquote><p>感觉感觉，身体告诉我，自己不再年轻洋溢，不再像小猫般到处蹦蹦跳跳摔跤打滚，这儿那儿磕磕碰碰，也就哭一哭睡一觉醒来第二天身体就恢复如初。心里始终以为自己还是小孩，唯独真正到病痛入侵的时刻！好无奈灰心，膝盖，你什么时候才能重返健康？ ​​​</p></blockquote><blockquote><p>就像是到了每个阴雨天患处要开始隐隐作痛，走路一瘸一拐的时候云淡风轻地解释：“老毛病啦！” 或者，当我找张椅子坐下，要慢慢吞吞地扶着把手晃晃悠悠地支撑着弯腿，待到结实地触底，嘴里还要长舒口气：唉呀… 我曾几何时想过“唉呀”这种语气词会轮到我发出来哈哈哈，像个小老头小老太。<code>from my Weibos --2024-8-8</code></p></blockquote><p>果断地，我开始上网搜索查询相关的病症，百度上说，我这是内侧半月板损伤…半信半疑，我预想我的下半生会不会坐在轮椅上度日hhh，当然事实上并没有这么严重，最后通过症状对比，这似乎更加符合鹅足肌腱炎的表征：膝盖内侧髌骨和股骨的交界处，按压时疼痛，同时弯腿直腿的时候这个位置会有肌肉拉伸的疼痛，同时在走路时，会仿佛感觉膝盖内侧总会有向外翻的趋势。</p><p>下面我来讲讲我是怎么治好鹅足肌腱炎的：</p><p>首先，我立马在某团下单了云南白药喷雾，然后当天中午用上，睡前再喷了药才睡，那时候还是非常的难，我习惯侧睡，睡觉不怎么安分，总会有翻来覆去的时候，于是前几个夜晚总是睡梦中被腿伤疼醒。但不得不说，云南白药确实很厉害，在第二天白天，疼痛的症状就减轻了许多，虽然还是只能慢慢晃悠地走路，但至少可以直行了。</p><p>然后呢，我是大概养伤一个多礼拜才开始象征性地做一些康复运动，对腿部的肌肉做拉伸，疏解。尽量避免上下楼梯这种需要弯腿的动作。还有，最好坐下的时候腿打直不要弯曲，这样在下一次需要站起来的时候，可以避免大量的疼痛，都是经验之谈！</p><p>目前到今天为止，我的膝盖已经恢复得七七八八，但依然在避免高强度的运动，毕竟恢复的周期漫长…</p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>等待施工…</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Life Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简易速记</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F405的DCMI外设的一些小的项目尝试🎶</title>
    <link href="/2024/08/11/STM32F405%E7%9A%84DCMI%E5%A4%96%E8%AE%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%B0%9D%E8%AF%95/README/"/>
    <url>/2024/08/11/STM32F405%E7%9A%84DCMI%E5%A4%96%E8%AE%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%B0%9D%E8%AF%95/README/</url>
    
    <content type="html"><![CDATA[<h3 id="STM32F405的DCMI外设的一些小的项目尝试🎶"><a href="#STM32F405的DCMI外设的一些小的项目尝试🎶" class="headerlink" title="STM32F405的DCMI外设的一些小的项目尝试🎶"></a>STM32F405的DCMI外设的一些小的项目尝试🎶</h3><h3 id="Use-STM32F405-DCMI-peripheral-to-do-some-small-projects"><a href="#Use-STM32F405-DCMI-peripheral-to-do-some-small-projects" class="headerlink" title="Use STM32F405 DCMI peripheral to do some small projects!!!"></a>Use STM32F405 DCMI peripheral to do some small projects!!!</h3><h3 id="Project-name：Color-Tracer"><a href="#Project-name：Color-Tracer" class="headerlink" title="Project name：Color-Tracer"></a>Project name：Color-Tracer</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><p><br></br></p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/images/STM32F405的DCMI外设的一些小的项目尝试/pic2.jpg" alt="exhibition" width="75%;"></div><div class="group-image-wrap"><img src="/images/STM32F405的DCMI外设的一些小的项目尝试/pic3.jpg" alt="exhibition" width="100%;"></div></div></div><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>这些个项目Demos都是基于先前设计的基于STM32F405的HMI开发板LUMOS进行的开发。当时不知道是从哪里听来的STM32F405也可以使用DCMI外设的这个说法，我反复翻阅了意法半导体的芯片手册，上面明确指出STM32F405是没有DCMI这个外设的。</p><p>但是出于好奇，也算是机缘巧合之下，在Bilibil看见有同学拿F405结合摄像头实现了电赛送药小车题目的数字识别，根据那位同学的描述，F405其实是有DCMI外设的，使用标准库可以驱动，但是在HAL库将这个外设阉割掉了hhh，当然现在使用HAL库是趋势，但难免还是为这样的损失而感到可惜。</p><p>于是乎，我就想要亲身复现一下这位同学利用STM32F405和摄像头实现的数字识别功能，所以就有了下面一系列的折腾…</p><p class="note note-info">当然，这些DEMOs都比较远古，包括代码和硬件设计都比较稚嫩，仅仅只做提供思路和参考的作用！仅以此博客，纪念这个有趣的尝试hhh😁</p><h2 id="关于程序"><a href="#关于程序" class="headerlink" title="关于程序"></a>关于程序</h2><h3 id="在LCD屏幕上显示摄像头画面"><a href="#在LCD屏幕上显示摄像头画面" class="headerlink" title="在LCD屏幕上显示摄像头画面"></a>在LCD屏幕上显示摄像头画面</h3><blockquote><ol><li>全屏显示(240x240)</li></ol></blockquote><center><img src="/images/STM32F405的DCMI外设的一些小的项目尝试/pic1.jpg" width="80%;"></center><h3 id="对特定的颜色进行识别与跟踪"><a href="#对特定的颜色进行识别与跟踪" class="headerlink" title="对特定的颜色进行识别与跟踪"></a>对特定的颜色进行识别与跟踪</h3><blockquote><ol start="2"><li>颜色识别(白、红、绿)</li></ol></blockquote><p>默认烧录为识别追踪浅绿色（草绿色），可以前往<code>dcmi.c</code>文件当中修改<code>TARGET_CONDI Conditionred</code>变量为其他色彩阈值。</p><p>演示效果如下：</p><center><img src="/images/STM32F405的DCMI外设的一些小的项目尝试/vedio1_converted.gif" width="90%;"></center><h3 id="识别标准数字-0-9"><a href="#识别标准数字-0-9" class="headerlink" title="识别标准数字(0-9)"></a>识别标准数字(0-9)</h3><blockquote><ol start="3"><li>数字识别(模板匹配)</li></ol></blockquote><center><img src="/images/STM32F405的DCMI外设的一些小的项目尝试/vedio2_converted.gif" width="50%;"></center><h2 id="关于硬件"><a href="#关于硬件" class="headerlink" title="关于硬件"></a>关于硬件</h2><p>硬件是我自己制作的基于STM32F405的HMI开发板LUMOS，但不是最新的版本，<a href="https://oshwhub.com/hugego/lumos-stm32f405-based-hmi-core-board">最新版本戳这里:p</a>.</p><p>您可以到关联仓库当中的<code>2.Hardware</code>当中获取旧版本的PCB打样文件，top为顶板，base为底板，但是本项目不建议复刻。</p><p>外观展示如下：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/images/STM32F405的DCMI外设的一些小的项目尝试/vedio3_converted.gif" width="99.5%;"></div><div class="group-image-wrap"><img src="/images/STM32F405的DCMI外设的一些小的项目尝试/vedio4_converted.gif" width="100%;"></div></div></div><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>关联的仓库<a href="https://github.com/ZhangKeLiang0627/Color-Tracer">请戳这里;P</a>，您可以在该仓库中获取项目源码和PCB打样文件，但，<strong>因为历史过于悠久不推荐复刻本项目。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
      <tag>STM32</tag>
      
      <tag>Camera</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Hexo&#39;s Fluid主题拓展的N种配置👾</title>
    <link href="/2024/07/31/%E5%85%B3%E4%BA%8EFluid%E4%B8%BB%E9%A2%98%E6%8B%93%E5%B1%95%E7%9A%84N%E7%A7%8D%E9%85%8D%E7%BD%AE/README/"/>
    <url>/2024/07/31/%E5%85%B3%E4%BA%8EFluid%E4%B8%BB%E9%A2%98%E6%8B%93%E5%B1%95%E7%9A%84N%E7%A7%8D%E9%85%8D%E7%BD%AE/README/</url>
    
    <content type="html"><![CDATA[<h3 id="关于Hexo’s-Fluid主题拓展的N种配置👾"><a href="#关于Hexo’s-Fluid主题拓展的N种配置👾" class="headerlink" title="关于Hexo’s Fluid主题拓展的N种配置👾"></a>关于Hexo’s Fluid主题拓展的N种配置👾</h3><h3 id="make-your-Hexo’s-theme-more-graceful"><a href="#make-your-Hexo’s-theme-more-graceful" class="headerlink" title="make your Hexo’s theme more graceful!!!"></a>make your Hexo’s theme more graceful!!!</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><h2 id="给Fluid主题添加MAC风格代码块"><a href="#给Fluid主题添加MAC风格代码块" class="headerlink" title="给Fluid主题添加MAC风格代码块"></a>给Fluid主题添加MAC风格代码块</h2><blockquote><p>完整路径: <code>blog_root_path/themes/fluid/source/css</code></p></blockquote><ul><li>首先，到<code>hexo-theme-fluid</code>主题根目录下<code>source/css</code>创建名为<code>macpanel.styl</code>的文件并往该文件当中写入以下内容：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.highlight</span><br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#21252b</span><br>    border-radius: <span class="hljs-number">10px</span><br>    box-shadow: <span class="hljs-number">0</span> <span class="hljs-number">0px</span> <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">4</span>)<br>    padding-top: <span class="hljs-number">30px</span><br><br>    &amp;::before<br>      background: <span class="hljs-number">#fc625d</span><br>      border-radius: <span class="hljs-number">50%</span><br>      box-shadow: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0</span> <span class="hljs-number">#35cd4b</span><br>      content: <span class="hljs-string">&#x27; &#x27;</span><br>      height: <span class="hljs-number">12px</span><br>      left: <span class="hljs-number">12px</span><br>      margin-top: -<span class="hljs-number">20px</span><br>      position: absolute<br>      width: <span class="hljs-number">12px</span><br></code></pre></td></tr></table></figure><ul><li>到管理主题的<code>_config.fluid.yml</code>配置文件当中添加新建的<code>macpanel.styl</code>文件，如下：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">custom_css:</span>    <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/css/macpanel</span><br></code></pre></td></tr></table></figure><ul><li>随后，重新<code>hexo g</code>后就可以看到效果啦。不过可能会出现MAC栏是黑色的，但是代码块背景是白色的情况（因为代码块风格默认为白色。此时如果你不满意，可以继续在<code>_config.fluid.yml</code>配置文件当中修改代码块风格，操作如下：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">highlightjs:</span><br><br>  <span class="hljs-comment"># style: &quot;github gist&quot;</span><br><br>  <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;github dark dimmed&quot;</span><br>  <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;dark&quot;</span><br></code></pre></td></tr></table></figure><p>其实呢，建议不需要修改这个默认的代码块背景颜色的风格，因为你选择使用夜间模式，画面就可以对的上了哈哈哈哈哈！</p><h2 id="给Fluid主题添加首页图片缩放动画"><a href="#给Fluid主题添加首页图片缩放动画" class="headerlink" title="给Fluid主题添加首页图片缩放动画"></a>给Fluid主题添加首页图片缩放动画</h2><p><img src="/images/%E5%85%B3%E4%BA%8EFluid%E4%B8%BB%E9%A2%98%E6%8B%93%E5%B1%95%E7%9A%84N%E7%A7%8D%E9%85%8D%E7%BD%AE/Wos2i6.gif" alt="首页图片缩放动画"></p><blockquote><p>完整路径：<code>blog_root_path/themes/fluid/source/css</code></p></blockquote><ul><li>在<code>blog_root_path/themes/fluid/source/css</code>中新建<code>indeximg-hover.css</code>，并往该文件内写入以下内容：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.index-img</span> &#123;<br>  <span class="hljs-comment">/* 动画时间 */</span><br>  <span class="hljs-attribute">transition</span>: .<span class="hljs-number">4s</span>;           <br>&#125;<br><span class="hljs-selector-class">.index-card</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.index-img</span> &#123;<br>  <span class="hljs-comment">/* 放大倍数 */</span><br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.05</span>);    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在Fluid主题配置文件<code>_config.fluid.yml</code>中添加自定义CSS，操作如下：</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">custom_css:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/css/indeximg-hover.css</span><br></code></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>前端麻瓜也能有出头的一天😁！</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在ESP32-Arduino中使用MQTT</title>
    <link href="/2024/07/20/%E5%9C%A8ESP32-Arduino%E4%B8%AD%E4%BD%BF%E7%94%A8MQTT/README/"/>
    <url>/2024/07/20/%E5%9C%A8ESP32-Arduino%E4%B8%AD%E4%BD%BF%E7%94%A8MQTT/README/</url>
    
    <content type="html"><![CDATA[<h3 id="在ESP32-Arduino中使用MQTT"><a href="#在ESP32-Arduino中使用MQTT" class="headerlink" title="在ESP32-Arduino中使用MQTT"></a>在ESP32-Arduino中使用MQTT</h3><h3 id="The-Usage-of-the-MQTT-protocol-in-ESP32-Arduino"><a href="#The-Usage-of-the-MQTT-protocol-in-ESP32-Arduino" class="headerlink" title="The Usage of the MQTT protocol in ESP32-Arduino"></a>The Usage of the MQTT protocol in ESP32-Arduino</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><h2 id="MQTT协议概述"><a href="#MQTT协议概述" class="headerlink" title="MQTT协议概述"></a>MQTT协议概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p><strong>MQTT的特点：</strong></p></blockquote><ul><li>开放消息协议，简单易实现</li><li>轻量级、占用带宽低（1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量</li><li>发布&#x2F;订阅模式，一对多消息发布，解除应用程序耦合</li><li>基于TCP&#x2F;IP网络连接，提供有序，无损，双向连接</li><li>消息QoS（Quality of Service）支持，可靠传输保证（0-至多发一次、1-最少发一次、2-保证收一次）</li><li>可传输任意类型的数据</li><li>收发消息都是异步的，发送方不需要等待接收方应答</li></ul><p>总的来说，MQTT（Message Queuing Telemetry Transport）是一种<strong>轻量级、基于发布-订阅模式的消息传输协议</strong>，<strong>适用于资源受限的设备和低带宽、高延迟或不稳定的网络环境</strong>。它在物联网应用中广受欢迎，能够实现传感器、执行器和其它设备之间的高效通信。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布&#x2F;订阅模式"></a>发布&#x2F;订阅模式</h4><p>相信这个<code>发布/订阅</code>的概念对于互联网大航海时代的我们来说应该都不陌生了。</p><p>玩过社交平台（如：公众号、微博、Bilibil、抖音等）的同学都知道，你想要接收某位博主的的推送，你首先要关注这位博主才可以，这就是<strong>订阅</strong>。</p><p>如果在某个时间点这个博主更新了新消息，社交平台就会将订阅的消息自动推送到你的设备当中，这就可以类比成<strong>发布</strong>。</p><p>而社交平台在这当中就是充当Broker的作用。</p><p>当然，你们之间的订阅和发布也不是单方面的，你们也可以互相订阅，互相发布！而这就是发布&#x2F;订阅模式。</p><p>当你需要某个话题(Topic)的数据时，你就可以去订阅这个话题获取消息。同时你自身也可以成为话题的发布者，发布消息。</p><h4 id="MQTT客户端-MQTT-Client"><a href="#MQTT客户端-MQTT-Client" class="headerlink" title="MQTT客户端(MQTT Client)"></a>MQTT客户端(MQTT Client)</h4><p>任何运行MQTT客户端库的应用或设备都是MQTT客户端。例如，使用MQTT的即时通讯应用是客户端，使用MQTT上报数据的各种传感器是客户端，各种MQTT测试工具也是客户端。</p><p>我们以社交平台为例，可以把每一位用户都看做是一个客户端(Client)，用户彼此之间可以互相订阅。</p><h4 id="MQTT代理-MQTT-Broker"><a href="#MQTT代理-MQTT-Broker" class="headerlink" title="MQTT代理(MQTT Broker)"></a>MQTT代理(MQTT Broker)</h4><p>MQTT Broker是负责处理客户端请求的关键组件，包括建立连接、断开连接、订阅和取消订阅等操作，同时还负责消息的转发。一个高效强大的MQTT Broker能够轻松应对海量连接和百万级消息吞吐量，从而帮助物联网服务提供商专注于业务发展，快速构建可靠的MQTT应用。</p><p>可以把Broker类比成社交平台，例如：你发布消息到微博上，微博这个社交平台就作为中转站把你的消息转发给已经订阅了你的用户。</p><h3 id="报文内容（请求连接与确认）"><a href="#报文内容（请求连接与确认）" class="headerlink" title="报文内容（请求连接与确认）"></a>报文内容（请求连接与确认）</h3><p>下面，我会简明扼要地解释MQTT连接时的报文的每一个参数的含义与作用：</p><h4 id="CONNECT-连接服务端"><a href="#CONNECT-连接服务端" class="headerlink" title="CONNECT - 连接服务端"></a>CONNECT - 连接服务端</h4><p>下图是CONNECT报文所包含的信息内容：<br><img src="/images/%E5%9C%A8ESP32-Arduino%E4%B8%AD%E4%BD%BF%E7%94%A8MQTT/image.png" alt="CONNECT数据包报文内容"></p><ul><li><strong>clientId（客户端ID）</strong></li></ul><p>ClientId是MQTT客户端的标识。MQTT服务端用该标识来识别客户端。因此ClientId必须是<strong>独立的、独有的</strong>。通常ClientId是<strong>由一串字符所构成的</strong>。</p> <p class="note note-warning">注：如果两个MQTT客户端使用相同ClientId标识，服务端会把它们当成同一个客户端来处理。</p><ul><li><strong>cleanSession（清除会话）</strong></li></ul><p>cleanSession设置为<code>true</code>时，MQTT Broker（服务器端）不会记忆以及缓存任何报文信息，实时转发报文后即刻清除会话。</p><p>cleanSession设置为<code>false</code>时，MQTT Broker（服务器端）会记忆保存那些没有得到客户端接收确认的信息。</p> <p class="note note-warning">注：如果需要服务端保存重要报文，光设置cleanSession为false是不够的，还需要传递的MQTT信息QoS级别大于0！</p><ul><li><strong>keepAlive（心跳时间间隔）</strong></li></ul><p>keepAlive用于服务端实时了解客户端是否与其保持连接的情况。</p><p>例如：keepAlive设置为60，即为客户端与服务器端约定：每60秒客户端必须要向服务器端发送一次心跳(PINGREQ)。</p><p>心跳可以是需要传输的数据，如果60秒内客户端都处于空闲状态没有发送数据，则会自动发送一个心跳数据包，证明自己还在线。</p> <p class="note note-warning">另外，在实际运行中，如果服务端没有在1.5倍心跳时间间隔内收到客户端发布消息(PUBLISH)或发来心跳请求(PINGREQ)，那么服务端就会认为这个客户端已经掉线。</p><ul><li><strong>lastWill（遗嘱）</strong></li></ul> <p class="note note-success">客户端确认意外掉线时，服务器端会根据客户端发送的CONNECT数据包中的遗嘱设置，往遗嘱主题中发送遗嘱消息。</p><blockquote><ul><li><strong>lastWillTopic（遗嘱主题）</strong></li><li><strong>lastWillMessage（遗嘱消息）</strong></li><li><strong>lastWillQos（遗嘱QoS）</strong></li><li><strong>lastWillRetain（遗嘱保留）</strong>：<br>遗嘱消息也可以设置为保留消息。</li></ul></blockquote><ul><li><strong>客户端用户密码认证</strong></li></ul> <p class="note note-success">有些服务端开启了客户端用户密码认证，这种服务端需要客户端在连接时正确提供认证信息才能连接。<br>当然，那些没有开启用户密码认证的服务端无需客户端提供用户名和密码认证信息。</p><blockquote><ul><li><strong>username（用户名）</strong></li><li><strong>password（用户密码）</strong></li></ul></blockquote><h4 id="CONNACK-–-确认连接请求"><a href="#CONNACK-–-确认连接请求" class="headerlink" title="CONNACK – 确认连接请求"></a>CONNACK – 确认连接请求</h4><p>下图是CONNACK报文所包含的信息内容：<br><img src="/images/%E5%9C%A8ESP32-Arduino%E4%B8%AD%E4%BD%BF%E7%94%A8MQTT/image-1.png" alt="CONNACK数据包报文内容"></p><ul><li><strong>sessionPresent（当前会话）</strong></li></ul><p>sessionPresent返回为<code>true</code>时，说明MQTT Broker（服务器端）记忆了未被确认的会话信息。</p><p>sessionPresent返回为<code>false</code>时，MQTT Broker（服务器端）不会记忆以及缓存任何报文信息，实时转发报文后即刻清除会话。</p><ul><li><strong>returnCode（连接返回码）</strong></li></ul><table><thead><tr><th align="center"><strong>返回码</strong></th><th align="left"><strong>返回码描述</strong></th></tr></thead><tbody><tr><td align="center">0</td><td align="left">成功连接</td></tr><tr><td align="center">1</td><td align="left">连接被服务端拒绝，原因是<strong>不支持客户端的MQTT协议版本</strong>。</td></tr><tr><td align="center">2</td><td align="left">连接被服务端拒绝，原因是<strong>不支持客户端标识符的编码</strong>。</td></tr><tr><td align="center">3</td><td align="left">连接被服务端拒绝，原因是<strong>服务端不可用</strong>。</td></tr><tr><td align="center">4</td><td align="left">连接被服务端拒绝，原因是<strong>用户名或密码无效</strong>。</td></tr><tr><td align="center">5</td><td align="left">连接被服务端拒绝，原因是<strong>客户端未被授权连接到此服务端</strong>。</td></tr></tbody></table><h3 id="报文内容（发布、订阅和取消订阅）"><a href="#报文内容（发布、订阅和取消订阅）" class="headerlink" title="报文内容（发布、订阅和取消订阅）"></a>报文内容（发布、订阅和取消订阅）</h3><h4 id="PUBLISH-–-发布消息"><a href="#PUBLISH-–-发布消息" class="headerlink" title="PUBLISH – 发布消息"></a>PUBLISH – 发布消息</h4><p>MQTT客户端发布消息时，会向服务端发送PUBLISH报文。以下是PUBLISH报文的详细信息：<br><img src="/images/%E5%9C%A8ESP32-Arduino%E4%B8%AD%E4%BD%BF%E7%94%A8MQTT/image-3.png" alt="PUBLISH数据包报文内容"></p><blockquote><ul><li><strong>topicName（主题名）</strong>：<br>主题名用于识别此信息应发布到哪一个主题。例如：<code>topic/1</code></li><li><strong>QoS（服务质量等级）</strong>：<br>QoS有三个级别：0、1和2。QoS决定MQTT通讯有什么样的服务保证。</li><li><strong>packetId（报文标识符）</strong>：<br>报文标识符可用于对MQTT报文进行标识。如果QoS等于0，报文标识符为0；只有QoS级别大于0时，报文标识符才是非零数值。</li><li><strong>retainFlag（保留标志）</strong>：<br>为<code>false</code>时客户端订阅了某一主题后，并不会马上接收到该主题的信息。为<code>true</code>时，客户端在订阅了某一主题后，马上接收到一条该主题的保留信息。</li><li><strong>Payload（有效载荷）</strong>：<br>有效載荷是我们希望通过MQTT所发送的实际内容。我们可以使用MQTT协议发送文本，图像等格式的内容。</li><li><strong>dupFlag（重发标志）</strong>：<br>当MQTT报文的接收方没有及时确认收到报文时，发送方会重复发送MQTT报文。在重复发送MQTT报文时，发送方会将此“重发标志”设置为true。请注意，重发标志只在QoS级别大于0时使用。</li></ul></blockquote><h4 id="SUBSCRIBE-–-订阅主题"><a href="#SUBSCRIBE-–-订阅主题" class="headerlink" title="SUBSCRIBE – 订阅主题"></a>SUBSCRIBE – 订阅主题</h4><p>客户端要想订阅主题，首先要向服务端发送主题订阅请求。客户端是通过向服务端发送SUBSCRIBE报文来实现这一请求的。</p><blockquote><ul><li><strong>topicName（主题名）</strong></li><li><strong>QoS（服务质量等级）</strong></li><li><strong>packetId（报文标识符）</strong></li></ul></blockquote><h4 id="SUBACK-–-订阅确认"><a href="#SUBACK-–-订阅确认" class="headerlink" title="SUBACK – 订阅确认"></a>SUBACK – 订阅确认</h4><p>服务端接收到客户端的订阅报文后，会向客户端发送SUBACK报文确认订阅。</p><p>SUBACK报文包含有“订阅返回码”和“报文标识符”这两个信息。</p><ul><li><strong>returnCode（订阅返回码）</strong></li></ul><p>客户端向服务端发送订阅请求后，服务端会给客户端返回一个订阅返回码。</p><p>这个返回码的作用是告知客户端是否成功订阅了主题。以下是返回码的详细说明：</p><table><thead><tr><th align="center"><strong>返回码</strong></th><th align="left"><strong>返回码描述</strong></th></tr></thead><tbody><tr><td align="center">0</td><td align="left">订阅成功 – QoS 0</td></tr><tr><td align="center">1</td><td align="left">订阅成功- QoS 1</td></tr><tr><td align="center">2</td><td align="left">订阅成功- QoS 2</td></tr><tr><td align="center">3</td><td align="left">订阅失败</td></tr></tbody></table><h4 id="UNSUBSCRIBE-–-取消订阅"><a href="#UNSUBSCRIBE-–-取消订阅" class="headerlink" title="UNSUBSCRIBE – 取消订阅"></a>UNSUBSCRIBE – 取消订阅</h4><p>顾名思义，当客户端要取消订阅某主题时，可通过向服务端发送UNSUBSCRIBE – 取消订阅报文来实现。<br><img src="/images/%E5%9C%A8ESP32-Arduino%E4%B8%AD%E4%BD%BF%E7%94%A8MQTT/image-4.png" alt="PUBLISH数据包报文内容"></p><p>报文内容详细的解读和理解可能会导致本篇文章的篇幅过长，这里指路太极创客关于MQTT报文内容的详细介绍：<a href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-tuttorial/mqtt-tutorial/">戳我看:D</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><blockquote><p>PC端：Windows11<br>主控：ESP32S3-R8（常见的模组和开发板都可以）<br>框架：Arduino</p></blockquote><blockquote><p>MQTT库：PubSubClient<br>作者名：Nick O’Leary<br>官网地址：<a href="https://pubsubclient.knolleary.net/">https://pubsubclient.knolleary.net/</a><br>GitHub：<a href="https://github.com/knolleary/pubsubclient/">https://github.com/knolleary/pubsubclient/</a></p></blockquote><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>在PC端安装相关的软件可以更加方便测试单片机的程序运行情况，因此我们需要安装一个MQTT协议软件，方便我们扮演发布端&#x2F;订阅端，来接收或者发布消息。这里推荐下载<code>MQTT.fx</code>！</p><ul><li><p>可以前往 MQTT.fx 的<a href="http://www.mqttfx.org/">官网</a>进行下载。</p></li><li><p>或者前往 太极创客 官网的下载页面进行下载<a href="http://www.taichi-maker.com/homepage/download/#mqtt">戳这里:P</a>（阿里嘎多太极创客！</p></li><li><p><strong>注：</strong>最新版本的<code>MQTT.fx</code>可能需要收费，学生党可以使用<code>MQTT.fx 1.7.1</code>版本，免费但是功能稍有阉割。</p></li><li><p>附：公用MQTT服务器列表（2024&#x2F;7&#x2F;21</p></li></ul><p><img src="/images/%E5%9C%A8ESP32-Arduino%E4%B8%AD%E4%BD%BF%E7%94%A8MQTT/image-2.png" alt="热门的公用MQTT服务器列表"></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="发布话题-传输字符串"><a href="#发布话题-传输字符串" class="headerlink" title="发布话题&amp;传输字符串"></a>发布话题&amp;传输字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Arduino.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WiFi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;PubSubClient.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Ticker.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *id = <span class="hljs-string">&quot;HUGO&quot;</span>;    <span class="hljs-comment">// WIFI名称</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *pswd = <span class="hljs-string">&quot;xxxxxxxx&quot;</span>; <span class="hljs-comment">// WIFI密码</span><br><br><span class="hljs-comment">// broker-cn.emqx.io</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqttServer = <span class="hljs-string">&quot;broker-cn.emqx.io&quot;</span>;<br><br><span class="hljs-comment">// Ticker的计数变量</span><br><span class="hljs-type">int</span> count;<br><br>Ticker ticker;<br>WiFiClient wifiClient;<br><span class="hljs-function">PubSubClient <span class="hljs-title">mqttClient</span><span class="hljs-params">(wifiClient)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectMQTTServer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 根据ESP32的MAC地址生成客户端ID（避免与其它ESP32的客户端ID重名）</span><br>  String clientId = <span class="hljs-string">&quot;esp32s3-&quot;</span> + WiFi.<span class="hljs-built_in">macAddress</span>();<br><br>  <span class="hljs-comment">// 连接MQTT服务器</span><br>  <span class="hljs-keyword">if</span> (mqttClient.<span class="hljs-built_in">connect</span>(clientId.<span class="hljs-built_in">c_str</span>()))<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MQTT Server Connected.&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server Address: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(mqttServer);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ClientId:&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, clientId.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    Serial.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MQTT Server Connect Failed. Client State:&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mqttClient.<span class="hljs-built_in">state</span>());<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">3000</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 发布信息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pubMQTTmsg</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> value; <span class="hljs-comment">// 客户端发布信息用数字</span><br><br>  <span class="hljs-comment">// 建立发布主题。主题名称以Taichi-Maker-为前缀，后面添加设备的MAC地址。</span><br>  <span class="hljs-comment">// 这么做是为确保不同用户进行MQTT信息发布时，ESP8266客户端名称各不相同，</span><br>  String topicString = <span class="hljs-string">&quot;Taichi-Maker-Pub-&quot;</span> + WiFi.<span class="hljs-built_in">macAddress</span>();<br>  <span class="hljs-type">char</span> publishTopic[topicString.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">strcpy</span>(publishTopic, topicString.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-comment">// 建立发布信息。信息内容以Hello World为起始，后面添加发布次数。</span><br>  String messageString = <span class="hljs-string">&quot;Hello World &quot;</span> + <span class="hljs-built_in">String</span>(value++);<br>  <span class="hljs-type">char</span> publishMsg[messageString.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">strcpy</span>(publishMsg, messageString.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-comment">// 实现ESP8266向主题发布信息</span><br>  <span class="hljs-keyword">if</span> (mqttClient.<span class="hljs-built_in">publish</span>(publishTopic, publishMsg))<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Publish Topic: %s\n&quot;</span>, publishTopic);<br>    <span class="hljs-comment">// printf(publishTopic);</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Publish message: %s\n&quot;</span>, publishMsg);<br>    <span class="hljs-comment">// printf(publishMsg);</span><br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message Publish Failed.\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化串口</span><br>  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">115200</span>);<br>  <span class="hljs-comment">// 初始化WIFI</span><br>  WiFi.<span class="hljs-built_in">begin</span>(id, pswd);<br>  <span class="hljs-comment">// 判断wifi是否连接成功</span><br>  <span class="hljs-keyword">while</span> (WiFi.<span class="hljs-built_in">status</span>() != WL_CONNECTED)<br>  &#123;<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正在连接...\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;连接成功！\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;IP address: %s\n&quot;</span>, WiFi.<span class="hljs-built_in">localIP</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 打印本地IP地址</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dns: %s\n&quot;</span>, WiFi.<span class="hljs-built_in">dnsIP</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());          <span class="hljs-comment">// 打印dns地址</span><br><br>  <span class="hljs-comment">// 设置MQTT服务器和端口号</span><br>  mqttClient.<span class="hljs-built_in">setServer</span>(mqttServer, <span class="hljs-number">1883</span>);<br><br>  <span class="hljs-comment">// 连接MQTT服务器</span><br>  <span class="hljs-built_in">connectMQTTServer</span>();<br><br>  <span class="hljs-comment">// Ticker定时对象</span><br>  ticker.<span class="hljs-built_in">attach</span>(<span class="hljs-number">1</span>, []()<br>                &#123; count++; &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 判断开发板是否成功连接服务器</span><br>  <span class="hljs-keyword">if</span> (mqttClient.<span class="hljs-built_in">connected</span>())<br>  &#123;<br>    <span class="hljs-comment">// 每隔三秒发布一次信息</span><br>    <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">3</span>)<br>    &#123;<br>      <span class="hljs-built_in">pubMQTTmsg</span>();<br>      count = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 保持客户端心跳</span><br>    mqttClient.<span class="hljs-built_in">loop</span>();<br>    <span class="hljs-comment">// printf(&quot;Okk\n&quot;);</span><br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">// 重新尝试连接服务器</span><br>    <span class="hljs-built_in">connectMQTTServer</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Err\n&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="订阅单个话题"><a href="#订阅单个话题" class="headerlink" title="订阅单个话题"></a>订阅单个话题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Arduino.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WiFi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;PubSubClient.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *id = <span class="hljs-string">&quot;MagicEyes&quot;</span>;    <span class="hljs-comment">// WIFI名称</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *pswd = <span class="hljs-string">&quot;Zkl2002627&quot;</span>; <span class="hljs-comment">// WIFI密码</span><br><br><span class="hljs-comment">// broker-cn.emqx.io</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *mqttServer = <span class="hljs-string">&quot;broker-cn.emqx.io&quot;</span>;<br><br>WiFiClient wifiClient;<br><span class="hljs-function">PubSubClient <span class="hljs-title">mqttClient</span><span class="hljs-params">(wifiClient)</span></span>;<br><br><span class="hljs-comment">// 订阅指定主题</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">subscribeTopic</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 建立订阅主题。主题名称以Taichi-Maker-Sub为前缀，后面添加设备的MAC地址。</span><br>  <span class="hljs-comment">// 这么做是为确保不同设备使用同一个MQTT服务器测试消息订阅时，所订阅的主题名称不同</span><br>  String topicString = <span class="hljs-string">&quot;Taichi-Maker-Sub-&quot;</span> + WiFi.<span class="hljs-built_in">macAddress</span>();<br>  <span class="hljs-type">char</span> subTopic[topicString.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">strcpy</span>(subTopic, topicString.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-comment">// 通过串口监视器输出是否成功订阅主题以及订阅的主题名称</span><br>  <span class="hljs-keyword">if</span> (mqttClient.<span class="hljs-built_in">subscribe</span>(subTopic))<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Subscrib Topic: %s\n&quot;</span>, subTopic);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Subscribe Fail...\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectMQTTServer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 根据ESP32的MAC地址生成客户端ID（避免与其它ESP32的客户端ID重名）</span><br>  String clientId = <span class="hljs-string">&quot;esp32s3-&quot;</span> + WiFi.<span class="hljs-built_in">macAddress</span>();<br><br>  <span class="hljs-comment">// 连接MQTT服务器</span><br>  <span class="hljs-keyword">if</span> (mqttClient.<span class="hljs-built_in">connect</span>(clientId.<span class="hljs-built_in">c_str</span>()))<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MQTT Server Connected.&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server Address: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(mqttServer);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ClientId:&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, clientId.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">subscribeTopic</span>(); <span class="hljs-comment">// 订阅指定主题</span><br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MQTT Server Connect Failed. Client State:&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mqttClient.<span class="hljs-built_in">state</span>());<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">3000</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 收到信息后的回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">receiveCallback</span><span class="hljs-params">(<span class="hljs-type">char</span> *topic, byte *payload, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message Received [%d]&quot;</span>, topic);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, (<span class="hljs-type">char</span>)payload[i]);<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Message Length(Bytes) %d\n&quot;</span>, length);<br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">char</span>)payload[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>  &#123; <span class="hljs-comment">// 如果收到的信息以“1”为开始</span><br>    <span class="hljs-comment">// digitalWrite(BUILTIN_LED, LOW); // 则点亮LED。</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LED ON\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">// digitalWrite(BUILTIN_LED, HIGH); // 否则熄灭LED。</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;LED OFF\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 初始化串口</span><br>  Serial.<span class="hljs-built_in">begin</span>(<span class="hljs-number">115200</span>);<br>  <span class="hljs-comment">// 初始化WIFI</span><br>  WiFi.<span class="hljs-built_in">begin</span>(id, pswd);<br>  <span class="hljs-comment">// 判断wifi是否连接成功</span><br>  <span class="hljs-keyword">while</span> (WiFi.<span class="hljs-built_in">status</span>() != WL_CONNECTED)<br>  &#123;<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正在连接...\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;连接成功！\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;IP address: %s\n&quot;</span>, WiFi.<span class="hljs-built_in">localIP</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 打印本地IP地址</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dns: %s\n&quot;</span>, WiFi.<span class="hljs-built_in">dnsIP</span>().<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());          <span class="hljs-comment">// 打印dns地址</span><br><br>  <span class="hljs-comment">// 设置MQTT服务器和端口号</span><br>  mqttClient.<span class="hljs-built_in">setServer</span>(mqttServer, <span class="hljs-number">1883</span>);<br>  <span class="hljs-comment">// 设置MQTT订阅回调函数</span><br>  mqttClient.<span class="hljs-built_in">setCallback</span>(receiveCallback);<br>  <span class="hljs-comment">// 连接MQTT服务器</span><br>  <span class="hljs-built_in">connectMQTTServer</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 判断开发板是否成功连接服务器</span><br>  <span class="hljs-keyword">if</span> (mqttClient.<span class="hljs-built_in">connected</span>())<br>  &#123;<br>    <span class="hljs-comment">// 保持客户端心跳</span><br>    mqttClient.<span class="hljs-built_in">loop</span>();<br>    <span class="hljs-comment">// printf(&quot;Okk\n&quot;);</span><br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">// 重新尝试连接服务器</span><br>    <span class="hljs-built_in">connectMQTTServer</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Err\n&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>再次感谢太极创客团队的开源教程！</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>Arduino</tag>
      
      <tag>MQTT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【简易速记24.07】最近在学习网络编程...</title>
    <link href="/2024/07/14/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/README/"/>
    <url>/2024/07/14/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/README/</url>
    
    <content type="html"><![CDATA[<h3 id="【简易速记24-07】最近在学习网络编程…"><a href="#【简易速记24-07】最近在学习网络编程…" class="headerlink" title="【简易速记24.07】最近在学习网络编程…"></a>【简易速记24.07】最近在学习网络编程…</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><h3 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h3><p>一直有一个机器人梦啊，这回不能再gugubird啦。只不过刚好碰上忙时，知识点零散，一点点慢慢积累吧。</p><hr><h3 id="【2024-07-14】找到一个有趣且强大的网络工具Socat"><a href="#【2024-07-14】找到一个有趣且强大的网络工具Socat" class="headerlink" title="【2024&#x2F;07&#x2F;14】找到一个有趣且强大的网络工具Socat"></a>【2024&#x2F;07&#x2F;14】找到一个有趣且强大的网络工具<code>Socat</code></h3><p><strong>Socat</strong>或<strong>SOcket CAT</strong>是一个基于 Linux 命令行&#x2F;终端的实用程序，用于在两个双向字节流之间建立和传输数据。</p><p>在linux环境<code>(Debian/Ubuntu)</code>下安装socat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo apt-get update</span><br><br>sudo apt-get install socat<br></code></pre></td></tr></table></figure><ul><li><strong>1.接着可以尝试一个简单的TCP通信测试</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分别打开两个终端窗口</span><br><br><span class="hljs-comment"># 窗口1输入以下命令，监听端口5555</span><br>socat -d -d TCP-LISTEN:5555 -<br><br><span class="hljs-comment"># 窗口2输入以下命令，连接端口5555</span><br><span class="hljs-comment"># ip地址可以使用ifconfig指令查询</span><br><br><span class="hljs-comment"># 这条指令是全双工的</span><br><span class="hljs-comment"># 连接成功以后，可以在各自的窗口发言，信息会传送到对方的窗口！</span><br>socat -d -d TCP-CONNECT:192.168.26.163:5555 -<br><br><span class="hljs-comment"># 这条指令是单工的</span><br><span class="hljs-comment"># 连接成功以后，监听窗口只能听不能发，只有发送窗口可以发！</span><br>socat - TCP:192.168.26.163:5555<br><br><span class="hljs-comment"># 上述的所有TCP可以更换为UDP，就会得到UDP通信！</span><br></code></pre></td></tr></table></figure><p><img src="/images/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/image.png" alt="socat-TCP"></p><ul><li><strong>2.创建两个虚拟串口并转发数据</strong></li></ul><p>打开一个新终端窗口，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">socat -d -d pty,raw,<span class="hljs-built_in">echo</span>=0 pty,raw,<span class="hljs-built_in">echo</span>=0<br></code></pre></td></tr></table></figure><p>返回结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">2024/07/14 20:39:00 socat[2297] N PTY is /dev/pts/1<br>2024/07/14 20:39:00 socat[2297] N PTY is /dev/pts/2<br>2024/07/14 20:39:00 socat[2297] N starting data transfer loop with FDs [5,5] and [7,7]<br></code></pre></td></tr></table></figure><p>创建了<code>/dev/pts/1</code>和<code>/dev/pts/2</code>两个串口，并且将两个串口连接起来，此时打开两个终端，在终端1输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 去到对应的文件夹</span><br><span class="hljs-built_in">cd</span> /dev/pts/<br><span class="hljs-built_in">cat</span> &lt; 1<br></code></pre></td></tr></table></figure><p>在另一个新终端，终端2中输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 去到对应的文件夹</span><br><span class="hljs-built_in">cd</span> /dev/pts/<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;abc&quot;</span> &gt; 2<br></code></pre></td></tr></table></figure><p>此时在终端1上就会显示<code>abc</code>数据，此时说明<code>/dev/pts/2</code>把数据传输到了<code>/dev/pts/1</code>.</p><p><img src="/images/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/image-1.png" alt="socat-UART"></p><p><strong>上面创建的串口，在不同的机器上名称可能不一致，对于调试、测试来讲很麻烦，下面给出解决方法！</strong></p><ul><li><strong>3.创建“固定名称”的串口</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用link即可把创建的虚拟的串口映射到任何你有权限的位置（这里是home目录）</span><br> socat -d -d pty,raw,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty1 pty,raw,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty2 <br></code></pre></td></tr></table></figure><p>返回内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">2024/07/14 20:57:47 socat[3041] N PTY is /dev/pts/1<br>2024/07/14 20:57:47 socat[3041] N PTY is /dev/pts/2<br>2024/07/14 20:57:47 socat[3041] N starting data transfer loop with FDs [5,5] and [7,7]<br></code></pre></td></tr></table></figure><p>创建串口并设置串口参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">socat -d -d pty,raw,b19200,csize=3,cstopb=1,parenb=1,parodd=1,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty1 pty,raw,b19200,csize=3,cstopb=1,parenb=1,parodd=1,<span class="hljs-built_in">echo</span>=0,<span class="hljs-built_in">link</span>=<span class="hljs-variable">$HOME</span>/socatpty2<br></code></pre></td></tr></table></figure><p>解释如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. b19200 <span class="hljs-comment"># 设置波特率为19200</span><br>2. csize3 <span class="hljs-comment"># 设置character size为8</span><br>3. cstopb=1 <span class="hljs-comment"># 设置两个停止位</span><br>4. parenb=1 <span class="hljs-comment"># 不进行奇偶检测</span><br>5. parodd=1 <span class="hljs-comment"># 奇校验</span><br></code></pre></td></tr></table></figure><p>类似参数还有很多很多，请查阅相关的帮助<a href="http://www.dest-unreach.org/socat/doc/socat.html">文档</a></p><p><img src="/images/2024%E5%B9%B4%E7%AE%80%E6%98%93%E9%80%9F%E8%AE%B0/7%E6%9C%88/image-2.png" alt="socat-UART"></p><hr><h3 id="【2024-07-16】浅薄地了解Cmake"><a href="#【2024-07-16】浅薄地了解Cmake" class="headerlink" title="【2024&#x2F;07&#x2F;16】浅薄地了解Cmake"></a>【2024&#x2F;07&#x2F;16】浅薄地了解<code>Cmake</code></h3><blockquote><p>最近要学习的东西用到很多makefile的知识，但是我横竖怎么写都不得心应手。那不如学学Cmake工具好了（其实是信号与系统学累了在摸鱼…</p></blockquote><p>找到一个关于<code>Cmake</code>的优良教程，阿里嘎多这位作者：<a href="https://subingwen.cn/cmake/CMake-primer/">教程戳我:)</a></p><hr><h3 id="【2024-7-27】tar：常用的文件打包和压缩工具"><a href="#【2024-7-27】tar：常用的文件打包和压缩工具" class="headerlink" title="【2024&#x2F;7&#x2F;27】tar：常用的文件打包和压缩工具"></a>【2024&#x2F;7&#x2F;27】tar：常用的文件打包和压缩工具</h3><blockquote><p>最近遇到镜像压缩、解压缩的小问题，找到这些tar常用的命令，这里统一收集一下。</p></blockquote><p>当然还有其他的工具比如zip、unzip等，这里只讲解tar，其他自行百度吧！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar [选项] [压缩文件名] [文件或目录...]<br></code></pre></td></tr></table></figure><p>常用的选项包括：</p><ul><li><code>-c</code>：创建压缩文件</li><li><code>-x</code>：提取压缩文件</li><li><code>-z</code>：使用<code>gzip</code>算法压缩文件</li><li><code>-j</code>：使用<code>bzip2</code>算法压缩文件</li><li><code>-J</code>：使用<code>xz</code>算法压缩文件</li><li><code>-f</code>：指定归档文件的名称</li><li><code>-v</code>：显示详细的处理信息</li></ul><p><code>-z -j -J</code>这三种参数如何选择？<br>如果对时间比较敏感，可以使用<code>-z</code>参数进行<code>gzip</code>压缩，虽然压缩率比较低，但是速度较快。<br>而如果您对压缩率比较看重，可以选择<code>-j</code>参数进行<code>bzip2</code>压缩，尽管速度较慢，但压缩率比较高。<br>如果您对压缩率要求非常高，可以选择<code>-J</code>参数进行<code>xz</code>压缩，这需要更长的时间。</p><p><br></br></p><p>下面提供几个常见的后缀名和对应的压缩和解压命令，大家不用过于纠结命令组合，以后看见相应的后缀直接用对应的命令就行。</p><ol><li><code>.tar.gz 或 .tgz</code>：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 压缩：tar -czf package.tar.gz file1.txt file.txt directory<br>2 解压缩：tar -xzf package.tar.gz<br></code></pre></td></tr></table></figure><ol start="2"><li><code>.tar.bz2 或 .tbz2</code>：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 压缩：tar -cjf package.tar.bz2 file1.txt file.txt directory<br>2 解压缩：tar -xjf package.tar.bz2<br></code></pre></td></tr></table></figure><ol start="3"><li><code>.tar.xz</code>：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">1 压缩：tar -cJf package.tar.xz file1.txt file.txt directory<br>2 解压缩：tar -xJf package.tar.xz<br></code></pre></td></tr></table></figure><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>鸣谢文章的思路：<a href="https://blog.csdn.net/hitgavin/article/details/116162329">https://blog.csdn.net/hitgavin/article/details/116162329</a></li><li>鸣谢文章答疑解惑，我对此内容做了搬运：<a href="https://lianshaohua.blog.csdn.net/article/details/135709779">https://lianshaohua.blog.csdn.net/article/details/135709779</a></li><li>鸣谢文档：<a href="https://lceda001.feishu.cn/wiki/WXwJw77ZRitCiYkimVGcO5q5nGh">https://lceda001.feishu.cn/wiki/WXwJw77ZRitCiYkimVGcO5q5nGh</a></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Web</tag>
      
      <tag>简易速记</tag>
      
      <tag>Socat</tag>
      
      <tag>Cmake</tag>
      
      <tag>tar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【ROS】ROS的搭建与安装</title>
    <link href="/2024/06/24/%E6%88%91%E7%9A%84ROS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/ROS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%AE%89%E8%A3%85/README/"/>
    <url>/2024/06/24/%E6%88%91%E7%9A%84ROS%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/ROS%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%AE%89%E8%A3%85/README/</url>
    
    <content type="html"><![CDATA[<h3 id="【ROS】ROS的搭建与安装"><a href="#【ROS】ROS的搭建与安装" class="headerlink" title="【ROS】ROS的搭建与安装"></a>【ROS】ROS的搭建与安装</h3><h3 id="【ROS】Setup-and-Installation"><a href="#【ROS】Setup-and-Installation" class="headerlink" title="【ROS】Setup and Installation"></a>【ROS】Setup and Installation</h3><h3 id="Author：-kkl"><a href="#Author：-kkl" class="headerlink" title="Author：@kkl"></a>Author：@kkl</h3><hr><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><blockquote><p>PC端：Win11</p></blockquote><blockquote><p>虚拟机：VirturalBox<br>Ubuntu版本：20.04.6<br>ROS版本：noetic</p></blockquote><h3 id="虚拟机的准备"><a href="#虚拟机的准备" class="headerlink" title="虚拟机的准备"></a>虚拟机的准备</h3><p>virturalBox安装Ubuntu20.04的流程步骤：<a href="https://blog.csdn.net/xiangbing911/article/details/108614181">戳这里:)</a></p><p>virtualBox安装Ubuntu时看不到继续按钮的解决办法：<a href="https://blog.csdn.net/Ratib/article/details/128167397">戳这里:P</a></p><p>virtualBox共享文件夹解决方法：<a href="https://blog.csdn.net/qq_57209192/article/details/124697935">戳这儿:-0</a></p><ul><li>最最关键的就是在于增强功能包的安装，如果没有实现共享文件夹功能，请手动使用该命令重新安装增强功能包：<code>sudo apt-get install virtualbox-guest-dkms</code></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-ROS常规安装方法"><a href="#1-ROS常规安装方法" class="headerlink" title="1. ROS常规安装方法"></a>1. ROS常规安装方法</h3><p>ROS的安装主要是网络问题居多，以下找到一个手把手安装ROS的教程<a href="https://blog.csdn.net/qq_64671439/article/details/135287166">戳这里:)</a></p><p>解决<code>rosdep</code>安装时遇到的各种问题的方法<a href="https://blog.csdn.net/luoluonuoyasuolong/article/details/128999527">戳这里:0</a></p><h3 id="2-ROS安装的超快速方法-鱼香ROS"><a href="#2-ROS安装的超快速方法-鱼香ROS" class="headerlink" title="2. ROS安装的超快速方法 -&gt; 鱼香ROS"></a>2. ROS安装的超快速方法 -&gt; 鱼香ROS</h3><p>这个是最懒人的安装方法了，让我们齐说感谢大佬-&gt;<a href="https://blog.csdn.net/m0_73745340/article/details/135281023">教程戳这里:)</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>感谢以上教程的各位发布者！</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ROS</tag>
      
      <tag>SLAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树莓派】YOLOv5实时识别loopy全流程😒</title>
    <link href="/2024/06/19/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8YOLOv5%E5%AE%9E%E6%97%B6%E8%AF%86%E5%88%ABloopy%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/06/19/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8YOLOv5%E5%AE%9E%E6%97%B6%E8%AF%86%E5%88%ABloopy%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="【树莓派】YOLOv5实时识别loopy全流程😒"><a href="#【树莓派】YOLOv5实时识别loopy全流程😒" class="headerlink" title="【树莓派】YOLOv5实时识别loopy全流程😒"></a>【树莓派】YOLOv5实时识别loopy全流程😒</h3><h3 id="【Raspberry-PI】-YOLOv5-identifies-the-loopy-in-real-time"><a href="#【Raspberry-PI】-YOLOv5-identifies-the-loopy-in-real-time" class="headerlink" title="【Raspberry PI】 YOLOv5 identifies the loopy in real time"></a>【Raspberry PI】 YOLOv5 identifies the loopy in real time</h3><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3><p><img src="/img/post/loopy1.png"><br><img src="/img/post/loopy2.png"></p><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><ul><li>PC：Win11, GTX3060(4GB)</li><li>硬件：Raspberry Pi 4B</li><li>摄像头：中星微摄像头（型号：USB301PL）</li><li>镜像版本：2022-09-22-raspios-bullseye-arm64.img</li><li>树莓派Python版本：<code>3.9.2</code></li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>请提前确认摄像头和OpenCV是否可以正常使用，详情请查看我从前的文章<code>【树莓派】OpenCV的环境安装与基本使用</code>。</p><h2 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h2><ul><li>关联的Github仓库<a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里</a>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">RaspberryPiDeployYOLOv5/<br>├─1.yolov5ForTrain <span class="hljs-comment"># 用于PC端进行模型训练</span><br>└─2.yolov5ForDetect <span class="hljs-comment"># 用于树莓派进行实时推理</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="一、准备运动"><a href="#一、准备运动" class="headerlink" title="一、准备运动"></a>一、准备运动</h2><h2 id="1-对树莓派"><a href="#1-对树莓派" class="headerlink" title="1. 对树莓派"></a>1. 对树莓派</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol><li><p>Pytorch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装torch</span><br>pip install torch==1.8.1<br><span class="hljs-comment"># 安装torchvision</span><br>pip install torchvision==0.9.1<br></code></pre></td></tr></table></figure></li><li><p>YOLOv5</p></li></ol><ul><li><a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里:)</a>下载YOLOv5的依赖，这是已经整理好适配此Python版本树莓派的包。</li><li>将下载完的<code>yolov5-master.zip</code>放到树莓派文件路径<code>home/pi/Download/</code>中，并输入命令<code>unzip yolov5-master.zip</code>将压缩包解压到当前目录。</li><li>解压完成后，<code>cd yolov5-master/</code>进入文件夹。</li><li>使用命令<code>pip install -r requirement.txt</code>安装依赖，时间会比较长，最终看见<code>Successfully</code>类似字样则表示安装成功。</li></ul><h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><ul><li>下载：<a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里:)</a>下载<code>yolov5s.pt</code>，这是YOLOv5的预训练权重文件，后续将使用此模型来进行示例测试。</li><li>文件传输：将此模型复制到之前解压好的<code>yolov5-master</code>文件夹当中。</li><li>运行代码：在<code>yolov5-master</code>文件夹中，运行命令<code>python detect.py</code>，倘若出现<code>Results saved to run/detect/expX</code>，代表代码执行成功，你可以前往此路径查看预测结果图片。</li></ul><h2 id="2-对Windows端PC"><a href="#2-对Windows端PC" class="headerlink" title="2. 对Windows端PC"></a>2. 对Windows端PC</h2><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n yolov5_60 python=3.8<br><br>conda activate yolov5_60<br></code></pre></td></tr></table></figure><h3 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol><li><p>Pytorch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118<br></code></pre></td></tr></table></figure></li><li><p>YOLOv5</p></li></ol><ul><li><a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里:)</a>下载YOLOv5的依赖，这是在PC端训练使用的包，此包中已经含有<code>yolov5s.pt</code>。</li><li>解压完成后，进入文件夹。</li><li>使用命令<code>pip install -r requirement.txt</code>安装依赖，时间会比较长，最终看见<code>Successfully</code>类似字样则表示安装成功。发生报错不要紧，要是模块没有当前的版本，我们就挑一个稍微靠近的版本就行。</li><li>训练模型：<code>train.py</code>中的参数已经手动进行修改，使用命令<code>python train.py</code>，训练完成会在<code>runs/train/expX/weight</code>中生成训练好的模型，我们将<code>test.pt</code>扔到树莓派解压后的文件夹中即可。</li></ul><blockquote><p>常见报错</p><ul><li>报错：RuntimeError: result type Float can’t be cast to the desired output type __int64 -&gt; <a href="https://blog.csdn.net/qq_43573527/article/details/132963466">解决方法</a></li><li>报错：cache文件已存在 -&gt; 解决方法：前往<code>data/loopy/labels</code>删除所有文件后缀<code>.cache</code>的文件即可。</li></ul></blockquote><hr><h2 id="二、推理运动"><a href="#二、推理运动" class="headerlink" title="二、推理运动"></a>二、推理运动</h2><h3 id="1-对树莓派-1"><a href="#1-对树莓派-1" class="headerlink" title="1. 对树莓派"></a>1. 对树莓派</h3><p><code>cd home/pi/Download/yolov5-master/</code>，输入命令<code>python3 detect.py --weight best_loopy.pt --source 0</code>，注意<code>best_loopy.pt</code>即为我们在PC端训练好的模型！<code>--source 0</code>表示使用摄像头实时进行识别。</p><h3 id="2-对PC端"><a href="#2-对PC端" class="headerlink" title="2. 对PC端"></a>2. 对PC端</h3><p><code>python detect.py --weight best_loopy.pt --source 0</code></p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>可可爱爱的loopy来自这里<a href="https://github.com/ZhangKeLiang0627/YOLOv8-loopy">数据集来源</a>。</li><li>关联的Github仓库<a href="https://github.com/ZhangKeLiang0627/YOLOv5-loopy-RaspberryPi">戳这里</a>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RaspberryPi</tag>
      
      <tag>OpenCV</tag>
      
      <tag>YOLOv5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树莓派】OpenCV的环境安装与基本使用</title>
    <link href="/2024/06/17/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84OpenCV%E7%9A%84%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/17/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84OpenCV%E7%9A%84%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="【树莓派】OpenCV的环境安装与基本使用"><a href="#【树莓派】OpenCV的环境安装与基本使用" class="headerlink" title="【树莓派】OpenCV的环境安装与基本使用"></a>【树莓派】OpenCV的环境安装与基本使用</h3><h3 id="【Raspberry-PI】-OpenCV-environment-installation-and-basical-usage"><a href="#【Raspberry-PI】-OpenCV-environment-installation-and-basical-usage" class="headerlink" title="【Raspberry PI】 OpenCV environment installation and basical usage"></a>【Raspberry PI】 OpenCV environment installation and basical usage</h3><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><ul><li>硬件：Raspberry Pi 4B</li><li>摄像头：中星微摄像头（型号：USB301PL）</li><li>镜像版本：2022-09-22-raspios-bullseye-arm64.img</li><li>Python版本：<code>3.9.2</code></li></ul></blockquote><hr><h2 id="摄像头安装"><a href="#摄像头安装" class="headerlink" title="摄像头安装"></a>摄像头安装</h2><p>我这里使用的是某宝随便淘来的<strong>linux免驱动USB摄像头</strong>，下面讲解几个安装摄像头时的注意事项：</p><ul><li>先将摄像头连接上树莓派，再将树莓派上电开机，不然树莓派无法识别设备。</li><li>输入<code>lsusb</code>命令查看当前的USB总线上面有没有挂载Camera字样的设备，如果有就说明摄像头连接成功了。</li><li>如果不是USB摄像头，可以输入<code>ls /dev/video*</code>命令，查看是否有<code>/dev/video0</code>设备。如果设备存在，则说明摄像头挂载成功。</li></ul><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装opencv</span><br>pip install opencv-python<br><br><span class="hljs-comment"># 由于opencv只支持 numpy v1.x 版本</span><br><span class="hljs-comment"># 这里进行numpy版本的统一</span><br>pip install numpy==1.19.3<br></code></pre></td></tr></table></figure><h2 id="环境验证"><a href="#环境验证" class="headerlink" title="环境验证"></a>环境验证</h2><ol><li><p>使用命令行<code>python3</code>，打开Python交互模式。</p></li><li><p>在Python交互模式中输入以下命令，对cv2模块进行验证，如果没有报错并显示出当前的cv2版本则环境已经安装成功。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>cv2.__version__<br></code></pre></td></tr></table></figure></li><li><p>在路径 <code>/home/pi/Downloads</code> 创建一个<code>testCV2.py</code>文件，并填入下方代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 调用摄像头‘0’一般是打开电脑自带摄像头，‘1’是打开外部摄像头（只有一个摄像头的情况）</span><br>width = <span class="hljs-number">1280</span><br>height = <span class="hljs-number">960</span><br>cap.<span class="hljs-built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, width)  <span class="hljs-comment"># 设置图像宽度</span><br>cap.<span class="hljs-built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, height)  <span class="hljs-comment"># 设置图像高度</span><br><span class="hljs-comment"># 显示图像</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <br>    ret, frame = cap.read()  <span class="hljs-comment"># 读取图像(frame就是读取的视频帧，对frame处理就是对整个视频的处理)</span><br>    <span class="hljs-comment"># print(ret)</span><br>    <span class="hljs-comment"># 例如将图像灰度化处理</span><br>    img=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)  <span class="hljs-comment"># 转灰度图</span><br>    <br>    cv2.imshow(<span class="hljs-string">&quot;img&quot;</span>, img)<br>    <span class="hljs-comment"># 图像不处理的情况</span><br>    cv2.imshow(<span class="hljs-string">&quot;frame&quot;</span>, frame)    <br> <br>    input_str = cv2.waitKey(<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">if</span> input_str == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):  <span class="hljs-comment"># 如过输入的是q就break，结束图像显示，鼠标点击视频画面输入字符</span><br>        <span class="hljs-keyword">break</span><br>    <br>cap.release()  <span class="hljs-comment"># 释放摄像头</span><br>cv2.destroyAllWindows()  <span class="hljs-comment"># 销毁窗口</span><br></code></pre></td></tr></table></figure></li><li><p>最后在<strong>VNC远程登录模式</strong>或者在<strong>树莓派图形界面操作系统</strong>下，在命令行中输入指令<code>cd /home/pi/Downloads/</code>，接着执行指令<code>python3 testCV2.py</code>。幸运的话，你会看到摄像头捕捉到的原画面和经过处理的灰度画面两个窗口，按下<code>q</code>键即可退出代码程序。到这里OpenCV的环境安装和基本使用就完成啦！</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RaspberryPi</tag>
      
      <tag>OpenCV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32S3接入百度在线语音合成</title>
    <link href="/2024/03/26/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/"/>
    <url>/2024/03/26/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32S3接入百度在线语音合成"><a href="#ESP32S3接入百度在线语音合成" class="headerlink" title="ESP32S3接入百度在线语音合成"></a>ESP32S3接入百度在线语音合成</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>使用ESP32S3接入百度在线语音合成，其实是为我后面的某个小项目做铺垫啦！这里记录一下实现的过程。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>主控：ESP32S3N16R8</li><li>平台：Arduino + PlatformIO + VScode</li></ul><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><blockquote><p>大部分内容都和语音识别那趴差不多，百度的语音识别和语音合成是共用同一个应用的，如果创建过了就直接使用相同的就行，密钥和token都是共用的，我就直接搬过来了，只有在POST的时候稍微有些区别，我也贴出了具体的代码和示例。</p></blockquote><ol><li>在百度智能云控制端选择<code>语音技术</code>并创建应用获取<code>API Key</code>和<code>Secret Key</code></li><li>根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></li><li>在ESP32S3中发送POST请求API</li></ol><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="1-创建语音合成应用"><a href="#1-创建语音合成应用" class="headerlink" title="1. 创建语音合成应用"></a>1. 创建语音合成应用</h3><p>登录百度智能云的云账号，选择语音识别，创建一个新应用。<strong>（注意：分清楚百度账号还是云账号，这两个不一样的）</strong><br>百度智能云：<a href="https://login.bce.baidu.com/?redirect=https://console.bce.baidu.com/ai/#/ai/speech/app/list">https://login.bce.baidu.com/?redirect=https%3A%2F%2Fconsole.bce.baidu.com%2Fai%2F#/ai/speech/app/list</a></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-1.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-2.png"></p><h3 id="2-根据创建应用生成的API-Key和Secret-Key来获取access-token"><a href="#2-根据创建应用生成的API-Key和Secret-Key来获取access-token" class="headerlink" title="2. 根据创建应用生成的API Key和Secret Key来获取access_token"></a>2. 根据创建应用生成的API Key和Secret Key来获取access_token</h3><p>创建好应用，在应用列表里会出现你刚刚创建的应用，当然<code>API Key</code>和<code>Secret Key</code>也有啦</p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-3.png"></p><p>有了<code>API Key</code>和<code>Secret Key</code>，下面我们可以在ESP32S3上进行GET请求得到access_token的代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 获取token */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gainToken</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>   </span><br><span class="hljs-function"></span>&#123;<br>    HTTPClient http_client; <span class="hljs-comment">// #include &lt;HTTPClient.h&gt;</span><br>    <span class="hljs-comment">//注意，要把下面网址中的your_apikey和your_secretkey替换成自己的API Key和Secret Key</span><br>    http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=your_apikey&amp;client_secret=your_secretkey&quot;</span>);<br>    <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">GET</span>();<br><br>    <span class="hljs-keyword">if</span>(httpResponseCode == HTTP_CODE_OK)<br>    &#123;<br>        String response = http_client.<span class="hljs-built_in">getString</span>();<br>        Serial.<span class="hljs-built_in">println</span>(response);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    http_client.<span class="hljs-built_in">end</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>请求成功会返回如下数据，我们主要关注<code>access_token</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;public wise_adapt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_secret&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dfac94a3489fe9fca7c3221cbf7525ff&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>access_token</code>对应的值就是可用的token，每次申请的<code>token</code>有效期限为30天，过期就需要重新申请。所以咱定时更新<code>access_token</code>就行，不用每次调用语音识别或合成都申请一遍。</li></ul><h3 id="3-发送文本数据，通过POST请求发送到语音合成API上"><a href="#3-发送文本数据，通过POST请求发送到语音合成API上" class="headerlink" title="3. 发送文本数据，通过POST请求发送到语音合成API上"></a>3. 发送文本数据，通过POST请求发送到语音合成API上</h3><p>下面是数据上传的格式说明：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90/image-4.png"></p><p>下面是ESP32S3的具体实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> payload[<span class="hljs-number">8000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">/* 在线语音合成 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speechSynthesis</span><span class="hljs-params">(String inputText)</span></span><br><span class="hljs-function"></span>&#123;<br>  HTTPClient http_client;<br><br>  _LOG(<span class="hljs-string">&quot;[Synthesis] Start Synthesis!\r\n&quot;</span>);<br><br>  <span class="hljs-built_in">memset</span>(payload, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in">strlen</span>(payload)); <span class="hljs-comment">// 将数组清空</span><br><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;tex=&quot;</span>); <span class="hljs-comment">// 合成的文本，UTF-8编码格式</span><br>  <span class="hljs-built_in">strcat</span>(payload, inputText.<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// 合成的文本，UTF-8编码格式</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;lan=zh&quot;</span>); <span class="hljs-comment">// 语言选择，目前只有中英文混合模式，填写固定值zh</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;cuid=hugokkl&quot;</span>); <span class="hljs-comment">// 识别码，随便几个字符，但最好唯一</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;ctp=1&quot;</span>); <span class="hljs-comment">// 客户端类型选择，web端填写固定值1</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;spd=7&quot;</span>); <span class="hljs-comment">// 语速，取值0-15，默认为5中语速</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;pit=5&quot;</span>); <span class="hljs-comment">// 音调，取值0-15，默认为5中语调</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;vol=15&quot;</span>); <span class="hljs-comment">// 音量，基础音库取值0-9，精品音库取值0-15，默认为5中音量</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;per=5118&quot;</span>); <span class="hljs-comment">// 基础音库，度丫丫=4，精品音库，度小鹿=5118</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;aue=5&quot;</span>); <span class="hljs-comment">// 3为mp3格式(默认)；4为pcm-16k；5为pcm-8k；6为wav（内容同pcm-16k）</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&amp;tok=24.fc3481a177dfe90487fa0c3ce0892530.2592000.1713939400.282335-57684431&quot;</span>); <span class="hljs-comment">// access_token</span><br><br>  http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;http://tsn.baidu.com/text2audio&quot;</span>);<br><br>  http_client.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 5s超时时间</span><br>  <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">POST</span>(payload);<br><br>  <span class="hljs-keyword">if</span> (httpResponseCode == HTTP_CODE_OK)<br>  &#123;<br>    WiFiClient response;<br>    <span class="hljs-type">uint32_t</span> streamLength = http_client.<span class="hljs-built_in">getSize</span>();<br>    _LOG(<span class="hljs-string">&quot;streamSize:%d\r\n&quot;</span>, streamLength);<br><br>    response = http_client.<span class="hljs-built_in">getStream</span>();<br><br>    <span class="hljs-keyword">while</span> (!response.<span class="hljs-built_in">available</span>()) <span class="hljs-comment">// 等待数据流可获取</span><br>    &#123;<br>    &#125;<br><br>    streamLength = <span class="hljs-built_in">min</span>(streamLength, _samples * <span class="hljs-number">2</span>);<br><br>    response.<span class="hljs-built_in">readBytes</span>((<span class="hljs-type">char</span> *)_rawData, streamLength);<br><br>    Speaker.<span class="hljs-built_in">playRaw</span>((<span class="hljs-type">int16_t</span> *)_rawData, streamLength / <span class="hljs-number">2</span>, <span class="hljs-number">8000</span>);<br><br>    _LOG(<span class="hljs-string">&quot;[Synthesis] All done!\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    _LOG(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>  &#125;<br>  http_client.<span class="hljs-built_in">end</span>();<br><br>  _LOG(<span class="hljs-string">&quot;[Synthesis] Synthesis complete!\r\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>access_token默认有效期30天，单位是秒，生产环境注意及时刷新。刷新了旧的也能用（只要不超时）</li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>这次没看教程（主要是搞语音合成的教程比较少）。所以！感谢我自己辛勤的劳作😋</p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>语音合成</tag>
      
      <tag>Speaker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32S3接入文心一言</title>
    <link href="/2024/03/25/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/"/>
    <url>/2024/03/25/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32S3接入文心一言"><a href="#ESP32S3接入文心一言" class="headerlink" title="ESP32S3接入文心一言"></a>ESP32S3接入文心一言</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>使用ESP32S3接入文心一言，其实是为我后面的某个小项目做铺垫啦！这里记录一下实现的过程。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>主控：ESP32S3N16R8</li><li>平台：Arduino + PlatformIO + VScode</li></ul><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><ol><li>在百度智能云的云千帆控制台并创建应用获取<code>API Key</code>和<code>Secret Key</code></li><li>根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></li><li>在ESP32S3中发送POST请求API</li></ol><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="1-在百度智能云的云千帆控制台并创建应用获取API-Key和Secret-Key"><a href="#1-在百度智能云的云千帆控制台并创建应用获取API-Key和Secret-Key" class="headerlink" title="1. 在百度智能云的云千帆控制台并创建应用获取API Key和Secret Key"></a>1. 在百度智能云的云千帆控制台并创建应用获取<code>API Key</code>和<code>Secret Key</code></h3><p>首先要使用云账号登录百度智能云，然后进入千帆大模型平台，创建一个新应用。<strong>（注意：分清楚百度账号还是云账号，这两个不一样的）</strong></p><p>百度智能云千帆控制台：<a href="https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application">https://console.bce.baidu.com/qianfan/ais/console/applicationConsole/application</a></p><p>创建新应用：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image.png"></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-1.png"></p><p>创建好应用以后就可以得到<code>API Key</code>和<code>Secret Key</code>！<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-2.png"></p><h3 id="2-根据创建应用生成的API-Key和Secret-Key来获取access-token"><a href="#2-根据创建应用生成的API-Key和Secret-Key来获取access-token" class="headerlink" title="2. 根据创建应用生成的API Key和Secret Key来获取access_token"></a>2. 根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></h3><p>进入API代码调试界面：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-3.png"></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-4.png"></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-5.png"></p><p>应用列表选择自己创建的ESP32S3智能语音助手<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-6.png"></p><p>获取<code>access_token</code><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-7.png"></p><p>指令格式：<code>&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:&quot;介绍一下名侦探柯南这部动画&quot;</code><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-8.png"></p><p>调试结果如下：<br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80/image-9.png"></p><h3 id="3-在ESP32S3中发送POST请求API"><a href="#3-在ESP32S3中发送POST请求API" class="headerlink" title="3. 在ESP32S3中发送POST请求API"></a>3. 在ESP32S3中发送POST请求API</h3><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String apiERNIEbotUrl = <span class="hljs-string">&quot;https://aip.baidubce.com/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions?access_token=xxxxxxxxx&quot;</span>; <span class="hljs-comment">// 把申请的access_token填上去</span><br>String inputText = <span class="hljs-string">&quot;你好！&quot;</span>;<br><br><span class="hljs-comment">/* 文心一言 */</span><br><span class="hljs-function">String <span class="hljs-title">getGPTResponse</span><span class="hljs-params">(String inputText)</span></span><br><span class="hljs-function"></span>&#123;<br>  HTTPClient http_client;<br><br>  http_client.<span class="hljs-built_in">begin</span>(apiERNIEbotUrl);<br>  http_client.<span class="hljs-built_in">addHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br>  http_client.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">20000</span>); <span class="hljs-comment">// 20s的超时时间</span><br><br>  String payload = <span class="hljs-string">&quot;&#123;\&quot;messages\&quot;:[&#123;\&quot;role\&quot;: \&quot;user\&quot;,\&quot;content\&quot;: \&quot;&quot;</span> + inputText + <span class="hljs-string">&quot;\&quot;&#125;],\&quot;disable_search\&quot;: false,\&quot;enable_citation\&quot;: false&#125;&quot;</span>;<br><br>  <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">POST</span>(payload);<br><br>  <span class="hljs-keyword">if</span> (httpResponseCode == HTTP_CODE_OK)<br>  &#123;<br>    String response = http_client.<span class="hljs-built_in">getString</span>();<br><br>    http_client.<span class="hljs-built_in">end</span>();<br>    _LOG(<span class="hljs-string">&quot;\r\n%s\r\n&quot;</span>, response.<span class="hljs-built_in">c_str</span>());<br><br>    <span class="hljs-comment">// Parse JSON response</span><br>    <span class="hljs-function">DynamicJsonDocument <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-number">2048</span>)</span></span>;<br>    <span class="hljs-built_in">deserializeJson</span>(doc, response);<br><br>    String outPutText = doc[<span class="hljs-string">&quot;result&quot;</span>];<br>    <span class="hljs-keyword">return</span> outPutText;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    _LOG(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    http_client.<span class="hljs-built_in">end</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[HTTP] GET... failed, error!&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>意外的顺利耶！Yapi😘</p><ul><li>要注意的是，文心一言的API新用户第一个月可以获得一张20元的优惠券有效期1个月，1个月以后就要付费使用文心一言啦！</li><li>access_token默认有效期30天，单位是秒，生产环境注意及时刷新。刷新了旧的也能用（只要不超时）</li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>项目教程：<a href="https://blog.csdn.net/vor234/article/details/135372118">https://blog.csdn.net/vor234/article/details/135372118</a></p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>文心一言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ESP32S3接入百度在线语音识别</title>
    <link href="/2024/03/24/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    <url>/2024/03/24/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="ESP32S3接入百度在线语音识别"><a href="#ESP32S3接入百度在线语音识别" class="headerlink" title="ESP32S3接入百度在线语音识别"></a>ESP32S3接入百度在线语音识别</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>使用ESP32S3接入百度智能云实现在线语音识别，记录中间遇到的问题和实现流程。</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>主控：ESP32S3N16R8</li><li>平台：Arduino + PlatformIO + VScode</li></ul><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><ol><li>在百度智能云控制端选择<code>语音识别</code>并创建应用获取<code>API Key</code>和<code>Secret Key</code></li><li>根据创建应用生成的<code>API Key</code>和<code>Secret Key</code>来获取<code>access_token</code></li><li>采集音频数据，打包数据，通过http协议将打包的数据（payload）POST请求发送语音识别的API上</li><li>接收返回的数据（response）</li></ol><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h3 id="1-创建语音识别应用"><a href="#1-创建语音识别应用" class="headerlink" title="1. 创建语音识别应用"></a>1. 创建语音识别应用</h3><p>登录百度智能云的云账号，选择语音识别，创建一个新应用。<strong>（注意：分清楚百度账号还是云账号，这两个不一样的）</strong><br>百度智能云：<a href="https://login.bce.baidu.com/?redirect=https://console.bce.baidu.com/ai/#/ai/speech/app/list">https://login.bce.baidu.com/?redirect=https%3A%2F%2Fconsole.bce.baidu.com%2Fai%2F#/ai/speech/app/list</a></p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image-1.png"><br><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image-2.png"></p><h3 id="2-根据创建应用生成的API-Key和Secret-Key来获取access-token"><a href="#2-根据创建应用生成的API-Key和Secret-Key来获取access-token" class="headerlink" title="2. 根据创建应用生成的API Key和Secret Key来获取access_token"></a>2. 根据创建应用生成的API Key和Secret Key来获取access_token</h3><p>创建好应用，在应用列表里会出现你刚刚创建的应用，当然<code>API Key</code>和<code>Secret Key</code>也有啦</p><p><img src="/images/ESP32S3%E6%8E%A5%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%A8%E7%BA%BF%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/image-3.png"></p><p>有了<code>API Key</code>和<code>Secret Key</code>，下面我们可以在ESP32S3上进行GET请求得到access_token的代码！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 获取token */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gainToken</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>   </span><br><span class="hljs-function"></span>&#123;<br>    HTTPClient http_client; <span class="hljs-comment">// #include &lt;HTTPClient.h&gt;</span><br>    <span class="hljs-comment">//注意，要把下面网址中的your_apikey和your_secretkey替换成自己的API Key和Secret Key</span><br>    http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=your_apikey&amp;client_secret=your_secretkey&quot;</span>);<br>    <span class="hljs-type">int</span> httpResponseCode = http_client.<span class="hljs-built_in">GET</span>();<br><br>    <span class="hljs-keyword">if</span>(httpResponseCode == HTTP_CODE_OK)<br>    &#123;<br>        String response = http_client.<span class="hljs-built_in">getString</span>();<br>        Serial.<span class="hljs-built_in">println</span>(response);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Serial.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    http_client.<span class="hljs-built_in">end</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>请求成功会返回如下数据，我们主要关注<code>access_token</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2592000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;public wise_adapt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;session_secret&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dfac94a3489fe9fca7c3221cbf7525ff&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>access_token</code>对应的值就是可用的token，每次申请的<code>token</code>有效期限为30天，过期就需要重新申请。所以咱定时更新<code>access_token</code>就行，不用每次调用语音识别都申请一遍。</li></ul><h3 id="3-采集数据，通过POST请求发送到语音识别API上"><a href="#3-采集数据，通过POST请求发送到语音识别API上" class="headerlink" title="3. 采集数据，通过POST请求发送到语音识别API上"></a>3. 采集数据，通过POST请求发送到语音识别API上</h3><p>数据上传POST的方式有两种：JSON格式和RAW格式。这里我们使用JSON格式，下图为JSON格式上传的一些必要的参数说明：</p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">可需</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">format</td><td align="center">String</td><td align="center">必填</td><td align="left">语音文件的格式，pcm&#x2F;wav&#x2F;amr&#x2F;m4a。不区分大小写。推荐pcm文件！</td></tr><tr><td align="center">rate</td><td align="center">int</td><td align="center">必填</td><td align="left">采样率，16000、8000，固定值</td></tr><tr><td align="center">channel</td><td align="center">int</td><td align="center">必填</td><td align="left">声道数，仅支持单声道，请填固定值1</td></tr><tr><td align="center">cuid</td><td align="center">String</td><td align="center">必填</td><td align="left">用户唯一标识，用来区分用户，计算UV值。建议填写能区分用户的机器MAC地址或IMEI码，长度为60字符以内。</td></tr><tr><td align="center">token</td><td align="center">String</td><td align="center">必填</td><td align="left">开放平台获取到的开发者[access_token]</td></tr><tr><td align="center">dev_pid</td><td align="center">int</td><td align="center">选填</td><td align="left">不填写lan参数生效，都不填写就默认1537（普通话，输入法模型）</td></tr><tr><td align="center">lm_id</td><td align="center">int</td><td align="center">选填</td><td align="left">自训练平台模型id，填dev_id &#x3D; 8001 或 8002 生效</td></tr><tr><td align="center">lan</td><td align="center">String</td><td align="center">选填，废弃参数</td><td align="left">历史兼容参数，已不再使用</td></tr><tr><td align="center">speech</td><td align="center">String</td><td align="center">必填</td><td align="left">本地语音文件的二进制语音数据，需要进行 base64 编码，与len参数一起使用</td></tr><tr><td align="center">len</td><td align="center">int</td><td align="center">必填</td><td align="left">本地语音文件的字节数，单位是字节（byte）</td></tr></tbody></table><p>图中对数据类型和内容说的很明确了，只需要按照这个格式打包好数据然后发送就行，下面是ESP32S3的具体实现代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> payload[<span class="hljs-number">160000</span>];<br><br><span class="hljs-comment">/* 在线语音识别 */</span><br><span class="hljs-function">String <span class="hljs-title">speechRecognition</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  HTTPClient http_client; <span class="hljs-comment">// #include &lt;HTTPClient.h&gt;</span><br><br>  _LOG(<span class="hljs-string">&quot;[Recognition] Start recognition!\r\n&quot;</span>);<br><br>  result = Mic.<span class="hljs-built_in">record</span>(_rawData, _samples); <span class="hljs-comment">// 录制声音</span><br>  _LOG(<span class="hljs-string">&quot;[Mic] record:%s\r\n&quot;</span>, (result == <span class="hljs-literal">true</span> ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>));<br>  <span class="hljs-keyword">while</span> (Mic.<span class="hljs-built_in">isRecording</span>()); <span class="hljs-comment">// 当录制完成时</span><br>  _LOG(<span class="hljs-string">&quot;[Mic] record is done!\r\n&quot;</span>);<br><br>  <span class="hljs-built_in">memset</span>(payload, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in">strlen</span>(payload)); <span class="hljs-comment">// 将数组清空</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&#123;&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;format\&quot;:\&quot;pcm\&quot;,&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;rate\&quot;:16000,&quot;</span>); <span class="hljs-comment">// 采样率，如果采样率改变了，记得修改该值，只有16000、8000两个固定采样率</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;dev_pid\&quot;:1537,&quot;</span>); <span class="hljs-comment">// 中文普通话</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;channel\&quot;:1,&quot;</span>); <span class="hljs-comment">// 单声道</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;cuid\&quot;:\&quot;hugozkl\&quot;,&quot;</span>); <span class="hljs-comment">// 识别码，随便打几个字符，但最好唯一</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;token\&quot;:\&quot;24.ba06cf95edb0b0aee7bfb016209e5948.2592000.1713715897.282335-57684431\&quot;,&quot;</span>); <span class="hljs-comment">// token，这里需要修改成自己申请到的token</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;len\&quot;:65536,&quot;</span>); <span class="hljs-comment">// 数据长度，如果传输的数据长度改变了，记得修改该值，该值是ADC采集的数据字节数，不是base64编码后的长度</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;speech\&quot;:\&quot;&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, base64::<span class="hljs-built_in">encode</span>((<span class="hljs-type">uint8_t</span> *)_rawData, <span class="hljs-number">65536</span>).<span class="hljs-built_in">c_str</span>()); <span class="hljs-comment">// base64编码数据 // #include &quot;base64.h&quot;</span><br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>  <span class="hljs-built_in">strcat</span>(payload, <span class="hljs-string">&quot;&#125;&quot;</span>);<br><br>  <span class="hljs-comment">// HTTP POST</span><br>  <span class="hljs-type">int</span> httpResponseCode;<br>  http_client.<span class="hljs-built_in">begin</span>(<span class="hljs-string">&quot;http://vop.baidu.com/server_api&quot;</span>);<br>  http_client.<span class="hljs-built_in">addHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>  http_client.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 5s超时时间</span><br>  httpResponseCode = http_client.<span class="hljs-built_in">POST</span>(payload);<br><br>  <span class="hljs-keyword">if</span> (httpResponseCode == HTTP_CODE_OK)<br>  &#123;<br>    String response = http_client.<span class="hljs-built_in">getString</span>();<br><br>    http_client.<span class="hljs-built_in">end</span>();<br>    _LOG(<span class="hljs-string">&quot;\r\n%s\r\n&quot;</span>, response.<span class="hljs-built_in">c_str</span>());<br><br>    <span class="hljs-comment">// Parse JSON response</span><br>    <span class="hljs-function">DynamicJsonDocument <span class="hljs-title">doc</span><span class="hljs-params">(<span class="hljs-number">2048</span>)</span></span>; <span class="hljs-comment">// #include &lt;ArduinoJson.h&gt;</span><br>    <span class="hljs-built_in">deserializeJson</span>(doc, response);<br><br>    String outPutText = doc[<span class="hljs-string">&quot;result&quot;</span>];<br>    <span class="hljs-comment">// 去掉首尾的[&quot;&quot;]</span><br>    outPutText = outPutText.<span class="hljs-built_in">substring</span>(<span class="hljs-number">2</span>);<br>    outPutText = outPutText.<span class="hljs-built_in">substring</span>(<span class="hljs-number">0</span>, outPutText.<span class="hljs-built_in">length</span>() - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> outPutText;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    _LOG(<span class="hljs-string">&quot;[HTTP] GET... failed, error: %s\n&quot;</span>, http_client.<span class="hljs-built_in">errorToString</span>(httpResponseCode).<span class="hljs-built_in">c_str</span>());<br>    http_client.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;error&gt;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>POST发送数据有一个固定头部：<code>Content-Type:application/json</code>，POST前需要设置一下，代码中已经有展示。</p><h3 id="4-接收数据"><a href="#4-接收数据" class="headerlink" title="4. 接收数据"></a>4. 接收数据</h3><p>在上一步代码中实现了接收数据，这里列一下返回的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;corpus_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;7349831540333925029&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;success.&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;你好，你是谁？&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sn&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;593363272001711266008&quot;</span><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;corpus_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;7349831596084473860&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;success.&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;现在多少点？&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sn&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;671001951581711266021&quot;</span><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;corpus_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;7349831639168589351&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_msg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;success.&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;err_no&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;深圳天气如何？&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sn&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;13152229661711266031&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>数据发送成功则会返回正确的识别数据，当然声音信号不好时返回的语音识别也会不准确。</li><li>谨记，返回的语音识别结果是<code>UTF-8</code>方式编码，所以代码的编码最好也改为<code>UTF-8</code>编码格式。</li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>百度智能云的语音识别服务是可以免费领取到一定使用次数的，15万次，足够我们测试使用，记得开始测试前先领取一下，不然会出现返回<code>报错：&#123;&#39;err_msg&#39;: &#39;request pv too much&#39;, &#39;err_no&#39;: 3305, &#39;sn&#39;: &#39;876137091191590632079&#39; &#125;</code>，报错原因多半是免费次数没领取或者用完了要开通付费功能。</li></ul><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>项目教程：<a href="https://blog.csdn.net/wojueburenshu/article/details/119244390">https://blog.csdn.net/wojueburenshu/article/details/119244390</a></p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ESP32</tag>
      
      <tag>语音识别</tag>
      
      <tag>Mic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lvgl添加自定义字体和图片</title>
    <link href="/2024/03/21/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/"/>
    <url>/2024/03/21/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Lvgl添加自定义字体和图片"><a href="#Lvgl添加自定义字体和图片" class="headerlink" title="Lvgl添加自定义字体和图片"></a>Lvgl添加自定义字体和图片</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: kkl"></a>Author: kkl</h2><hr><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>仅仅保证对于<code>X-TRACK</code>项目的自定义字体和图片的有效使用哦！</p><hr><h2 id="Font-convert-字体格式转换成-c文件"><a href="#Font-convert-字体格式转换成-c文件" class="headerlink" title="Font convert 字体格式转换成.c文件"></a>Font convert 字体格式转换成.c文件</h2><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>首先我们要去到Lvgl官方网站上的<strong>Online Font Converter</strong><br>网址：<a href="https://lvgl.io/tools/fontconverter">https://lvgl.io/tools/fontconverter</a></p><p>然后我们会看到以下页面！<br><img src="/images/Lvgl%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E5%92%8C%E5%9B%BE%E7%89%87/image.png"></p><blockquote><ol><li>Name</li></ol></blockquote><p>填写.c文件的名字，如<code>font_smliey_36</code>，36表示字号大小，这样就清晰明了！</p><blockquote><ol start="2"><li>Size</li></ol></blockquote><p>填写字号大小，刚刚我们名字写了<code>font_smliey_36</code>，字号是36，那我们这里就填写36px的字号大小。</p><blockquote><ol start="3"><li>Bpp(bit-per-piel)</li></ol></blockquote><p>填写Bpp为4，这个值会让字体看起来更顺滑而且占据的内存空间相对不大（填别的也行，自己尝试对比一下</p><blockquote><ol start="4"><li>Fallback</li></ol></blockquote><p>这里填写和Name一样的<code>font_smliey_36</code>就行啦！</p><blockquote><ol start="5"><li>三个选项框都不要点！反正在X-TRACK没法用！</li></ol></blockquote><blockquote><ol start="6"><li>TTF&#x2F;WOFF file</li></ol></blockquote><p>在这里选择我们准备好的字体文件，推荐用<code>ttf</code>格式。</p><blockquote><ol start="7"><li>Range</li></ol></blockquote><p>这里是设置范围来选择你的.c文件需要包含哪些文字（Symbols），我们不用这个，这里空着，我们直接在下面的Symbols栏里面写我们需要的字。</p><blockquote><ol start="8"><li>Symbols</li></ol></blockquote><p>在这里我们填入希望在Lvgl里使用的文字，比方说我想要在Lvgl里显示<code>鸡你太美</code>，那我就需要在这个栏里填入<code>鸡你太美</code>。</p><blockquote><ol start="9"><li>点击红色的Convert按钮等待.c文件的渲染和下载即可！</li></ol></blockquote><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>首先打开刚刚生成的.c文件，如<code>font_smiley_36.c</code></p><ol><li>找到注释<code>KERNING</code>和注释<code>ALL CUSTOM DATA</code>之间的一大串，注释掉或者删掉！</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 里面注释掉或者删掉！</span><br><span class="hljs-comment">/*-----------------</span><br><span class="hljs-comment"> *    KERNING</span><br><span class="hljs-comment"> *----------------*/</span><br><br><br><span class="hljs-comment">/*Map glyph_ids to kern left classes*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> kern_left_class_mapping[] =<br>&#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<br>    <span class="hljs-number">7</span><br>&#125;;<br><br><span class="hljs-comment">/*Map glyph_ids to kern right classes*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> kern_right_class_mapping[] =<br>&#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>,<br>    <span class="hljs-number">6</span><br>&#125;;<br><br><span class="hljs-comment">/*Kern values between classes*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int8_t</span> kern_class_values[] =<br>&#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-12</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-17</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-6</span>,<br>    <span class="hljs-number">-12</span>, <span class="hljs-number">0</span><br>&#125;;<br><br><br><span class="hljs-comment">/*Collect the kern class&#x27; data in one place*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">lv_font_fmt_txt_kern_classes_t</span> kern_classes =<br>&#123;<br>    .class_pair_values   = kern_class_values,<br>    .left_class_mapping  = kern_left_class_mapping,<br>    .right_class_mapping = kern_right_class_mapping,<br>    .left_class_cnt      = <span class="hljs-number">7</span>,<br>    .right_class_cnt     = <span class="hljs-number">6</span>,<br>&#125;;<br><br><span class="hljs-comment">/*--------------------</span><br><span class="hljs-comment"> *  ALL CUSTOM DATA</span><br><span class="hljs-comment"> *--------------------*/</span><br></code></pre></td></tr></table></figure><ol start="2"><li>将注释<code>ALL CUSTOM DATA</code>和注释<code>PUBLIC FONT</code>之间的一大坨，用以下代码替换掉！</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 用它们替换掉原来的一大坨！</span><br><span class="hljs-comment">/*--------------------</span><br><span class="hljs-comment"> *  ALL CUSTOM DATA</span><br><span class="hljs-comment"> *--------------------*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_VERSION_CHECK(8, 0, 0)</span><br><span class="hljs-comment">/*Store all the custom data of the font*/</span><br><span class="hljs-type">static</span>  <span class="hljs-type">lv_font_fmt_txt_glyph_cache_t</span> cache;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">lv_font_fmt_txt_dsc_t</span> font_dsc = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">lv_font_fmt_txt_dsc_t</span> font_dsc = &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    .glyph_bitmap = glyph_bitmap,<br>    .glyph_dsc = glyph_dsc,<br>    .cmaps = cmaps,<br>    .kern_dsc = <span class="hljs-literal">NULL</span>,<br>    .kern_scale = <span class="hljs-number">0</span>,<br>    .cmap_num = <span class="hljs-number">1</span>,<br>    .bpp = <span class="hljs-number">4</span>,<br>    .kern_classes = <span class="hljs-number">0</span>,<br>    .bitmap_format = <span class="hljs-number">0</span>,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LV_VERSION_CHECK(8, 0, 0)</span><br>    .cache = &amp;cache<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><span class="hljs-comment">/*-----------------</span><br><span class="hljs-comment"> *  PUBLIC FONT</span><br><span class="hljs-comment"> *----------------*/</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>最后，删除注释<code>PUBLIC FONT</code>下的<code>.fallback</code>和<code>.user_data</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 删除以下两条！</span><br><span class="hljs-comment">/*-----------------</span><br><span class="hljs-comment"> *  PUBLIC FONT</span><br><span class="hljs-comment"> *----------------*/</span><br><br>    <span class="hljs-comment">// ...</span><br><br>    .fallback = &amp;font_smiley_36,<br>    .user_data = <span class="hljs-literal">NULL</span>,<br></code></pre></td></tr></table></figure><ol start="4"><li>最后拿去Lvgl跑一下，基本上没有问题啦！</li></ol><h2 id="Pictures-convert-图片格式转换成-c文件"><a href="#Pictures-convert-图片格式转换成-c文件" class="headerlink" title="Pictures convert 图片格式转换成.c文件"></a>Pictures convert 图片格式转换成.c文件</h2><ul><li><strong>未完待续</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lvgl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Power By Hugo@kkl</title>
    <link href="/2024/01/01/WelcomePage/hello-world/"/>
    <url>/2024/01/01/WelcomePage/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h1><h1 id="Welcome-to-MyBlog"><a href="#Welcome-to-MyBlog" class="headerlink" title="Welcome to MyBlog"></a>Welcome to MyBlog</h1><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3><h3 id="Wallpaper’s-Source-kelvinLi-…"><a href="#Wallpaper’s-Source-kelvinLi-…" class="headerlink" title="Wallpaper’s Source: kelvinLi …"></a>Wallpaper’s Source: kelvinLi …</h3><hr><p><br></br></p><body><title>耿鬼</title><style>    body{}*{box-sizing:border-box;}*:before,*:after{content:'';}main{margin:auto;text-align:center;}.gengar{background:#9179c6;margin:3em auto 5em;width:310px;height:350px;border-radius:50% 50% 50% 50%/60% 60% 40% 40%;position:relative;}.gengar .ear{width:150px;height:150px;background:#9179c6;border-radius:10px;position:relative;transform:rotate(-120deg) skewX(-40deg) scale(1,0.866);position:absolute;top:0;}.gengar .ear.right{position:absolute;background:#9179c6;transform:rotate(110deg) skewX(40deg) scale(1,0.866);right:0;}.gengar .hair{width:0;height:0;position:absolute;top:-45px;left:50%;margin-left:-45px;transform:rotate(10deg);border-bottom:100px solid #9179c6;border-left:70px solid transparent;border-right:70px solid transparent;}.gengar .hair.two,.gengar .hair.two:before,.gengar .hair.two:after{transform:rotate(-30deg);margin-left:-60px;top:-35px;border-bottom:80px solid #9179c6;border-left:30px solid transparent;border-right:30px solid transparent;}.gengar .hair.two:before{transform:rotate(60deg) translate(130px,-50px);position:absolute;}.gengar .hair.two:after{transform:rotate(-15deg) translate(-10px,48px);border-bottom:40px solid #9179c6;}.gengar .eye{width:100px;height:50px;background:#f6b392;border-radius:0 0 200px 200px;position:absolute;top:33%;overflow:hidden;transition:0.3s ease;}.gengar .eye:before{width:20px;height:35px;background:black;border-radius:100%;transform:rotate(-35deg);position:absolute;}.gengar .eye:after{width:8px;height:8px;border-radius:50%;background:white;left:43%;top:10px;position:absolute;}.gengar .eye.one{left:50%;transform:rotate(35deg);margin-left:-120px;position:absolute;}.gengar .eye.two{transform:rotate(-35deg) scaleX(-1);right:50%;margin-right:-120px;position:absolute;}.gengar .mouth{position:absolute;left:50%;margin-left:-125px;top:7%;width:250px;height:190px;border-radius:50%;box-shadow:0 75px 0 -10px white;transition:0.3s ease;}.gengar .leg{position:absolute;width:320px;height:130px;border-top-left-radius:200px;border-top-right-radius:200px;border:80px solid #7a63ad;border-bottom:0;top:75%;left:0;right:0;margin:auto;z-index:-1;}.gengar .leg:before,.gengar .leg:after{height:20px;border-radius:10px;width:85px;bottom:-5px;background:#7a63ad;position:absolute;}.gengar .leg:before{left:-84.5px;}.gengar .leg:after{right:-84.5px;}.gengar .hand{position:absolute;width:85px;height:140px;background:#9179c6;border-radius:50% 50% 50% 50%/40% 40% 60% 60%;transform:rotate(59deg);top:31%;left:-40px;}.gengar .hand.two{transform:rotate(-59deg);left:auto;right:-40px;}input[type='checkbox']{height:0;width:0;visibility:hidden;}label{background:#eee;width:160px;height:75px;border-radius:80px;display:inline-block;margin:4em auto;position:relative;cursor:pointer;}label span{position:absolute;top:5px;left:5px;width:65px;height:65px;background:#333;border-radius:50%;transition:0.5s;border:3px solid #222;background:radial-gradient(        #fff,#fff 15%,#333 15%,#333 24%,transparent 24%        ),linear-gradient(        to bottom,#d02222,#d02222 45%,#222 45%,#222 52%,#fff 52%        );}input:checked + label span{left:90px;transform:rotate(360deg);background:#f38dcb;border-radius:200% 320% 150% 150%;border-radius:50%;background-repeat:no-repeat;background-image:radial-gradient(ellipse,black 50%,transparent 50%),radial-gradient(ellipse,black 50%,transparent 50%),linear-gradient(#333,#333);background-size:6px 6px,6px 6px,25px 2px;background-position:28% 50%,80% 50%,55% 64%;}input:checked ~ .gengar .eye{background:black;width:16px;height:16px;border-radius:50%;}input:checked ~ .gengar .eye.one{margin-left:-60px;}input:checked ~ .gengar .eye.two{margin-right:-60px;}input:checked ~ .gengar .eye:before,input:checked ~ .gengar .eye:after{content:none;}input:checked ~ .gengar .mouth{margin-left:-100px;top:35%;width:210px;height:50px;border-radius:50%;box-shadow:0 15px 0 -10px #131313;}</style></body><body><main>    <input type="checkbox" id="ditto-me" />    <label for="ditto-me"><span></span></label>    <div class="gengar">    <div class="ear left"></div>    <div class="ear right"></div>    <div class="hair"></div>    <div class="hair two"></div>    <div class="hand"></div>    <div class="hand two"></div>    <div class="mouth"></div>    <div class="eye one"></div>    <div class="eye two"></div>    <div class="leg"></div>    </div></main></body>]]></content>
    
    
    
    <tags>
      
      <tag>SayHi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【树莓派】远程登录方法</title>
    <link href="/2023/12/28/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E6%B3%95/"/>
    <url>/2023/12/28/MyRaspberryPiLearningGuide/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="My-Raspberry-Pi"><a href="#My-Raspberry-Pi" class="headerlink" title="My Raspberry Pi"></a>My Raspberry Pi</h1><h1 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h1><hr><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><ul><li>硬件：raspberry Pi 4B</li><li>镜像版本：2022-09-22-raspios-bullseye-arm64.img</li></ul></blockquote><hr><h2 id="镜像烧录"><a href="#镜像烧录" class="headerlink" title="镜像烧录"></a>镜像烧录</h2><ul><li>这步就是平常的烧录过程，推荐使用官方的烧录工具，这样前期可以排很多坑（这些坑后面我们会逐一提到）</li></ul><hr><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul><li><strong>初次登录的时，这个地方有个大坑！</strong></li></ul><blockquote><p>最新版的树莓派系统（2022年4月以及以后发布的），<strong>没有了初始化的用户名和密码</strong>，以前用户名是pi，密码是raspberry，但是这次需要进系统之后才能设置。</p></blockquote><blockquote><p>意思就是，你如果初次登录，如果没有用图形化界面，无法创建你的个人用户，你也无法像以前一样直接使用默认账号密码进行登录。</p></blockquote><blockquote><p><strong>解决方法</strong>：</p><ul><li>使用官方的烧录工具，烧录的时候会让你配置初始账号密码。</li><li>外接屏幕、键鼠，使用图形化界面开机配置。</li></ul></blockquote><ul><li>我们重点来了解一下第三种方法，<strong>使用串口无屏幕的登录</strong>。</li></ul><ol><li>往烧录好镜像的SD卡根目录下新建一个文件<code>userconf.txt</code></li><li>文件内写入<code>pi:$6$/4.VdYgDm7RJ0qM1$FwXCeQgDKkqrOU3RIRuDSKpauAbBvP11msq9X58c8Que2l1Dwq3vdJMgiZlQSbEXGaY5esVHGBNbCxKLVNqZW1</code><blockquote><p>这一段意思就是告诉系统，新建一个用户<br>用户名：pi<br>密码：raspberry</p></blockquote></li><li>最后把SD卡插回到树莓派上，重新上电，就可以用这个用户密码登录啦！</li></ol><h3 id="串口登录"><a href="#串口登录" class="headerlink" title="串口登录"></a>串口登录</h3><ul><li><p>串口登录我们需要准备一个USB-TTL Link！</p></li><li><p>排针连接图（<strong>此时TypeC口朝向我们时，即USB-A口朝向右手边时</strong>）：</p><blockquote><p><strong>&#x2F; * * G T R * * * * * * * * * * * * * * &#x2F;</strong><br><strong>&#x2F; * * * * * * * * * * * * * * * * * * * &#x2F;</strong><br><strong>G-&gt;GND &#x2F; T-&gt;TXD &#x2F; R-&gt;RXD</strong></p></blockquote></li><li><p>接着检查烧录好镜像的SD卡根目录下的<code>cmdline.txt</code></p><blockquote><p>如果没有<code>console=serial0,115200</code>就自己在最前面加上去，用一个空格隔开和其他的指令就行</p></blockquote></li><li><p>接着修改烧录好镜像的SD卡根目录下的<code>config.txt</code></p><blockquote><p>在该文件的最后一行加上<code>dtoverlay=pi3-miniuart-bt</code></p></blockquote></li><li><p>这时连接串口就会打印login页面信息啦，记得串口连接选择<strong>波特率为115200，无流控模式</strong>噢！</p></li><li><p>如果没有任何东西显示出来，回去逐一检查，检查硬件是不是插错啦，要<strong>Link的Tx对Pi的Rx，Link的Rx对Pi的Tx</strong>！</p></li></ul><h3 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h3><p>树莓派初次配置SSH登录其实也挺麻烦的，下面演示一下配置步骤。</p><ul><li><p>在烧录好镜像的SD卡根目录下新建文件<code>ssh</code>，空文件就行，命名好以后不用去动它</p></li><li><p>同样的在根目录下再新建一个空文件<code>wpa_supplicant.conf</code></p></li><li><p>使用编译器打开，我这里使用<code>Vscode</code></p></li><li><p>打开以后输入以下配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs conf">country=CN<br>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>update_config=1<br> <br>network=&#123;<br>    ssid=&quot;EMMA&quot;<br>    psk=&quot;12345678&quot;<br>    priority=1<br>&#125;<br> <br>network=&#123;<br>    ssid=&quot;HUGO&quot;<br>    psk=&quot;12345678&quot;<br>    priority=2<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下：<br><code>ssid</code>是将要连接的wifi的名字，不能有中文！<br><code>psk</code>是将要连接的wifi的密码<br><code>priority</code>是连接的优先级，优先级数字大的wifi优先连接<br>你可以按照格式来记录多个wifi，注意优先级不要都相同。</p></blockquote></li><li><p>上述步骤完成以后，把SD卡插回树莓派中运行，<code>ssh</code>和<code>wpa_supplicant.conf</code>文件都会自动被写入系统，写入成功后再次用电脑打开SD卡这两个文件会消失不见。如果你要添加或者修改wifi，你需要把<code>wpa_supplicant.conf</code>文件重新写一遍，重复上述操作，新的文件会自动覆盖旧的；<code>ssh</code>不用重新创建，之前创建过了就可以了。</p></li><li><p>重新给树莓派上电进入系统以后，你可能会发现以下问题警告<code>Wi-Fi is currently blocked by rfkill. Use raspi-config to set the country before use.</code></p></li><li><p>这是我们没有设置无线局域网所在国家，于是我们输入指令<code>sudo raspi-config nonint do_wifi_country CN</code>，顺利的话再输入指令<code>ifconfig</code>会查看到wlan0已经被分配了ip地址！</p></li><li><p>如果平时在同一局域网下我们不知道树莓派ip地址是多少，我们可以在Windows<code>win+R</code>输入cmd打开命令行，输入指令<code>ping raspberrypi -4</code>，可以查询同一局域网当中的树莓派的ip地址。</p></li><li><p>拿到ip地址就可以愉快的远程访问啦！</p></li></ul><h3 id="VNC远程桌面登录"><a href="#VNC远程桌面登录" class="headerlink" title="VNC远程桌面登录"></a>VNC远程桌面登录</h3><ul><li>问题1：VNC Viewer显示<code>Cannot currently show the desktop</code></li></ul><blockquote><p><strong>问题分析</strong>：</p></blockquote><p>出现这个无法显示远程桌面的问题，其实是树莓派配置分辨率的关系，树莓派默认使用了最小分辨率，然后VNC不支持这么小的，咱改一下就行。</p><blockquote><p><strong>解决方法</strong>：</p></blockquote><ul><li><code>sudo raspi-config</code>打开设置界面</li><li>按方向键向下选择到<code>Display Options</code></li><li>接着继续选择<code>VNC Resolution</code></li><li>接着选择除了<code>640x480</code>以外的分辨率</li><li>然后回车确定，方向键左右选择<code>finish</code>退出，然后确认reboot重启，选择<code>yes</code></li><li>最后等待重启就行啦！</li></ul><hr><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>请参照<strong>登录</strong>章节当中的<strong>SSH登录</strong>！</p>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>RaspberryPi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的Linux驱动学习笔记 - IMX6ULL</title>
    <link href="/2023/12/13/MyLinuxLearningGuide/MyLinuxLearningGuide%20-%20IMX6ULL/"/>
    <url>/2023/12/13/MyLinuxLearningGuide/MyLinuxLearningGuide%20-%20IMX6ULL/</url>
    
    <content type="html"><![CDATA[<h3 id="我的Linux驱动学习笔记-IMX6ULL"><a href="#我的Linux驱动学习笔记-IMX6ULL" class="headerlink" title="我的Linux驱动学习笔记 - IMX6ULL"></a>我的Linux驱动学习笔记 - IMX6ULL</h3><h3 id="MyLinuxLearningGuide-IMX6ULL"><a href="#MyLinuxLearningGuide-IMX6ULL" class="headerlink" title="MyLinuxLearningGuide - IMX6ULL"></a>MyLinuxLearningGuide - IMX6ULL</h3><h3 id="By-kkl"><a href="#By-kkl" class="headerlink" title="By @kkl"></a>By @kkl</h3><p class="note note-warning">该笔记目前处于积极开发阶段。</p><hr><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>PC：Win11<br>虚拟机：Ubuntu18.04<br>开发板：正点原子IMX6ULL开发板emmc-512MB</p></blockquote><blockquote><p>镜像：</p><ol><li>出厂镜像：linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7</li><li>教程镜像：linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4</li></ol></blockquote><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>用于不同启动方式的拨码开关设置：</p><ul><li>USB_OTG启动(0 1 0 0 0 0 0 0)<br>该启动方式主要用于mfg固化系统，烧录镜像。</li></ul><p class="note note-warning">注意：从USB_OTG启动时，开发板上如果有SD卡，要先把SD卡拔出来，上电后再重新插上SD卡，否则会影响镜像的烧录。</p><ul><li><p>从TF(SDcard)卡启动(1 0 0 0 0 0 1 0)<br>该启动方式主要用于从TF(SDcard)卡启动内核。</p></li><li><p>从eMMC启动(1 0 1 00 1 1 0)<br>该启动方式主要用于从eMMC启动内核。</p></li></ul><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><p>烧录方法请查看<strong>I.MX6U用户快速体验V2.6 P25</strong></p><ol><li>出厂镜像：linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7</li></ol><ul><li>可以通过<code>【正点原子】阿尔法Linux开发板（A盘）-基础资料\05、开发工具\04、正点原子MFG_TOOL出厂固件烧录工具\mfgtool</code>进行烧录。</li></ul><ol start="2"><li>教程镜像：linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4</li></ol><ul><li><p>可以通过<code>【正点原子】阿尔法Linux开发板（A盘）-基础资料\08、系统镜像\02、教程系统镜像\02、V2.4版本及以后的底板\mfgtool(study)</code>进行烧录。</p></li><li><p>烧录结束以后，重启以后是无法成功加载系统的，需要在Uboot中重新配置一下环境变量，如下：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用Type-C数据线连接开发板的串口和个人PC</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用MobaXterm，Serial连接，波特率设置为115200</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开发板上电，在Uboot准备加载内核前的倒计时结束前，按回车键留在Uboot</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">依次输入以下命令，修改环境变量</span><br><br>setenv bootcmd &#x27;mmc dev 1;fatload mmc 1:1 80800000 zImage;fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb;bootz 80800000 - 83000000&#x27;<br><br>setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;<br><br>saveenv<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置好环境变量后，重新上电启动内核，就可以成功进入系统啦！</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">上述内容来自【正点原子】阿尔法Linux开发板（A盘）-基础资料\08、系统镜像\02、教程系统镜像\02、V2.4版本及以后的底板\mfgtool(study)\【EMMC-bootcmd-bootargs】.txt or 【NAND-bootcmd-bootargs】.txt</span><br></code></pre></td></tr></table></figure><p class="note note-success">当然，你可以使用该工具 <b>mfgtool(study)</b> 烧录你自己制作的镜像。<br></br>只要把 <b>mfgtool(study)\Profiles\Linux\OS Firmware\files\boot</b> 路径下的对应镜像和u-boot修改成你制作的就可以啦，但是名字要和原来的同名噢！！！</p><h3 id="通过命令行更新emmc的内核和设备树固件"><a href="#通过命令行更新emmc的内核和设备树固件" class="headerlink" title="通过命令行更新emmc的内核和设备树固件"></a>通过命令行更新emmc的内核和设备树固件</h3><h4 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h4><p>因为Linux内核和设备树是在uboot运行的时候被从emmc加载到内存当中去的，所以Linux系统正在运行的时候，我们是可以修改emmc中存放的固件的，然后reset等待重启即可。</p><h4 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h4><ol><li>查看emmc分区</li></ol><p>使用命令<code>fdisk -l</code>查看分区信息</p><p>在使用mfg tool烧录之后，emmc会有两个分区，第一个分区是FAT32文件系统<code>/dev/mmcblk1p1</code>，用来存放kernel和设备树，第二个分区是Linux文件系统，用来存放根文件系统</p><ol start="2"><li>更新固件</li></ol><ul><li>使用命令<code>mount /dev/mmcblk1p1 /mnt</code>挂载emmc分区</li><li>接着使用<code>ls /mnt/</code>就可以看到设备树dtb文件和zImage已经出现</li><li>然后使用cp命令将自己最新的文件（可以只替换其中一个或两个）替换掉旧的</li><li>最后通过<code>umount /mnt</code>卸载emmc分区</li></ul><ol start="3"><li>测试</li></ol><ul><li>按下板载的reset按键或者命令行输入<code>reboot</code>进行重启</li><li>重启之后可以通过<code>uname</code>命令或者查找设备树信息的方式检查是否替换成功。</li></ul><hr><h2 id="配网"><a href="#配网" class="headerlink" title="配网"></a>配网</h2><ul><li><p><code>cd /etc/</code>去到此文件夹当中</p></li><li><p>编写<code>wpa_supplicant.conf</code></p><blockquote><p>ctrl_interface&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant<br>update_config&#x3D;1</p><p>network&#x3D;{<br> ssid&#x3D;”MagicEyes”<br> psk&#x3D;”12345678”<br>}</p></blockquote></li><li><p><code>vi wpa_supplicant.conf</code>用vi打开这个文件配置你的网络</p></li><li><p><code>modprobe 8188eu.ko</code>加载 RTL8188EUS 驱动模块（USB-WiFi-RTL8188EUS）</p></li><li><p><code>wpa_supplicant -D wext -c /etc/wpa_supplicant.conf -i wlan0 &amp;</code>使用 wpa_supplicant 工具让 RTL8188 USB WIFI 连接到热点上</p></li><li><p><code>udhcpc -i wlan0</code>从路由器获取IP地址，执行了这一步才可以得到分配的IP地址</p></li><li><p><code>ifconfig wlan0</code>查看IP地址</p></li></ul><p><br></br></p><ul><li><p><code>ping [-I wlan0的IP地址] www.baidu.com</code>可以使用这个指令测试WiFi是否工作正常，[]的内容可以省略，-I 是指定执行 ping 操作的网卡 IP 地址，我们可以指定要使用的 wlan0 去 ping 百度网站。</p></li><li><p>更加详细的内容在<strong>驱动开发指南P1765</strong></p></li></ul><p class="note note-warning">注意！RTL8188EUS 请使用 8188eu.ko 驱动，RTL8188CUS 请使用 8192cu.ko 驱动！</p><p>在出厂镜像中，默认加载的是RTL8188CUS驱动，所以要手动cd到对应的文件夹加载RTL8188EUS驱动模块：</p><ul><li><code>cd /lib/modules/4.1.15-g3dc0a4b/kernel/drivers/net/wireless/rtlwifi/rtl8188EUS</code></li><li><code>insmod 8188eu.ko</code></li></ul><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><ul><li><code>Uboot</code>和内核的编译步骤：</li></ul><blockquote><ol><li><code>distclean</code>清理工程</li><li><code>make xxx_defconfig</code>使用默认配置文件配置工程</li><li><code>make menuconfig</code>打开配置界面，进行配置</li><li><code>make -j12</code>编译所有文件，<code>-j12</code>表示十二核编译</li></ol><ul><li>编译的时间会比较长</li></ul></blockquote><ul><li><strong>Warning:</strong></li></ul><blockquote><p><strong>内核的解压和编译绝对不可以在共享文件夹里进行！</strong><br>否则会出现无法软链接的情况，比如<code>ln: failed to create symbolic link &#39;./dt-bindings&#39;: Operation not permitted</code><br>因为共享文件夹是windows和linux的的共享目录，而windows下的文件系统，不支持linux的<code>symbolic link</code>!</p></blockquote><ul><li>实践</li></ul><blockquote><ol><li>出厂镜像：linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7</li></ol></blockquote><ul><li>这里的编译的内核选用<code>linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7.tar.bz2</code>即正点原子imx6ull的出厂镜像</li><li>解压方法：<code>tar -vxjf xxx.tar.bz2</code></li><li>注意！编译内核时，请先安装Poky交叉编译工具链（具体参照<strong>用户快速体验P115</strong>）</li><li>执行<code>linux-imx-4.1.15-2.1.0-g3dc0a4b-v2.7</code>文件夹内的<code>build.sh</code>一键全编译。</li><li>最后请使用<strong>04、正点原子MFG_TOOL出厂固件烧录工具</strong>进行开发板的烧录哦！</li></ul><blockquote><ol start="2"><li>教程镜像：linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4</li></ol></blockquote><ul><li>这里的编译的内核选用<code>linux-imx-rel_imx_4.1.15_2.1.1_ga_alientek_v2.4.tar.bz2</code>即正点原子imx6ull的教程镜像</li><li>解压方法：<code>tar -vxjf xxx.tar.bz2</code></li></ul><h2 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h2><ul><li>Linux驱动有<strong>两种运行方式</strong>，<strong>第一种</strong>就是将驱动<strong>编译进Linux内核</strong>中，这样当Linux内核启动的时候就会自动运行驱动程序。<strong>第二种</strong>就是<strong>将驱动编译成模块</strong>(Linux下模块扩展名为.ko)，在Linux内核启动以后使用<code>insmod</code>或<code>modprobe</code>命令加载驱动模块，使用<code>rmmod</code>或<code>modprobe -r</code>命令卸载驱动模块。</li></ul><h3 id="驱动模块的加载与卸载"><a href="#驱动模块的加载与卸载" class="headerlink" title="驱动模块的加载与卸载"></a>驱动模块的加载与卸载</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>Linux的驱动程序可以编译到<code>kernel</code>里面（也就是<code>zImage</code>），也可以编译为模块<code>.ko</code>。测试的时候只需要加载<code>.ko</code>模块就可以。</li><li>编写驱动时的注意事项<blockquote><ul><li>编译驱动的时候需要用到Linux内核源码！因此要解压缩Linux内核源码，编译Linux内核源码！编译完成会得到<code>zImage</code>和<code>.dtb</code>设备树。需要使用编译后得到的<code>zImage</code>和<code>.dtb</code>启动系统。</li></ul></blockquote></li></ul><h4 id="驱动模块的Makefile"><a href="#驱动模块的Makefile" class="headerlink" title="驱动模块的Makefile"></a>驱动模块的Makefile</h4><ul><li>Makefile的通用写法<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">KERNELDIR := /home/embedfire/kl_files/linux/IMX6ULL/linux<br>CURRENT_PATH := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br>obj-m := chrdevbase.o<br><br>build : kernel_modules<br><br><span class="hljs-section">kernel_modules:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> modules<br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(CURRENT_PATH)</span> clean<br></code></pre></td></tr></table></figure></li><li>注意要修改<code>c_cpp_properties.json</code>当中的路径哦！（修改了你就可以写代码的时候有补全，不管它对模块的编译和应用没影响）</li></ul><h4 id="驱动模块的编译"><a href="#驱动模块的编译" class="headerlink" title="驱动模块的编译"></a>驱动模块的编译</h4><ul><li><p><code>make</code>在Makefile存放的目录下执行该命令进行编译，编译完成后生成<code>.ko</code>模块</p></li><li><p><code>make clean</code>用于清理编译生成的模块等文件</p></li><li><p>请在使用<code>make</code>命令之前先使用此命令选择交叉工具链<code>source /opt/fsl-imx-x11/4.1.15-2.1.0/environment-setup-cortexa7hf-neon-poky-linux-gnueabi</code></p></li><li><p>编译应用<code>arm-linux-gnueabihf-gcc chrdevbaseApp.c -o chrdevbaseApp</code></p></li></ul><h4 id="模块加载和卸载命令"><a href="#模块加载和卸载命令" class="headerlink" title="模块加载和卸载命令"></a>模块加载和卸载命令</h4><blockquote><p>模块的加载</p></blockquote><ul><li><code>insmod</code>具体用法：<code>insmod xxx.ko</code></li><li><code>modprobe</code>具体用法：<code>modprobe xxx</code>，记得使用之前用<code>depmod</code>刷新当前的模块变量哦！</li><li>加载完成可以使用<code>cat /proc/devices</code>查看模块的设备号哦！</li></ul><blockquote><p>模块的卸载</p></blockquote><ul><li><code>rmmod</code>具体用法：<code>rmmod xxx.ko</code></li><li><code>modprobe -r</code>具体用法：<code>modprobe -r xxx</code></li></ul><h4 id="字符设备驱动-基于设备树的GPIO高低电平驱动模块编写"><a href="#字符设备驱动-基于设备树的GPIO高低电平驱动模块编写" class="headerlink" title="字符设备驱动 - 基于设备树的GPIO高低电平驱动模块编写"></a>字符设备驱动 - 基于设备树的GPIO高低电平驱动模块编写</h4><p>Plus：驱动编写完成进行测试的时候要多次加载卸载来测试驱动的稳健性，如果一两次加载卸载可以成功，试多几次就不行了，可能是我们在驱动编写的时候没有注销、摧毁设备，没有释放内存导致的，这时就需要我们回去修改驱动相关代码啦！</p><h5 id="具体编写流程"><a href="#具体编写流程" class="headerlink" title="具体编写流程"></a>具体编写流程</h5><ul><li><p>编写设备结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module_dev</span>&#123;</span><br><span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">// 设备号</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">// cdev</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">// 类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">// 设备</span><br><span class="hljs-type">int</span> major; <span class="hljs-comment">// 主设备号</span><br><span class="hljs-type">int</span> minor; <span class="hljs-comment">// 次设备号</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">// 设备节点</span><br><span class="hljs-type">int</span> module_gpio; <span class="hljs-comment">// module设备所使用的GPIO编号</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module_dev</span> <span class="hljs-title">module</span>;</span> <span class="hljs-comment">/* module 设备 */</span><br></code></pre></td></tr></table></figure></li><li><p>编写<code>module_open</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">module_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>filp-&gt;private_data = &amp;module; <span class="hljs-comment">/* 设置私有数据 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写<code>module_read</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">module_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写<code>module_write</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">module_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf,</span><br><span class="hljs-params"><span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span><br>&#123;<br><span class="hljs-comment">/* ...... */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写<code>module_release</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写设备操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">module_fops</span> =</span> &#123;<br>.owner = THIS_MODULE,<br>.open = module_open,<br> .read = module_read,<br> .write = module_write,<br> .release = module_release,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>编写驱动入口函数<code>_module_init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODULE_CNT 1 <span class="hljs-comment">// 设备号个数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MODULE_NAME <span class="hljs-string">&quot;module&quot;</span> <span class="hljs-comment">// 名字</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init _module_init(<span class="hljs-type">void</span>)<br>&#123;<br><span class="hljs-comment">/* 设置module设备所使用的GPIO */</span><br><span class="hljs-comment">// 1.获取设备节点（gpio子系统节点）</span><br>module.nd = of_find_node_by_path(<span class="hljs-string">&quot;/module&quot;</span>);<br><span class="hljs-comment">// 判断设备节点是否获取成功</span><br><span class="hljs-keyword">if</span>(module.nd == <span class="hljs-literal">NULL</span>) <br>&#123;<br> printk(<span class="hljs-string">&quot;module node cant not found!\r\n&quot;</span>);<br> <span class="hljs-keyword">return</span> -EINVAL; <span class="hljs-comment">// 获取失败返回失败值</span><br> &#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>printk(<span class="hljs-string">&quot;module node has been found!\r\n&quot;</span>);<br> &#125;<br><br><span class="hljs-comment">// 2.获取设备树中的gpio属性，得到module所使用的gpio编号</span><br>module.module_gpio = of_get_named_gpio(module.nd, <span class="hljs-string">&quot;module-gpio&quot;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(module.module_gpio &lt; <span class="hljs-number">0</span>)<br>&#123;<br> printk(<span class="hljs-string">&quot;can&#x27;t get module-gpio&quot;</span>);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br> printk(<span class="hljs-string">&quot;module-gpio num = %d\r\n&quot;</span>, module.module_gpio);<br><br><span class="hljs-comment">// 3.其他设置，比如设置gpio的电平输出状态等</span><br><br><span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-comment">// 1.创建设备号</span><br><span class="hljs-keyword">if</span> (module.major)<br>&#123; <br><span class="hljs-comment">/* 定义了设备号 */</span><br> module.devid = MKDEV(module.major, <span class="hljs-number">0</span>);<br> register_chrdev_region(module.devid, MODULE_CNT,MODULE_NAME);<br> &#125; <br><span class="hljs-keyword">else</span> <br>&#123; <br><span class="hljs-comment">/* 没有定义设备号 */</span><br> alloc_chrdev_region(&amp;module.devid, <span class="hljs-number">0</span>, MODULE_CNT, MODULE_NAME); <span class="hljs-comment">/* 申请设备号 */</span><br> module.major = MAJOR(module.devid); <span class="hljs-comment">/* 获取分配号的主设备号 */</span><br> module.minor = MINOR(module.devid); <span class="hljs-comment">/* 获取分配号的次设备号 */</span><br> &#125;<br> printk(<span class="hljs-string">&quot;module major=%d,minor=%d\r\n&quot;</span>,module.major,module.minor);<br><br><span class="hljs-comment">// 2.初始化 cdev</span><br>module.cdev.owner = THIS_MODULE;<br>cdev_init(&amp;module.cdev, &amp;module_fops);<br><br><span class="hljs-comment">// 3.添加一个 cdev</span><br>cdev_add(&amp;module.cdev, module.devid, MODULE_CNT);<br><br><span class="hljs-comment">// 4.创建类</span><br>module.class = class_create(THIS_MODULE, MODULE_NAME);<br> <span class="hljs-keyword">if</span> (IS_ERR(module.class))<br>&#123;<br> <span class="hljs-keyword">return</span> PTR_ERR(module.class);<br> &#125;<br><br><span class="hljs-comment">// 5.创建设备</span><br>module.device = device_create(module.class, <span class="hljs-literal">NULL</span>, module.devid, <span class="hljs-literal">NULL</span>, MODULE_NAME);<br> <span class="hljs-keyword">if</span> (IS_ERR(module.device))<br>&#123;<br> <span class="hljs-keyword">return</span> PTR_ERR(module.device);<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写驱动出口函数<code>_module_exit</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit _module_exit(<span class="hljs-type">void</span>)<br>&#123;<br> <span class="hljs-comment">/* 注销字符设备驱动 */</span><br> cdev_del(&amp;module.cdev); <span class="hljs-comment">/* 删除 cdev */</span><br> unregister_chrdev_region(module.devid, MODULE_CNT); <span class="hljs-comment">/* 注销设备号 */</span><br><br> device_destroy(module.class, module.devid); <span class="hljs-comment">/* 注销设备 */</span><br> class_destroy(module.class); <span class="hljs-comment">/* 注销类 */</span><br>&#125;<br><br><span class="hljs-comment">/* 将自己编写的驱动出入口函数注册进API当中 */</span><br>module_init(_module_init); <br>module_exit(_module_exit);<br><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>); <span class="hljs-comment">// 添加版权信息</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;kkl&quot;</span>); <span class="hljs-comment">// 添加作者信息</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="通用的i2c-dev驱动-基于设备树的I2C驱动模块编写"><a href="#通用的i2c-dev驱动-基于设备树的I2C驱动模块编写" class="headerlink" title="通用的i2c_dev驱动 - 基于设备树的I2C驱动模块编写"></a>通用的i2c_dev驱动 - 基于设备树的I2C驱动模块编写</h4><h5 id="具体编写流程（基于ap3216c光传感器"><a href="#具体编写流程（基于ap3216c光传感器" class="headerlink" title="具体编写流程（基于ap3216c光传感器"></a>具体编写流程（基于ap3216c光传感器</h5><ul><li><p>编写设备结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> &#123;</span><br><span class="hljs-type">dev_t</span> devid; <span class="hljs-comment">// 设备号</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> <span class="hljs-title">cdev</span>;</span> <span class="hljs-comment">// cdev</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">class</span> *<span class="hljs-keyword">class</span>;</span> <span class="hljs-comment">// 类</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">device</span>;</span> <span class="hljs-comment">// 设备</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nd</span>;</span> <span class="hljs-comment">// 设备节点</span><br><span class="hljs-type">int</span> major; <span class="hljs-comment">// 主设备号</span><br><span class="hljs-type">void</span> *private_data; <span class="hljs-comment">// 私有数据</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> ir, als, ps;<span class="hljs-comment">// 三个光传感器数据</span><br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> <span class="hljs-title">ap3216cdev</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>编写I2C读多个寄存器函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 从ap3216c读取多个寄存器数据</span><br><span class="hljs-comment"> * @param - dev: ap3216c设备</span><br><span class="hljs-comment"> * @param - reg: 要读取的寄存器首地址</span><br><span class="hljs-comment"> * @param - val: 读取到的数据</span><br><span class="hljs-comment"> * @param - len: 要读取的数据长度</span><br><span class="hljs-comment"> * @return: 操作结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="hljs-type">void</span> *val, <span class="hljs-type">int</span> len)</span><br>&#123;<br><span class="hljs-comment">/* ...... */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写I2C写多个寄存器函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 向ap3216c多个寄存器写入数据</span><br><span class="hljs-comment"> * @param - dev: ap3216c设备</span><br><span class="hljs-comment"> * @param - reg: 要写入的寄存器首地址</span><br><span class="hljs-comment"> * @param - val: 要写入的数据缓冲区</span><br><span class="hljs-comment"> * @param - len: 要写入的数据长度</span><br><span class="hljs-comment"> * @return: 操作结果</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-type">static</span> s32 <span class="hljs-title function_">ap3216c_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span><br>&#123;<br><span class="hljs-comment">/* ...... */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写设备文件打开函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 打开设备</span><br><span class="hljs-comment"> * @param - inode: 传递给驱动的inode</span><br><span class="hljs-comment"> * @param - filp: 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="hljs-comment"> * @return: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br><span class="hljs-comment">/* 一般在open的时候将private_data指向设备结构体 */</span> <br>filp-&gt;private_data = &amp;ap3216cdev;<br><span class="hljs-comment">/* 初始化AP3216C */</span><br>ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="hljs-number">0x04</span>); <span class="hljs-comment">// 复位ap3216c</span><br>mdelay(<span class="hljs-number">50</span>); <span class="hljs-comment">// AP3216C复位最少10ms</span><br>ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="hljs-number">0X03</span>); <span class="hljs-comment">// 开启ALS、PS+IR </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写设备文件读取函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 从设备读取数据 </span><br><span class="hljs-comment"> * @param - filp: 要打开的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @param - buf: 返回给用户空间的数据缓冲区</span><br><span class="hljs-comment"> * @param - cnt: 要读取的数据长度</span><br><span class="hljs-comment"> * @param - offt: 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return: 读取的字节数，如果为负值，表示读取失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">ap3216c_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *off)</span><br>&#123;<br><span class="hljs-type">short</span> data[<span class="hljs-number">3</span>];<br><span class="hljs-type">long</span> err = <span class="hljs-number">0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ap3216c_dev</span> *<span class="hljs-title">dev</span> =</span> (<span class="hljs-keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;<br><br>ap3216c_readdata(dev);<br><br>data[<span class="hljs-number">0</span>] = dev-&gt;ir;<br>data[<span class="hljs-number">1</span>] = dev-&gt;als;<br>data[<span class="hljs-number">2</span>] = dev-&gt;ps;<br>err = copy_to_user(buf, data, <span class="hljs-keyword">sizeof</span>(data));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写设备释放函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 关闭/释放设备</span><br><span class="hljs-comment"> * @param - filp: 要关闭的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @return: 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写设备操作函数集合结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ap3216c_ops</span> =</span> &#123;<br> .owner = THIS_MODULE,<br> .open = ap3216c_open,<br> .read = ap3216c_read,<br> .release = ap3216c_release,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>编写I2C驱动的匹配函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @description: i2c驱动的probe函数，当驱动与设备匹配以后此函数就会执行      </span><br><span class="hljs-comment">* @param - client: i2c设备</span><br><span class="hljs-comment">* @param - id: i2c设备ID</span><br><span class="hljs-comment">* @return: 0-&gt;成功; 其他负值-&gt;失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span><br>&#123;<br><span class="hljs-comment">// 1.构建设备号</span><br><span class="hljs-keyword">if</span> (ap3216cdev.major)<br>&#123;<br>ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="hljs-number">0</span>);<br>register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="hljs-number">0</span>, AP3216C_CNT, AP3216C_NAME);<br>ap3216cdev.major = MAJOR(ap3216cdev.devid);<br>&#125;<br><br><span class="hljs-comment">// 2.注册设备</span><br>cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);<br>cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);<br><br><span class="hljs-comment">// 3.创建类</span><br>ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);<br><span class="hljs-keyword">if</span> (IS_ERR(ap3216cdev.class))<br>&#123;<br><span class="hljs-keyword">return</span> PTR_ERR(ap3216cdev.class);<br>&#125;<br><br><span class="hljs-comment">// 4.创建设备</span><br>ap3216cdev.device = device_create(ap3216cdev.class, <span class="hljs-literal">NULL</span>, ap3216cdev.devid, <span class="hljs-literal">NULL</span>, AP3216C_NAME);<br><span class="hljs-keyword">if</span> (IS_ERR(ap3216cdev.device))<br>&#123;<br><span class="hljs-keyword">return</span> PTR_ERR(ap3216cdev.device);<br>&#125;<br><br>ap3216cdev.private_data = client;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写I2C驱动的移除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: i2c驱动的remove函数，移除i2c驱动的时候此函数会执行</span><br><span class="hljs-comment"> * @param - client: i2c设备</span><br><span class="hljs-comment"> * @return: 0-&gt;成功; 其他负值-&gt;失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ap3216c_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span><br>&#123;<br><span class="hljs-comment">/* 删除设备 */</span><br>cdev_del(&amp;ap3216cdev.cdev);<br>unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);<br><br><span class="hljs-comment">/* 注销掉类和设备 */</span><br>device_destroy(ap3216cdev.class, ap3216cdev.devid);<br>class_destroy(ap3216cdev.class);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建匹配列表和I2C驱动结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 传统匹配方式ID列表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_device_id</span> <span class="hljs-title">ap3216c_id</span>[] =</span> &#123;<br>&#123;<span class="hljs-string">&quot;alientek,ap3216c&quot;</span>, <span class="hljs-number">0</span>&#125;,  <br>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">/* 设备树匹配列表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span> <span class="hljs-title">ap3216c_of_match</span>[] =</span> &#123;<br>&#123; .compatible = <span class="hljs-string">&quot;alientek,ap3216c&quot;</span> &#125;,<br>&#123; <span class="hljs-comment">/* Sentinel */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">/* i2c驱动结构体 */</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">i2c_driver</span> <span class="hljs-title">ap3216c_driver</span> =</span> &#123;<br>.probe = ap3216c_probe,<br>.remove = ap3216c_remove,<br>.driver = &#123;<br>.owner = THIS_MODULE,<br>   .name = <span class="hljs-string">&quot;ap3216c&quot;</span>,<br>   .of_match_table = ap3216c_of_match, <br>   &#125;,<br>.id_table = ap3216c_id,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>编写驱动出入口函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 驱动入口函数</span><br><span class="hljs-comment"> * @param: 无</span><br><span class="hljs-comment"> * @return: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">ap3216c_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>ret = i2c_add_driver(&amp;ap3216c_driver);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 驱动出口函数</span><br><span class="hljs-comment"> * @param: 无</span><br><span class="hljs-comment"> * @return: 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">ap3216c_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>i2c_del_driver(&amp;ap3216c_driver);<br>&#125;<br><br><span class="hljs-comment">/* module_i2c_driver(ap3216c_driver) */</span><br><br>module_init(ap3216c_init);<br>module_exit(ap3216c_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;kkl&quot;</span>);<br><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><ul><li>VScode设备树高亮插件：devicetree</li></ul><h3 id="pinctrl子系统"><a href="#pinctrl子系统" class="headerlink" title="pinctrl子系统"></a>pinctrl子系统</h3><ol><li><p>在<code>iomuxc</code>中创建pinctrl节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs devicetree">pinctrl_test: testgrp &#123;<br><br>/* 具体的PIN信息 */<br><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>添加”fsl,pins”属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs devicetree">pinctrl_test: testgrp &#123;<br>fsl,pins = &lt;<br>/* 设备所使用的 PIN 配置信息 */<br>MX6UL_PAD_GPIO1_IO00__GPIO1_IO00 config /* config 是具体设置值 */<br>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h3 id="gpio子系统"><a href="#gpio子系统" class="headerlink" title="gpio子系统"></a>gpio子系统</h3><ol><li>在根节点<code>/</code>下创建gpio设备子节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs devicetree">test &#123;<br>/* 节点内容 */<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>添加pinctrl信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs devicetree">test &#123;<br>pinctrl-names = &quot;default&quot;; /* 添加pinctrl-name属性，描述pinctrl名字为&quot;default&quot; */<br>pinctrl-0 = &lt;&amp;pinctrl_test&gt;; /* 添加pinctrl-0节点，表示test设备所使用的Pin信息保存在pinctrl_test节点当中 */<br>/* 其他节点内容 */<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>添加gpio属性信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs devicetree">test &#123;<br>pinctrl-names = &quot;default&quot;; /* 添加pinctrl-name属性，描述pinctrl名字为&quot;default&quot; */<br>pinctrl-0 = &lt;&amp;pinctrl_test&gt;; /* 添加pinctrl-0节点，表示test设备所使用的Pin信息保存在pinctrl_test节点当中 */<br>gpio = &lt;&amp;gpio1 0 GPIO_ACTIVE_LOW&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="长定时（P1260）"><a href="#长定时（P1260）" class="headerlink" title="长定时（P1260）"></a>长定时（P1260）</h4><h4 id="短延时Delay（P1260）"><a href="#短延时Delay（P1260）" class="headerlink" title="短延时Delay（P1260）"></a>短延时Delay（P1260）</h4><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="打开有管理员权限的文件管理器"><a href="#打开有管理员权限的文件管理器" class="headerlink" title="打开有管理员权限的文件管理器"></a>打开有管理员权限的文件管理器</h3><ul><li><code>sudo nautilus</code></li></ul><h3 id="删除非空文件夹"><a href="#删除非空文件夹" class="headerlink" title="删除非空文件夹"></a>删除非空文件夹</h3><ul><li><code>rm -r xxx</code>-r的意思就是递归操作，将会删除该文件夹下的所有子文件夹和文件！</li></ul><h3 id="查看dmesg日志信息"><a href="#查看dmesg日志信息" class="headerlink" title="查看dmesg日志信息"></a>查看dmesg日志信息</h3><ul><li><code>dmesg</code>把从启动开始到当前是所有日志都打印出来</li><li><code>dmesg | tail</code>默认打印最近的十条日志</li><li><code>dmesg | tail -20</code>打印最近的二十条日志</li></ul><h3 id="挂载SD卡"><a href="#挂载SD卡" class="headerlink" title="挂载SD卡"></a>挂载SD卡</h3><ol><li>通过<code>fdisk -l</code>确定sd卡的存在</li><li>创建一个空文件夹，我选择<code>/mnt/mmc</code></li><li>挂载sd卡到新创建的空文件夹<code>mount /dev/mmcblk0p1 /mnt/mmc</code></li></ol><ul><li>卸载可以使用<code>umount /mnt/mmc</code>，注意卸载的时候你所在的当前目录不能是&#x2F;mnt，否则会卸载失败的。</li></ul><h3 id="复制非空文件夹"><a href="#复制非空文件夹" class="headerlink" title="复制非空文件夹"></a>复制非空文件夹</h3><ul><li><code>cp -r /home/packageA/* /home/packageB/</code> 或者<code>cp /home/packageA/* /home/packageB/</code>是把packageA中的文件都复制到packageB中</li><li><code>cp -r /home/packageA/ /home/cp/packageB/</code> 是直接把packageA文件夹复制到packageB中</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">Linux cp（英文全拼：copy file）命令主要用于复制文件或目录。<br><br>语法<br>cp [options] source dest<br>或<br><br>cp [options] source... directory<br>参数说明：<br><br>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。<br>-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。<br>-f：覆盖已经存在的目标文件而不给出提示。<br>-i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。<br>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。<br>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。<br>-l：不复制文件，只是生成链接文件。<br>实例<br>使用指令 cp 将当前目录 test/ 下的所有文件复制到新目录 newtest 下，输入如下命令：<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> –r <span class="hljs-built_in">test</span>/ newtest</span>          <br>注意：用户使用该指令复制目录时，必须使用参数 -r 或者 -R 。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>驱动</tag>
      
      <tag>IMX6ULL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的FreeRTOS使用指南</title>
    <link href="/2023/12/09/MyFreeRTOSLearningGuide/MyFreeRTOSLearningGuide/"/>
    <url>/2023/12/09/MyFreeRTOSLearningGuide/MyFreeRTOSLearningGuide/</url>
    
    <content type="html"><![CDATA[<h1 id="我的FreeRTOS使用指南"><a href="#我的FreeRTOS使用指南" class="headerlink" title="我的FreeRTOS使用指南"></a>我的FreeRTOS使用指南</h1><h1 id="MyFreeRTOS-LearningGuide"><a href="#MyFreeRTOS-LearningGuide" class="headerlink" title="MyFreeRTOS-LearningGuide"></a>MyFreeRTOS-LearningGuide</h1><h2 id="By-kkl"><a href="#By-kkl" class="headerlink" title="By @kkl"></a>By @kkl</h2><hr><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote><p>本指南着重于FreeRTOS的API从入门到入土的所有用法（Maybe<br>不会太深究底层的内核实现，可能有一些相关性强的会Q一下<br>会讲一些我学习RTOS的时候卡关的地方，或者是觉得莫名其妙的、理解困难的点<br>主张一个，看着就能用，或者是看着看着就会用，而且用的还一溜一溜的FreeRTOS指南</p></blockquote><hr><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>MCU: STM32F405（现在是二三年十二月，最近才十元钱每片，以前单价十多元我还傻乎乎地买了好多…悲</li><li>工程: 标准库 + VScode + Keil（标准开局</li><li>版本: FreeRTOSv9.0.0</li></ul><hr><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>讲讲我们提前必须要知道的一些知识点和概念，不然后面看到代码会直接懵圈。</li></ul><blockquote><p><strong>1.堆栈</strong></p><ul><li>简单来说就是内存动态分配的问题，比方说你代码跑起来之后，会在某函数里面创建<code>临时变量</code>（也叫<code>局部变量</code>）的时候，就会用上堆栈。</li><li>**栈(Stack)**：就是在某个函数创建的<code>临时变量</code>的内存是编译器自动给你分配的。当这个函数执行完毕，编译器自动帮你释放了这个<code>临时变量</code>的内存。</li><li>栈也用在触发中断的时候，用于保护现场（当前函数地址啊寄存器值啊，方便从中断回来的时候还原现场哈。</li><li>当然栈的使用还包括你函数参数<code>eg: void Func(int Temp[256])</code>这里的变量<code>Temp[256]</code>也是编译器自动帮你申请内存。所以为啥有时候移植一些大型库的时候你什么都配置好了函数也没有出错编译器却报错，原因可能是库当中的某些函数申请的<code>局部变量</code>太大，而你的栈分配的太小导致的。</li><li>**堆(Heap)**：就是malloc或者new，简单说就是malloc，你自己分配内存，当然也要你自己去释放free，生命周期结束不释放内存，会造成内存泄漏。</li><li>**静态区(Static)**：就是你放<code>全局变量</code>或者<code>static修饰的变量</code>的地方啦。<blockquote><ul><li>那么在FreeRTOS中各个任务都有自己的堆栈，一般呢我们只管写这个任务需要多大的堆栈，FreeRTOS会自动帮我们从RAM中申请内存。包括信号量、队列这些都是。</li><li><code>configSUPPORT_STATIC_ALLOCATION</code>为0的时候，FreeRTOS会使用<code>heap_x.c(x为 1~5)</code>中的动态内存管理函数来自动申请RAM；当此宏定义为1的时候，用户可以给FreeRTOS指定一块静态RAM内存，你就可以执行类似<code>xTaskCreateStatic</code>的函数啦。一般咱们写0就行（默认也是写0的</li><li><code>configTOTAL_HEAP_SIZE</code></li><li><code>#define XXX_STK_SIZE 256</code>意思是设置XXX任务的堆栈大小为256*4(字&#x2F;byte</li></ul></blockquote></li></ul></blockquote><blockquote><p><strong>2.字和字节</strong></p><ul><li><strong>字节(bit)</strong></li><li><strong>字(Byte)</strong> ：1 byte &#x3D; 4 bits</li><li>在单片机中可以简单的把<code>byte</code>理解成<code>char</code>类型或者<code>unsigned char</code>类型</li></ul></blockquote><blockquote><p><strong>3.钩子</strong></p><ul><li>ChatGPT说，FreeRTOS的钩子函数(Hooks)是一组可由用户自定义的回调函数</li></ul></blockquote><blockquote><p><strong>4.优先级</strong></p><ul><li>使用FreeRTOS最好把优先级分组选择为<code>NVIC_PriorityGroup_4</code>，寄存器的4位字节都设置为抢占优先级，这样就有 0~15 共16个抢占优先级可供选择。因为FreeRTOS的中断配置里不能处理亚优先级（排队优先级）的这种情况。</li><li>任务优先级</li><li>FreeRTOS的任务优先级是0最不优先，越大越优先，和中断优先级相反的哈！</li></ul></blockquote><hr><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="1-1-中断屏蔽"><a href="#1-1-中断屏蔽" class="headerlink" title="1.1 中断屏蔽"></a>1.1 中断屏蔽</h3><ul><li><code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>此宏用来设置FreeRTOS系统可以管理的最大优先级。可以自由设置，正点原子设置为5，我也设置为5。也就是说抢占优先级小于5的中断不归FreeRTOS管理。</li><li><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>此宏用来设置FreeRTOS系统可以管理的最小优先级。可以自由设置，正点原子和我都设置成15。也就是说抢占优先级大于15的中断不归FreeRTOS管理，当然STM32的优先级只有 0~15 哈。</li><li>所以上述两个宏加起来的意思就是，<strong>抢占优先级为 0-4 的中断不归FreeRTOS调度，抢占优先级 5-15 的中断服从FreeRTOS的调度。</strong></li><li><em>Plus: 不归FreeRTOS调度的中断，不可以调用FreeRTOS的API哦，不可以哦！打咩！</em></li></ul><h3 id="1-2-开关中断"><a href="#1-2-开关中断" class="headerlink" title="1.2 开关中断"></a>1.2 开关中断</h3><h3 id="1-3-临界段代码（临界区）"><a href="#1-3-临界段代码（临界区）" class="headerlink" title="1.3 临界段代码（临界区）"></a>1.3 临界段代码（临界区）</h3><h4 id="1-3-1-任务级临界段代码保护"><a href="#1-3-1-任务级临界段代码保护" class="headerlink" title="1.3.1 任务级临界段代码保护"></a>1.3.1 任务级临界段代码保护</h4><ul><li>函数<code>taskENTER_CRITICAL()</code>进入临界区和<code>taskEXIT_CRITICAL()</code>退出临界区，是任务级的临界段代码保护。保护这两个函数包夹的区域不会受到中断的打扰。</li><li><strong>Important1: 这两个函数是成对使用的哦！不可以只用其中一个，它们必须成双成对的出现！就是说，你调用了多少次进入临界段，你就要调用多少次退出临界段来抵消！否则中断会一直被屏蔽！</strong></li><li><strong>Important2: 临界区的代码一定要精简！因为进入了临界区意味着关闭了FreeRTOS可以调度的所有中断，你不精简一点，噼里啪啦一大长串，执行好几秒，可能会导致这些中断得不到及时的响应！</strong></li><li>使用场景：任务创建、硬件层初始化、重要的实时性高的代码段…</li><li>任务级临界段代码保护的使用方法如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">testFunction</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        taskENTER_CRITICAL(); <span class="hljs-comment">// 进入临界区</span><br><br>        <span class="hljs-comment">// 你的代码段...</span><br>        <span class="hljs-comment">// 这里是临界区，代码不会受到中断的打断...</span><br><br>        taskEXIT_CRITICAL(); <span class="hljs-comment">// 退出临界区</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-3-2-中断级临界段代码保护"><a href="#1-3-2-中断级临界段代码保护" class="headerlink" title="1.3.2 中断级临界段代码保护"></a>1.3.2 中断级临界段代码保护</h4><ul><li>函数<code>taskENTER_CRITICAL_FROM_ISR()</code>进入中断临界区和<code>taskEXIT_CRITICAL_FROM_ISR(x)</code>退出中断临界区，是中断级临界段代码保护。</li><li>和任务级临界段代码保护差不多，只不过这里呢，<strong>进入中断临界区函数</strong>会返回一个Value，执行<strong>退出中断临界区函数</strong>的时候要把得到的Value传给它。Value记录的就是你屏蔽的其他的中断的优先级。<strong>反正你要记住进入中断临界段时接收这个Value，并在退出中断临界段的时候把这个Value放回去！</strong></li><li><strong>Important: 也是讲究成双成对出现的！一定要注意！</strong></li><li>运用场景：实时性要求最高的代码段（你看，你在中断里打开临界区，屏蔽了自己以外的所有FreeRTOS管理的中断，防止了中断嵌套的情况发生，保护在中断临界区的代码不被打扰</li><li>中断级临界段代码保护的使用方法如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定时器3中断服务函数 </span><br><span class="hljs-comment">// 假设定时器3的抢占优先级在FreeRTOS的调度范围内</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM3_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(TIM_GetITStatus(TIM3, TIM_IT_Update) == SET)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> Status_Value = taskENTER_CRITICAL_FROM_ISR();<br><br>        <span class="hljs-comment">// 你的代码段...</span><br>        <span class="hljs-comment">// 这里是中断临界区，屏蔽所有可被FreeRTOS调度的中断...</span><br><br>        taskEXIT_CRITICAL_FROM_ISR(Status_Value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="2-1-任务状态"><a href="#2-1-任务状态" class="headerlink" title="2.1 任务状态"></a>2.1 任务状态</h3><ul><li>运行态</li><li>就绪态</li><li>阻塞态</li><li>挂起态</li></ul><hr><h3 id="2-2-任务的创建"><a href="#2-2-任务的创建" class="headerlink" title="2.2 任务的创建"></a>2.2 任务的创建</h3><h4 id="2-2-1-任务创建的API函数"><a href="#2-2-1-任务创建的API函数" class="headerlink" title="2.2.1 任务创建的API函数"></a>2.2.1 任务创建的API函数</h4><blockquote><p>函数 <strong><code>xTaskCreate()</code></strong> ，又名你会用的最多的函数。</p><ul><li>用于动态创建一个任务，RAM会自行从FreeRTOS的堆中分配出来。</li></ul></blockquote><ul><li><code>xTaskCreate()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值 pdPASS-&gt;任务创建成功 / errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY-&gt;堆内存不足，创建任务失败</span><br>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( TaskFunction_t          pxTaskCode, <span class="hljs-comment">// 任务函数</span></span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span>      pcName, <span class="hljs-comment">// 任务名字</span></span><br><span class="hljs-params">                        <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span>          usStackDepth, <span class="hljs-comment">// 任务堆栈大小，实际申请到的堆栈是usStackDepth的4倍</span></span><br><span class="hljs-params">                        <span class="hljs-type">void</span> * <span class="hljs-type">const</span>            pvParameters, <span class="hljs-comment">// 传递给任务函数的参数</span></span><br><span class="hljs-params">                        UBaseType_t             uxPriority, <span class="hljs-comment">// 任务优先级</span></span><br><span class="hljs-params">                        TaskHandle_t * <span class="hljs-type">const</span>    pxCreatedTask <span class="hljs-comment">// 任务句柄</span></span><br><span class="hljs-params">                        )</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2-任务删除的API函数"><a href="#2-2-2-任务删除的API函数" class="headerlink" title="2.2.2 任务删除的API函数"></a>2.2.2 任务删除的API函数</h4><blockquote><p>函数 <strong><code>xTaskDelete()</code></strong></p><ul><li>删除一个用<code>xTaskCreate()</code>或者<code>xTaskCreateStatic()</code>创建的任务。</li><li>任务被删除之后，任务不复存在，关于被删除的任务的句柄不能再被使用，除非这个任务重新创建起来。</li><li>如果任务是由<code>xTaskCreate()</code>创建的（由动态方法创建），那么任务被删除以后，任务的堆栈将在<strong>空闲任务</strong>中得到<strong>释放</strong>，所以删除动态方法创建的任务以后要给空闲任务一些时间来释放空间哦！</li></ul></blockquote><ul><li><code>xTaskDelete()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无返回值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">( TaskHandle_t xTaskToDelete )</span> <span class="hljs-comment">// xTaskToDelete是要被删除的任务的任务句柄</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3-任务创建与删除的程序示例（动态方法）"><a href="#2-2-3-任务创建与删除的程序示例（动态方法）" class="headerlink" title="2.2.3 任务创建与删除的程序示例（动态方法）"></a>2.2.3 任务创建与删除的程序示例（动态方法）</h4><ul><li>简单的总结分析一下此例程的流程，因为这是我们使用 FreeRTOS 写的第一个程序，很多习惯是我们后面要用到的。比如使用任务宏定义任务优先级，堆栈大小等，一般有关一个任务的东西我们的放到一起，比如任务堆栈、任务句柄、任务函数声明等，这样方便修改。这些东西可以放到一个.h 头文件里面去，只是例程里面任务数比较少，所以就直接放到 main.c 文件里面了，要是工程比较大的话最好做一个专用的头文件来管理。</li></ul><h4 id="2-2-4-任务创建与删除的程序示例（静态方法）"><a href="#2-2-4-任务创建与删除的程序示例（静态方法）" class="headerlink" title="2.2.4 任务创建与删除的程序示例（静态方法）"></a>2.2.4 任务创建与删除的程序示例（静态方法）</h4><ul><li>和动态方法比较不同的是，想要使用静态方法，你必须自己实现两个接口函数<code>vApplicationGetIdleTaskMemory()</code>和<code>vApplicationGetTimerTaskMemory()</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 空闲任务任务堆栈 // 分配了静态的RAM啦</span><br><span class="hljs-type">static</span> StackType_t IdleTaskStack[configMINIMAL_STACK_SIZE];<br><span class="hljs-comment">// 空闲任务控制块</span><br><span class="hljs-type">static</span> StaticTask_t IdleTaskTCB;<br><br><span class="hljs-comment">// 定时器服务任务堆栈 // 分配了静态的RAM啦</span><br><span class="hljs-type">static</span> StackType_t TimerTaskStack[configTIMER_TASK_STACK_DEPTH];<br><span class="hljs-comment">// 定时器服务任务控制块</span><br><span class="hljs-type">static</span> StaticTask_t TimerTaskTCB;<br><br><span class="hljs-comment">// 获取空闲任务地任务堆栈和任务控制块内存，因为本例程使用的</span><br><span class="hljs-comment">// 静态内存，因此空闲任务的任务堆栈和任务控制块的内存就应该</span><br><span class="hljs-comment">// 有用户来提供，FreeRTOS提供了接口函数vApplicationGetIdleTaskMemory()</span><br><span class="hljs-comment">// 实现此函数即可。</span><br><span class="hljs-comment">// ppxIdleTaskTCBBuffer:任务控制块内存</span><br><span class="hljs-comment">// ppxIdleTaskStackBuffer:任务堆栈内存</span><br><span class="hljs-comment">// pulIdleTaskStackSize:任务堆栈大小</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationGetIdleTaskMemory</span><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer,</span><br><span class="hljs-params">    StackType_t **ppxIdleTaskStackBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> *pulIdleTaskStackSize)</span><br>&#123;<br>*ppxIdleTaskTCBBuffer = &amp;IdleTaskTCB;<br>*ppxIdleTaskStackBuffer = IdleTaskStack;<br>*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;<br>&#125;<br><br><span class="hljs-comment">// 获取定时器服务任务的任务堆栈和任务控制块内存</span><br><span class="hljs-comment">// ppxTimerTaskTCBBuffer:任务控制块内存</span><br><span class="hljs-comment">// ppxTimerTaskStackBuffer:任务堆栈内存</span><br><span class="hljs-comment">// pulTimerTaskStackSize:任务堆栈大小</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vApplicationGetTimerTaskMemory</span><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer,</span><br><span class="hljs-params">    StackType_t **ppxTimerTaskStackBuffer,</span><br><span class="hljs-params">    <span class="hljs-type">uint32_t</span> *pulTimerTaskStackSize)</span><br>&#123;<br>*ppxTimerTaskTCBBuffer = &amp;TimerTaskTCB;<br>*ppxTimerTaskStackBuffer = TimerTaskStack;<br>*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-x-x-任务控制块"><a href="#2-x-x-任务控制块" class="headerlink" title="2.x.x 任务控制块"></a>2.x.x 任务控制块</h4><h4 id="2-x-x-任务堆栈"><a href="#2-x-x-任务堆栈" class="headerlink" title="2.x.x 任务堆栈"></a>2.x.x 任务堆栈</h4><hr><h3 id="2-3-任务挂起和恢复"><a href="#2-3-任务挂起和恢复" class="headerlink" title="2.3 任务挂起和恢复"></a>2.3 任务挂起和恢复</h3><h4 id="2-3-1-任务挂起的API函数"><a href="#2-3-1-任务挂起的API函数" class="headerlink" title="2.3.1 任务挂起的API函数"></a>2.3.1 任务挂起的API函数</h4><blockquote><p>函数 <strong><code>vTaskSuspend()</code></strong></p><ul><li>该函数用于将某个任务设置为挂起态，任务挂起以后就不会被运行，直到使用<code>vTaskResume()</code>或者<code>xTaskResumeFromISR()</code>结束任务的挂起态。</li></ul></blockquote><ul><li><code>vTaskSuspend()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无返回值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">( TaskHandle_t xTaskToSuspend )</span> <span class="hljs-comment">// xTaskToSuspend将要被挂起任务的任务句柄 </span><br>                                                 <span class="hljs-comment">// 注意！如果参数为NULL，表示挂起任务自己。</span><br></code></pre></td></tr></table></figure><h4 id="2-3-2-任务恢复的API函数"><a href="#2-3-2-任务恢复的API函数" class="headerlink" title="2.3.2 任务恢复的API函数"></a>2.3.2 任务恢复的API函数</h4><blockquote><p>函数 <strong><code>vTaskResume()</code></strong> ，在主程序中调用</p><ul><li>该函数可以也只可以将先前使用<code>vTaskSuspend()</code>函数挂起的任务恢复到就绪态。</li></ul></blockquote><ul><li><code>vTaskResume()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 无返回值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span> <span class="hljs-comment">// 将要被恢复任务的任务句柄</span><br></code></pre></td></tr></table></figure><blockquote><p>函数 <strong><code>xTaskResumeFromISR()</code></strong> ，在中断函数中调用</p><ul><li>该函数是<code>vTaskResume()</code>函数的中断版本，需要在中断里调用哈。</li><li>该函数可以也只可以将先前使用<code>vTaskSuspend()</code>函数挂起的任务恢复到就绪态。</li></ul></blockquote><ul><li><code>xTaskResumeFromISR()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdTRUE-&gt;恢复的任务优先级 &gt;= 当前任务的优先级，所以在退出中断函数后要进行一次上下文切换</span><br><span class="hljs-comment">// 返回值：pdFALSE-&gt;恢复的任务优先级 &lt; 当前任务的优先级，所以在退出中断函数后不需要进行一次上下文切换</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">( TaskHandle_t xTaskToResume )</span> <span class="hljs-comment">// 将要被恢复任务的任务句柄</span><br></code></pre></td></tr></table></figure><h4 id="2-3-3-任务挂起和恢复程序示例"><a href="#2-3-3-任务挂起和恢复程序示例" class="headerlink" title="2.3.3 任务挂起和恢复程序示例"></a>2.3.3 任务挂起和恢复程序示例</h4><hr><h3 id="3-1-列表和列表项"><a href="#3-1-列表和列表项" class="headerlink" title="3.1 列表和列表项"></a>3.1 列表和列表项</h3><h4 id="3-1-1-列表"><a href="#3-1-1-列表" class="headerlink" title="3.1.1 列表"></a>3.1.1 列表</h4><p>为啥要有列表？不是已经可以创建任务运行任务了吗？我的理解是，在做一些大型项目的时候，往往要根据不同的场景执行不同的任务，有时任务比较多了，创建任务和删除任务这些操作就变得弯弯绕绕了。这个时候把任务们归类进不同的列表中，那我切换运用场景的时候，直接切换目前正在执行的列表就行啦！就不用一个一个对任务进行操作，避免了麻烦。</p><ul><li>列表，是FreeRTOS中的一个数据结构，和链表有点像，是被用做跟踪FreeRTOS中的任务的</li><li>列表项就是存放在列表当中的项目</li><li>列表相当于链表，列表项相当于节点，FreeRTOS中的列表是一个双向环形链表</li><li>常见的列表包括：就绪列表、阻塞列表、挂起列表（目前自己做列表的情况比较少，都是RTOS自动帮我们做好的）</li></ul><h4 id="3-1-2-列表项"><a href="#3-1-2-列表项" class="headerlink" title="3.1.2 列表项"></a>3.1.2 列表项</h4><ul><li>列表项，就是存放在列表中的项目。</li><li>FreeRTOS提供了两种列表项：列表项和迷你列表项。</li></ul><hr><h3 id="4-1-调度器"><a href="#4-1-调度器" class="headerlink" title="4.1 调度器"></a>4.1 调度器</h3><blockquote><p>函数 <strong><code>vTaskStartScheduler()</code></strong> ，开启任务调度器</p><ul><li>在<code>main()</code>函数里，创建好所需的任务后，即可调用<code>vTaskStartScheduler()</code>让任务开始运行吧。</li></ul></blockquote><blockquote><p>函数 <strong><code>vTaskEndScheduler()</code></strong> ，关闭任务调度器</p></blockquote><blockquote><p>函数 <strong><code>vTaskSuspendAll()</code></strong> ，挂起任务调度器，就是挂起所有任务</p></blockquote><blockquote><p>函数 <strong><code>vTaskResumeAll()</code></strong> ，恢复任务调度器，就是恢复所有任务</p></blockquote><h3 id="4-2-空闲任务"><a href="#4-2-空闲任务" class="headerlink" title="4.2 空闲任务"></a>4.2 空闲任务</h3><blockquote><ul><li>调用<code>vTaskStartScheduler()</code>时候，此函数会自动创建一个名为<code>IDLE</code>的任务，这个就是空闲任务！它是FreeRTOS系统自动创建的，不需要用户手动创建。而且任务调动器启动以后必须至少有一个任务在运行中，所以这也是空闲任务存在的意义之一。</li><li>空闲任务的优先级最低，是0！任务函数为<code>prvIdleTask()</code>（是啥？</li><li>空闲任务的作用如下：<blockquote><ul><li>如果系统有任务被删除，被删除的任务的堆栈和任务控制块的内存会在空闲任务中得到释放哦！</li><li>运行用户设置的空闲任务钩子函数（？啥是钩子</li><li>判断是否开启低功耗tickless模式，如果开启的话还需要做相应的处理（？</li></ul></blockquote></li></ul></blockquote><h3 id="4-3-延时函数"><a href="#4-3-延时函数" class="headerlink" title="4.3 延时函数"></a>4.3 延时函数</h3><blockquote><p>函数 <strong><code>xTaskDelay()</code></strong> ，延时多少时间，用于固定延时（常用的普通的延时函数）</p></blockquote><blockquote><p>函数 <strong><code>xTaskDelayUntil()</code></strong> ，每隔多少时间执行一次函数，用于周期性执行</p></blockquote><hr><h3 id="5-1-队列"><a href="#5-1-队列" class="headerlink" title="5.1 队列"></a>5.1 队列</h3><ul><li>队列是任务到任务、任务到中断、中断到任务数据交流的一种机制（消息传递</li><li>写队列和读队列的api函数都会自动进入临界区操作的</li><li>在队列中可以存储数量有限、大小固定的数据。队列中的每一个数据叫做“队列项目”，队列能够存储“队列项目”的最大数量成为队列的长度</li></ul><h3 id="5-2-二值信号量"><a href="#5-2-二值信号量" class="headerlink" title="5.2 二值信号量"></a>5.2 二值信号量</h3><ul><li><p>二值信号量：其实就是一个只有一个队列项的队列，这个特殊的队列要么是满的，要么是空的，这正好是二值！</p></li><li><p>任务和中断使用这个特殊队列不用在乎队列中存的是什么消息，只需要知道这个队列是满的还是空的，就可以利用这个机制来完成任务与中断之间的同步！</p></li></ul><h4 id="5-2-1-二值信号量创建的API函数"><a href="#5-2-1-二值信号量创建的API函数" class="headerlink" title="5.2.1 二值信号量创建的API函数"></a>5.2.1 二值信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateBinary()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateBinary()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;信号量创建失败；其他-&gt;创建成功的信号量的句柄</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateBinary</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br></code></pre></td></tr></table></figure><h4 id="5-2-2-二值信号量释放的API函数"><a href="#5-2-2-二值信号量释放的API函数" class="headerlink" title="5.2.2 二值信号量释放的API函数"></a>5.2.2 二值信号量释放的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreGive()</code></strong> ，任务级信号量释放函数<br>函数 <strong><code>xSemaphoreGiveISR()</code></strong> ，中断级信号量释放函数</p></blockquote><ul><li><code>xSemaphoreGive()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：errQUEUE_FULL-&gt;信号量释放失败；pdPASS-&gt;信号量释放成功</span><br><span class="hljs-comment">// 参数： xSemaphore-&gt;要释放的信号量句柄</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGive</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore )</span> <br></code></pre></td></tr></table></figure><ul><li><code>xSemaphoreGiveISR()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：errQUEUE_FULL-&gt;信号量释放失败；pdPASS-&gt;信号量释放成功</span><br><span class="hljs-comment">// 参数：xSemaphore-&gt;要释放的信号量句柄</span><br><span class="hljs-comment">// 参数：pxHigherPriorityTaskWoken-&gt;标记退出此函数是否进行任务切换，用户要做的就是</span><br><span class="hljs-comment">// 提供一个变量来保存这个值，在退出中断函数前判断一下这个变量，当这个值为pdTRUE时</span><br><span class="hljs-comment">// 在退出中断函数之前一定要做一次任务切换taskYIELD()！</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGiveISR</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore, BaseType_t* pxHigherPriorityTaskWoken )</span> <br></code></pre></td></tr></table></figure><h4 id="5-2-3-二值信号量获取的API函数"><a href="#5-2-3-二值信号量获取的API函数" class="headerlink" title="5.2.3 二值信号量获取的API函数"></a>5.2.3 二值信号量获取的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreTake()</code></strong> ，任务级信号量释放函数<br>函数 <strong><code>xSemaphoreTakeISR()</code></strong> ，中断级信号量释放函数</p></blockquote><ul><li><code>xSemaphoreTake()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFALSE-&gt;信号量获取失败；pdTRUE-&gt;信号量获取成功</span><br><span class="hljs-comment">// 参数： xSemaphore-&gt;要释放的信号量句柄</span><br><span class="hljs-comment">// 参数：xBlockTime-&gt;阻塞时间</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTake</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore, TickType_t xBlockTime )</span> <br></code></pre></td></tr></table></figure><ul><li><code>xSemaphoreTakeISR()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFALSE-&gt;信号量获取失败；pdTRUE-&gt;信号量获取成功</span><br><span class="hljs-comment">// 参数：xSemaphore-&gt;要获取信号量句柄</span><br><span class="hljs-comment">// 参数：pxHigherPriorityTaskWoken-&gt;标记退出此函数是否进行任务切换，用户要做的就是</span><br><span class="hljs-comment">// 提供一个变量来保存这个值，在退出中断函数前判断一下这个变量，当这个值为pdTRUE时</span><br><span class="hljs-comment">// 在退出中断函数之前一定要做一次任务切换taskYIELD()！</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTakeISR</span><span class="hljs-params">( SemaphoreHandle_t xSemaphore, BaseType_t* pxHigherPriorityTaskWoken )</span> <br></code></pre></td></tr></table></figure><h3 id="5-3-计数型信号量"><a href="#5-3-计数型信号量" class="headerlink" title="5.3 计数型信号量"></a>5.3 计数型信号量</h3><ul><li>计数型信号量就是读取这个队列项的数值，获取信号量的时候自减，释放信号量的时候自增，本质就是一个带值的二值信号量</li></ul><h4 id="5-3-1-计数型信号量创建的API函数"><a href="#5-3-1-计数型信号量创建的API函数" class="headerlink" title="5.3.1 计数型信号量创建的API函数"></a>5.3.1 计数型信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateCounting()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateCounting()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;计数型信号量创建失败；其他-&gt;创建成功的计数型信号量的句柄</span><br><span class="hljs-comment">// 参数：uxMaxCount-&gt;计数信号量的最大值，当信号量值等于此值时，释放信号量会失败，因为已经满了</span><br><span class="hljs-comment">// 参数：uxInitialCount-&gt;计数信号量的初值</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateCounting</span><span class="hljs-params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span> <br></code></pre></td></tr></table></figure><h4 id="5-3-2-计数型信号量释放与获取的API函数"><a href="#5-3-2-计数型信号量释放与获取的API函数" class="headerlink" title="5.3.2 计数型信号量释放与获取的API函数"></a>5.3.2 计数型信号量释放与获取的API函数</h4><p><strong>计数型信号量的释放和获取与二值信号量相同！请看5.2.2和5.2.3！</strong></p><h3 id="5-4-互斥信号量"><a href="#5-4-互斥信号量" class="headerlink" title="5.4 互斥信号量"></a>5.4 互斥信号量</h3><ul><li>但是呢，使用二值信号量可能会导致优先级反转的问题，这个时候我们可以使用！互斥信号量！</li><li>互斥信号量其实就是一个拥有优先级继承的二值信号量。</li><li>注意：创建互斥信号量时，会主动释放一次信号量！就是你可以直接获取到！而二值信号量和计数型信号量不行，它们需要手动释放第一次信号量。</li><li><strong>互斥信号量有优先级继承机制，所以只能用在任务中，不能用于中断服务函数中！</strong></li></ul><h4 id="5-4-1-互斥信号量创建的API函数"><a href="#5-4-1-互斥信号量创建的API函数" class="headerlink" title="5.4.1 互斥信号量创建的API函数"></a>5.4.1 互斥信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateMutex()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateMutex()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;信号量创建失败；其他-&gt;创建成功的信号量的句柄</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br></code></pre></td></tr></table></figure><h4 id="5-4-2-互斥信号量释放与获取的API函数"><a href="#5-4-2-互斥信号量释放与获取的API函数" class="headerlink" title="5.4.2 互斥信号量释放与获取的API函数"></a>5.4.2 互斥信号量释放与获取的API函数</h4><p><strong>互斥信号量的释放和获取与二值信号量相同！请看5.2.2和5.2.3！</strong></p><h3 id="5-5-递归互斥信号量"><a href="#5-5-递归互斥信号量" class="headerlink" title="5.5 递归互斥信号量"></a>5.5 递归互斥信号量</h3><ul><li>递归互斥信号量可以看作一个特殊的互斥信号量，已经获取了互斥信号量的任务就不能再次获取这个互斥信号量，但是递归互斥信号量不同，已经获取了递归互斥信号量的任务可以再次获取这个递归互斥任务而且次数不限！一个任务使用函数xSemaphoreTakeRecursive()成功的获取了多少次递归互斥信号量就得使用函数xSemaphoreGiveRecursive()释放多少次！</li><li>注意：要使用递归互斥信号量的话宏configUSE_RECURSIVE_MUTEXES必须为1！</li></ul><h4 id="5-5-1-递归互斥信号量创建的API函数"><a href="#5-5-1-递归互斥信号量创建的API函数" class="headerlink" title="5.5.1 递归互斥信号量创建的API函数"></a>5.5.1 递归互斥信号量创建的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreCreateRecursiveMutex()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreCreateRecursiveMutex()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：NULL-&gt;信号量创建失败；其他-&gt;创建成功的信号量的句柄</span><br>SemaphoreHandle_t <span class="hljs-title function_">xSemaphoreCreateRecursiveMutex</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br></code></pre></td></tr></table></figure><h4 id="5-5-2-递归互斥信号量释放的API函数"><a href="#5-5-2-递归互斥信号量释放的API函数" class="headerlink" title="5.5.2 递归互斥信号量释放的API函数"></a>5.5.2 递归互斥信号量释放的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreGiveRecursive()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreGiveRecursive()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFAIL-&gt;信号量释放失败；pdPASS-&gt;信号量释放成功</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreGiveRecursive</span><span class="hljs-params">( QueueHandle_t xMutex )</span> <br></code></pre></td></tr></table></figure><h4 id="5-5-3-递归互斥信号量获取的API函数"><a href="#5-5-3-递归互斥信号量获取的API函数" class="headerlink" title="5.5.3 递归互斥信号量获取的API函数"></a>5.5.3 递归互斥信号量获取的API函数</h4><blockquote><p>函数 <strong><code>xSemaphoreTakeRecursive()</code></strong> ，在主程序中调用</p></blockquote><ul><li><code>xSemaphoreTakeRecursive()</code>一览：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 返回值：pdFAIL-&gt;信号量获取失败；pdPASS-&gt;信号量获取成功</span><br>BaseType_t <span class="hljs-title function_">xSemaphoreTakeRecursive</span><span class="hljs-params">( QueueHandle_t xMutex, TickType_t xTicksTowait )</span> <br></code></pre></td></tr></table></figure><hr><h3 id="6-1-任务通知"><a href="#6-1-任务通知" class="headerlink" title="6.1 任务通知"></a>6.1 任务通知</h3><blockquote><p>任务通知的优势</p></blockquote><ul><li><strong>效率更高</strong>！如果使用任务通知来模拟二值信号量，速度快45%（官方测试）！</li><li><strong>使用内存更小</strong>，使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体</li></ul><blockquote><p>任务通知的劣势</p></blockquote><ul><li><strong>无法在中断服务函数中获得任务通知</strong>，你只能在中断服务函数中发送任务通知</li><li><strong>无法广播给多个任务（只能一个）</strong>，任务通知只能是被指定的一个任务接收并处理</li><li><strong>无法缓存多个数据（只能一个）</strong>，任务通知是通过更新任务通知值来发送数据的，任务结构体中只有一个任务通知值，只能保持一个数据</li></ul><h4 id="6-1-1-任务通知模拟二值信号量"><a href="#6-1-1-任务通知模拟二值信号量" class="headerlink" title="6.1.1 任务通知模拟二值信号量"></a>6.1.1 任务通知模拟二值信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br>xTaskNotifyGive(yourTaskHandler);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 接收任务成功后pdTRUE-&gt;任务通知值清零，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        <span class="hljs-keyword">if</span>(ulTaskNotifyTake(pdTRUE, portMAX_DELAY))<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-2-任务通知模拟计数型信号量"><a href="#6-1-2-任务通知模拟计数型信号量" class="headerlink" title="6.1.2 任务通知模拟计数型信号量"></a>6.1.2 任务通知模拟计数型信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br>xTaskNotifyGive(yourTaskHandler);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> rev = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 接收任务成功后pdFALSE-&gt;任务通知值自减，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        rev = ulTaskNotifyTake(pdFALSE, portMAX_DELAY);<br>        <span class="hljs-keyword">if</span>(rev)<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-3-任务通知模拟消息邮箱（传值）"><a href="#6-1-3-任务通知模拟消息邮箱（传值）" class="headerlink" title="6.1.3 任务通知模拟消息邮箱（传值）"></a>6.1.3 任务通知模拟消息邮箱（传值）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br><span class="hljs-comment">// valForTransfer-&gt;你想要传送的变量值，eSetValueWithOverwrite-&gt;设置成可覆写模式</span><br>xTaskNotify(yourTaskHandler, valForTransfer, eSetValueWithOverwrite);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> notifyVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 接收任务成功后，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span><span class="hljs-comment">/*传入值不改变*/</span>, <span class="hljs-number">0xFFFFFFFF</span><span class="hljs-comment">/*退出函数后传入值清零*/</span>, &amp;notifyVal, portMAX_DELAY);<br>        <span class="hljs-keyword">switch</span>(notifyVal)<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-4-任务通知模拟事件标志组"><a href="#6-1-4-任务通知模拟事件标志组" class="headerlink" title="6.1.4 任务通知模拟事件标志组"></a>6.1.4 任务通知模拟事件标志组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 任务发起通知 */</span><br><span class="hljs-comment">// EVENTBIT_X-&gt;你想要通知的第几个bit，eSetBits-&gt;设置成事件标志组模式</span><br>xTaskNotify(yourTaskHandler, EVENTBIT_0<span class="hljs-comment">/* 通知bit0 */</span>, eSetBits);<br><br>xTaskNotify(yourTaskHandler, EVENTBIT_1<span class="hljs-comment">/* 通知bit1 */</span>, eSetBits);<br><br><span class="hljs-comment">/* 任务接收通知 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">yourTask</span><span class="hljs-params">(<span class="hljs-type">void</span> * pvPaeameters)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> notifyVal = <span class="hljs-number">0</span>, eventBit = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 接收任务成功后，portMAX_DELAY-&gt;死等，没任务通知就阻塞</span><br>        xTaskNotifyWait(<span class="hljs-number">0</span><span class="hljs-comment">/*传入值不改变*/</span>, <span class="hljs-number">0xFFFFFFFF</span><span class="hljs-comment">/*退出函数后传入值清零*/</span>, &amp;notifyVal, portMAX_DELAY);<br>        <span class="hljs-keyword">if</span>(notifyVal &amp; EVENTBIT_0)<br>        &#123;<br>            eventBit |= EVENTBIT_0;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(notifyVal &amp; EVENTBIT_1)<br>        &#123;<br>            eventBit |= EVENTBIT_1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(eventBit == (EVENTBIT_0 | EVENTBIT_1))<br>        &#123;<br>            <span class="hljs-comment">// do your task</span><br>        &#125;<br>    &#125;<br>    xTaskDelete(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内核控制函数"><a href="#内核控制函数" class="headerlink" title="内核控制函数"></a>内核控制函数</h3><h4 id="任务切换的API函数"><a href="#任务切换的API函数" class="headerlink" title="任务切换的API函数"></a>任务切换的API函数</h4><blockquote><p>函数 <strong><code>taskYIELD()</code></strong> ，此函数用于进行任务切换，用的最多的就是出中断的优先级切换时</p></blockquote><h4 id="进入、退出临界区的API函数"><a href="#进入、退出临界区的API函数" class="headerlink" title="进入、退出临界区的API函数"></a>进入、退出临界区的API函数</h4><blockquote><p>函数 <strong><code>taskENTER_CRITICAL()</code></strong> ，进入临界区，用于任务级</p></blockquote><blockquote><p>函数 <strong><code>taskENTER_CRITICAL_FROM_ISR()</code></strong> ，进入临界区，用于中断级</p></blockquote><blockquote><p>函数 <strong><code>taskEXIT_CRITICAL()</code></strong> ，退出临界区，用于任务级</p></blockquote><blockquote><p>函数 <strong><code>taskEXIT_CRITICAL_FROM_ISR()</code></strong> ，退出临界区，用于中断级</p></blockquote><h4 id="中断打开、关闭的API函数"><a href="#中断打开、关闭的API函数" class="headerlink" title="中断打开、关闭的API函数"></a>中断打开、关闭的API函数</h4><blockquote><p>函数 <strong><code>taskENABLE_INTERRUPTS()</code></strong> ，打开中断</p></blockquote><blockquote><p>函数 <strong><code>taskDISABLE_INTERRUPTS()</code></strong> ，关闭中断</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
      <tag>FreeRTOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git与VScode联合使用的源代码管理指南</title>
    <link href="/2023/12/09/GitxVScode-CodeManageGuide/GitxVScode-CodeManageGuide/"/>
    <url>/2023/12/09/GitxVScode-CodeManageGuide/GitxVScode-CodeManageGuide/</url>
    
    <content type="html"><![CDATA[<h1 id="GitxVScode-CodeManageGuide"><a href="#GitxVScode-CodeManageGuide" class="headerlink" title="GitxVScode-CodeManageGuide"></a>GitxVScode-CodeManageGuide</h1><h1 id="Git与VScode联合使用的源代码管理指南"><a href="#Git与VScode联合使用的源代码管理指南" class="headerlink" title="Git与VScode联合使用的源代码管理指南"></a>Git与VScode联合使用的源代码管理指南</h1><h2 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h2><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>建议有一点Git管理基础的人使用！至少你得Github有号吧，是吧！</li><li>这些指令其实并不常用，我们只是稍作理解，剩下的交给Vscode点点点吧！</li></ul><hr><h2 id="相关插件"><a href="#相关插件" class="headerlink" title="相关插件"></a>相关插件</h2><ul><li><p>Git Graph</p><ul><li>可以清晰地看到存储仓库的每一次提交(Commit)，每一个分支(Branch)，和每一次合并的记录，非常nice！</li><li>同时可以很方便的查询每一次的记录，进行文件代码比对。</li></ul></li><li><p>GitLens</p><ul><li>可以直接在源代码里看到每一行代码的更改时间！</li></ul></li><li><p>GitHistory</p><ul><li>和Git Graph功能类似，细节注重点不太一样。</li></ul></li></ul><hr><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><strong>提交(Commit)</strong><ul><li><code>git add .</code>添加所有被修改文件到暂存更改区</li><li><code>git commit -m &quot;massage&quot;</code> 提交暂存更改区的内容作为一个新版本，<code>massage</code>为该版本的关键字</li><li><code>-m</code>的作用就是可以不弹窗直接写关键字，如果你只输入<code>git commit</code>就会弹出一个窗口让你填写该版本的关键字。</li></ul></li></ul><blockquote><p>这个操作我们使用VScode自带的源代码管理来完成。<br>暂存我们所需的修改之后点击提交，接着会跳转到<code>COMMIT_EDITMSG</code>文件页面，顾名思义就是提交编辑信息。<br>你可以在这个文件最顶部写一些你这次提交的一些消息备注。写完保存，关掉这个文件页面，即可完成一次提交！</p></blockquote><ul><li><strong>推送(Push)</strong></li></ul><blockquote><p>这个操作需要我们的VScode关联自己的Github仓库后才可以使用。<br>提交之后，提交记录会暂存在我们本地的仓库内，如果想要把提交记录推送至Github，我们只需要在VScode的源代码管理里选择推送即可。<br>如果你Github没有创建相关的仓库，VScode也会弹窗让你创建的！</p></blockquote><ul><li><strong>签出到(Checkout)</strong></li></ul><blockquote><ul><li><code>git checkout branch_name</code>切换分支。 </li><li>切换分支的时候要保证当前暂存区没有需要修改的文件哦！可以用<code>git status</code>确保现在的状态是<code>clean</code>，否则就会切换分支失败了。</li></ul></blockquote><ul><li><strong>版本回退(Reset)</strong></li></ul><blockquote><p>有3种常用的回退方式，分别是<code>soft</code>, <code>mixed</code>, <code>hard</code></p></blockquote><blockquote><p>1.<code>git reset --soft &lt;Hash&gt;</code>（这里<code>&lt;Hash&gt;</code>是你的版本号哈！<br><code>soft</code>回退方式只会把Head指针往回指到你回退的版本，然后你仓库里的文件不会发生任何的增删，状态大概就是你已经commit了，但是没有push的状态。（？不知道理解的对不对</p></blockquote><blockquote><p>2.<code>git reset --mixed &lt;Hash&gt;</code><br><code>mixed</code>回退方式，会把Head指针往回指到我们希望回退到的版本，然后仓库里的文件也不会发生任何的增删（暂时），为什么说是暂时呢？因为它把你这个回退版本之后所有的commit都放回了暂存更改区，你就可以在暂存更改区里决定要恢复什么文件，恢复什么代码啦！</p></blockquote><blockquote><p>3.<code>git reset --hard &lt;Hash&gt;</code><br><code>hard</code>回退方式，会把Head指针往回指到我们希望回退到的版本，然后该版本号以后的版本统统都会不见使用<code>git log</code>时就看不见当前回退版本以后的版本号了（所以要谨慎！</p><ul><li>这种回退方式会简单粗暴的把你本地仓库回退版本的什么文件啊什么代码原封不动地一字不拉地归还它的原样！</li><li>当然，你仍然可以通过<code>git reflog</code>找回从前的版本号，然后使用<code>git reset --hard &lt;Hash&gt;</code>跳回去，<strong>理论上，你的代码不会丢，</strong> nice！</li><li><code>git reset --hard HEAD^</code>表示硬回退到<strong>上一个</strong>版本</li><li>同理<code>HEAD^^</code>表示<strong>上上个</strong>版本，<code>HEAD^^^</code>表示<strong>上上上个</strong>版本，而且你也可以用<code>HEAD~3</code>表示<strong>上上上个</strong>版本噢！</li></ul></blockquote><h2 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h2><h3 id="记录查看"><a href="#记录查看" class="headerlink" title="记录查看"></a>记录查看</h3><ul><li><code>git log</code></li></ul><blockquote><ul><li><code>git log</code>用来查看commit提交历史记录。</li><li><code>git log --graph</code>这条命令使用了就会有优雅的树状图可以看啦（也不算是树状图，反正就是图形化显示</li><li>在终端按<code>Q</code>键退出日志哦！</li></ul></blockquote><ul><li><code>git reflog</code></li></ul><blockquote><p>用来查看Git仓库的所有git命令操作的历史记录，比如你用过的<code>reset</code>, <code>checkout</code>, <code>commit</code>, <code>push</code> 的记录都能在这里看到。</p></blockquote><ul><li><code>git status</code></li></ul><blockquote><p>用来查看本地仓库状态。</p></blockquote><h3 id="分支查找"><a href="#分支查找" class="headerlink" title="分支查找"></a>分支查找</h3><ul><li><code>git branch</code></li></ul><blockquote><ul><li><code>git branch</code>用来查看当前所在的分支。</li><li><code>git branch -v</code>用来查看当前所在分支最后一次提交的版本号和版本关键字。</li><li><code>git branch branch_name</code>用来创建名字为<code>branch_name</code>的新分支。</li></ul></blockquote><h3 id="远程仓库克隆"><a href="#远程仓库克隆" class="headerlink" title="远程仓库克隆"></a>远程仓库克隆</h3><ul><li><code>git clone</code></li></ul><blockquote><ul><li><code>git clone &lt;address&gt;</code>老熟人了，打开一个文件夹，打开它的命令行窗口，你就敲上面的命令，<code>&lt;address&gt;</code>是被克隆的远程仓库的地址。就这个命令可以完成目前所有开源项目90%的克隆。</li><li><code>git clone --recursive &lt;address&gt;</code>剩下的10%就比较专业一点，可能人家远程代码库里运用了别人的子项目，你直接克隆下来就是个空文件夹，所以你就需要用这个命令来<strong>递归</strong>克隆！把别人子项目的内容也可以克隆下来！</li></ul></blockquote><h3 id="本地仓库初始化"><a href="#本地仓库初始化" class="headerlink" title="本地仓库初始化"></a>本地仓库初始化</h3><ul><li><code>git init</code></li></ul><blockquote><p>在该文件夹下初始化git仓库</p></blockquote><h3 id="本地仓库全局配置"><a href="#本地仓库全局配置" class="headerlink" title="本地仓库全局配置"></a>本地仓库全局配置</h3><ul><li><code>git config</code></li></ul><blockquote><p>在初始化完成Git本地仓库后，开始正式使用前，是需要有一些全局设置的，如用户名、邮箱等</p><ul><li><code>git config --global user.name &quot;your name&quot;</code>用于设置全局用户名</li><li><code>git config --global uer.email &quot;your email&quot;</code>用于设置全局邮箱<br>其中，<code>--global</code>指定全局配置，不使用该参数，则为当前所在仓库配置。</li></ul></blockquote><blockquote><p>我的Github用户名和邮箱：</p></blockquote><script >function checkPassword() {  var password = document.getElementById("password").value;  if (password === "0000") {  document.getElementById("user").style.display = "block";  } else {  alert("不准偷看！！！");  document.getElementById("user").style.display = "none";  }}</script><body title="哒咩">  口令是什么？  <input type="password" id="password">  <button onclick="checkPassword()" style="border-radius: 5px;">确认</button>  <div id="user" style="display: none;">    <p>俺滴Github用户名：ZhangKeLiang0627</p>    <p>俺滴Github邮箱：111654293+ZhangKeLiang0627@users.noreply.github.com</p>  </div></body><style>  input[type="password"] {    padding: 3px;    margin: 5px;    border: 1px solid #ccc;    border-radius: 5px;  }  #user {    display: none;    background-color: #f4f4f4;    padding: 5px;    margin-top: 10px;    border-radius: 5px;    box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);  }</style><blockquote><p>注意我的不是你的哦🫸</p></blockquote><blockquote><p>于是可以如下配置：<br><code>git config --global user.name &quot;xxx&quot;</code><br><code>git config --global uer.email &quot;xxx.example.com&quot;</code></p></blockquote><blockquote><p>可以输入以下两条指令，检查用户名和邮箱是否输入正确。<br><code>git config user.name</code><br><code>git config user.email</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在单片机环境下移植Lua</title>
    <link href="/2023/11/14/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/"/>
    <url>/2023/11/14/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/%E5%9C%A8%E5%8D%95%E7%89%87%E6%9C%BA%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%A7%BB%E6%A4%8DLua/</url>
    
    <content type="html"><![CDATA[<h1 id="在单片机环境下移植Lua🤗"><a href="#在单片机环境下移植Lua🤗" class="headerlink" title="在单片机环境下移植Lua🤗"></a>在单片机环境下移植Lua🤗</h1><h2 id="软件：keil"><a href="#软件：keil" class="headerlink" title="软件：keil"></a>软件：keil</h2><h2 id="所需环境：Malloc、Fatfs"><a href="#所需环境：Malloc、Fatfs" class="headerlink" title="所需环境：Malloc、Fatfs"></a>所需环境：Malloc、Fatfs</h2><ul><li>声明这里使用的是正点原子家的源码，感谢！</li><li>上述环境是为了实现Lua能够从外置存储介质读取文件所准备的，如果没有需求可以不用</li></ul><h2 id="主控：STM32F401RET6"><a href="#主控：STM32F401RET6" class="headerlink" title="主控：STM32F401RET6"></a>主控：STM32F401RET6</h2><ul><li>运行频率：84MHz</li><li>ROM:512KB</li><li>RAM:96KB</li></ul><h2 id="移植版本：Lua-v5-3"><a href="#移植版本：Lua-v5-3" class="headerlink" title="移植版本：Lua-v5.3"></a>移植版本：Lua-v5.3</h2><h3 id="lua-lua-at-v5-3-github-com"><a href="#lua-lua-at-v5-3-github-com" class="headerlink" title="(lua&#x2F;lua at v5.3 (github.com))"></a><strong>(<a href="https://github.com/lua/lua/tree/v5.3">lua&#x2F;lua at v5.3 (github.com)</a>)</strong></h3><ul><li>具体版本是Lua-v5.3.5</li></ul><h2 id="关于Lua"><a href="#关于Lua" class="headerlink" title="关于Lua"></a>关于Lua</h2><p>Lua 语言是由巴西里约热内卢天主教大学 ([Pontifical Catholic University of Rio de janeiro ) 里的一个研究小组与 1993年开发的一种<strong>轻量小巧</strong>的<strong>脚本（弱语言）语言</strong>，用标准 C 语言编写，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p>作为一种扩展语言，Lua 没有“主”程序的概念：它嵌入在宿主客户端中运行，称为嵌入程序或简称为宿主。（通常这个宿主是单机lua程序） <strong>宿主程序可以调用函数执行一段Lua代码，可以读写Lua变量，可以注册Lua代码调用的C函数</strong>。通过使用 C 函数，可以增强 Lua 以应对广泛的不同领域，从而创建共享语法框架的定制编程语言。</p><ul><li>简单来说，Lua是一种轻量级的基于C编写的运行高效的脚本语言（解释性语言like：Python、shell、Matlab等。</li><li>在单片机环境下移植Lua，因为Lua和C的超级无敌兼容性，相当于你同时拥有了两种语言加持（C和Lua），你可以直接用Lua内部提供的几个简单的API，使得C内运行Lua脚本，特别方便，避免了重复烧录的麻烦。</li><li><strong>Lua解释器的移植，最小占用ROM: 70KB，占用RAM: 7.5KB(很小很小)</strong></li><li>简单的lua程序跟C程序效率比是1：100。而lua运算量越大。与C程序效率差距就越小。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>在github上拉取Lua-v5.3的版本库(<a href="https://github.com/lua/lua/tree/v5.3">lua&#x2F;lua at v5.3 (github.com)</a>)</li><li>建立一个基于主控STM32F401RET6的Keil文件(已经有的话就不需要，直接哐哐移植)</li></ol><h2 id="开始移植"><a href="#开始移植" class="headerlink" title="开始移植"></a>开始移植</h2><h4 id="移植Lua库文件"><a href="#移植Lua库文件" class="headerlink" title="移植Lua库文件"></a>移植Lua库文件</h4><ol><li>将github上拉取的 lua-5.3 文件夹移入工程文件夹。</li><li>打开Keil，点击魔术棒，将..\lua-5.3 相对路径添加到环境变量。</li><li>点击三个盒子，创建一个文件夹命名为Lua，将..\lua-5.3 相对路径下的所有.c文件（除了Lua.c和Luac.c以外，如果有的话，没有就不管）添加到其中。</li><li>更改 loslib.c 文件下部分内容：</li></ol><blockquote><ol><li>将 <strong>os_exit(lua_State * L)</strong> 函数中 <strong>if(L) exit(status)</strong> 注释，并添加 <strong>status&#x3D;status</strong> 语句。</li><li>添加 <strong>time(time_t *time)</strong> 和 <strong>system(const char * string)</strong> 。</li><li>将魔术棒里的 <strong>Use MicroLIB</strong> 模式关闭（不打勾！）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">os_exit</span> <span class="hljs-params">(lua_State *L)</span> &#123;<br>  <span class="hljs-type">int</span> status;<br>  <span class="hljs-keyword">if</span> (lua_isboolean(L, <span class="hljs-number">1</span>))<br>    status = (lua_toboolean(L, <span class="hljs-number">1</span>) ? EXIT_SUCCESS : EXIT_FAILURE);<br>  <span class="hljs-keyword">else</span><br>    status = (<span class="hljs-type">int</span>)luaL_optinteger(L, <span class="hljs-number">1</span>, EXIT_SUCCESS);<br>  <span class="hljs-keyword">if</span> (lua_toboolean(L, <span class="hljs-number">2</span>))<br>    lua_close(L);<br><span class="hljs-comment">/* &#x27;if&#x27; to avoid warnings for unreachable &#x27;return&#x27; */</span><br>  <span class="hljs-comment">//if (L) exit(status);  </span><br><br>  status=status;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-type">time_t</span> <span class="hljs-title function_">time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> *time)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">system</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-built_in">string</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>最后可以去<strong>linit.c</strong>注释一些用不到的Lua库，当然，不注释也不会影响太大。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">** these libs are loaded by lua.c and are readily available to any Lua</span><br><span class="hljs-comment">** program</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> luaL_Reg loadedlibs[] = &#123;<br>  &#123;<span class="hljs-string">&quot;_G&quot;</span>, luaopen_base&#125;,<br>  &#123;LUA_LOADLIBNAME, luaopen_package&#125;,<br>  &#123;LUA_COLIBNAME, luaopen_coroutine&#125;,<br>  &#123;LUA_TABLIBNAME, luaopen_table&#125;,<br><span class="hljs-comment">//  &#123;LUA_IOLIBNAME, luaopen_io&#125;,</span><br><span class="hljs-comment">//  &#123;LUA_OSLIBNAME, luaopen_os&#125;,</span><br>  &#123;LUA_STRLIBNAME, luaopen_string&#125;,<br>  &#123;LUA_MATHLIBNAME, luaopen_math&#125;,<br>  &#123;LUA_UTF8LIBNAME, luaopen_utf8&#125;,<br><span class="hljs-comment">//  &#123;LUA_DBLIBNAME, luaopen_debug&#125;,</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(LUA_COMPAT_BITLIB)</span><br>  &#123;LUA_BITLIBNAME, luaopen_bit32&#125;,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  &#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="添加retarget-c"><a href="#添加retarget-c" class="headerlink" title="添加retarget.c"></a>添加retarget.c</h4><blockquote><ul><li>放哪随意，我基于正点原子的工程放在了system的文件夹中</li><li>引进这个库的目的是为了实现Lua从外置的存储介质中获取文件内容，我们需要用Fatfs的API去实现Lua所需的fopen、fclose、fread等函数（如果没有这个需求，可以跳过此步骤）</li><li>声明本次移植使用的Fatfs，来自正点原子的Fatfs实验源码，好用爱用，给个好评。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rt_sys.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;usart.h&quot;</span></span><br><br><span class="hljs-comment">// 是否将fopen与FatFS关联起来</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FATFS_EN 1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ff.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// #pragma import(__use_no_semihosting) // 禁用半主机模式 //已经在usart.c中定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> import(__use_no_semihosting_swi) <span class="hljs-comment">// 即不使用半主机模式，防止程序进入软件中断</span></span><br><span class="hljs-comment">// #pragma import(_main_redirection)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDIN 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDOUT 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDERR 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_STD(fh) ((fh) &gt;= 0 &amp;&amp; (fh) &lt;= 2)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * These names are used during library initialization as the</span><br><span class="hljs-comment"> * file names opened for stdin, stdout, and stderr.</span><br><span class="hljs-comment"> * As we define _sys_open() to always return the same file handle,</span><br><span class="hljs-comment"> * these can be left as their default values.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __stdin_name[] = <span class="hljs-string">&quot;:kkl&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __stdout_name[] = <span class="hljs-string">&quot;kkl&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> __stderr_name[] = <span class="hljs-string">&quot;kkl&quot;</span>;<br><br>FILEHANDLE _sys_open(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> openmode)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    BYTE mode;<br>    FIL *fp;<br>    FRESULT fr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (name == __stdin_name)<br>        <span class="hljs-keyword">return</span> STDIN;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == __stdout_name)<br>    &#123;<br>        uart_init(<span class="hljs-number">115200</span>); <span class="hljs-comment">// 初始化串口 (在main函数执行前执行)</span><br>        <span class="hljs-keyword">return</span> STDOUT;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == __stderr_name)<br>        <span class="hljs-keyword">return</span> STDERR;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(FILEHANDLE) &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *))<br>    &#123;<br>        USART1_SendBuf(<span class="hljs-string">&quot;sizeof(FILEHANDLE) should be no less than sizeof(void *)!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    fp = ff_memalloc(<span class="hljs-keyword">sizeof</span>(FIL)); <span class="hljs-comment">// 使用自己的malloc函数替换</span><br>    <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">/* http://elm-chan.org/fsw/ff/doc/open.html */</span><br>    <span class="hljs-keyword">if</span> (openmode &amp; OPEN_W)<br>    &#123;<br>        mode = FA_CREATE_ALWAYS | FA_WRITE;<br>        <span class="hljs-keyword">if</span> (openmode &amp; OPEN_PLUS)<br>            mode |= FA_READ;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (openmode &amp; OPEN_A)<br>    &#123;<br>        mode = FA_OPEN_APPEND | FA_WRITE;<br>        <span class="hljs-keyword">if</span> (openmode &amp; OPEN_PLUS)<br>            mode |= FA_READ;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        mode = FA_READ;<br>        <span class="hljs-keyword">if</span> (openmode &amp; OPEN_PLUS)<br>            mode |= FA_WRITE;<br>    &#125;<br><br>    fr = f_open(fp, name, mode);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">uintptr_t</span>)fp;<br><br>    ff_memfree(fp); <span class="hljs-comment">// 使用自己的free函数替换</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> _sys_close(FILEHANDLE fh)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (IS_STD(fh))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fh == STDOUT)<br>            <span class="hljs-comment">// usart_deinit();</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    fr = f_close((FIL *)fh);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>    &#123;<br>        ff_memfree((<span class="hljs-type">void</span> *)fh);<span class="hljs-comment">// 使用自己的free函数替换</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> _sys_write(FILEHANDLE fh, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">unsigned</span> len, <span class="hljs-type">int</span> mode)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br>    UINT bw;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (fh == STDIN)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (fh == STDOUT || fh == STDERR)<br>    &#123;<br>        USART1_SendBuf((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)buf);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    fr = f_write((FIL *)fh, buf, len, &amp;bw);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>        <span class="hljs-keyword">return</span> len - bw;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> _sys_read(FILEHANDLE fh, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *buf, <span class="hljs-type">unsigned</span> len, <span class="hljs-type">int</span> mode)<br>&#123;<br>    <span class="hljs-comment">// char ch;</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br>    UINT br;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">if</span> (fh == STDIN)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; len)<br>        &#123;<br>            <span class="hljs-comment">//     ch = usart_receive(); // 这里需要实现串口收到字符串传入buf的功能</span><br>            <span class="hljs-comment">//     if (isprint(ch))</span><br>            <span class="hljs-comment">//     &#123;</span><br>            <span class="hljs-comment">//         buf[i++] = ch;</span><br>            <span class="hljs-comment">//         usart_send(ch);</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">//     else if (ch == &#x27;\r&#x27;)</span><br>            <span class="hljs-comment">//     &#123;</span><br>            <span class="hljs-comment">//         buf[i++] = &#x27;\n&#x27;;</span><br>            <span class="hljs-comment">//         usart_send(&#x27;\n&#x27;);</span><br>            <span class="hljs-comment">//         break;</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">//     else if (i &gt; 0 &amp;&amp; ch == &#x27;\b&#x27;)</span><br>            <span class="hljs-comment">//     &#123;</span><br>            <span class="hljs-comment">//         i--;</span><br>            <span class="hljs-comment">//         usart_send_string(&quot;\b \b&quot;, 3);</span><br>            <span class="hljs-comment">//     &#125;</span><br>            i--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> len - i;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fh == STDOUT || fh == STDERR)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    fr = f_read((FIL *)fh, buf, len, &amp;br);<br>    <span class="hljs-keyword">if</span> (fr == FR_OK)<br>        <span class="hljs-keyword">return</span> len - br;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 检查句柄是否为终端</span><br><span class="hljs-type">int</span> _sys_istty(FILEHANDLE fh)<br>&#123;<br>    <span class="hljs-keyword">return</span> IS_STD(fh);<br>&#125;<br><br><span class="hljs-type">int</span> _sys_seek(FILEHANDLE fh, <span class="hljs-type">long</span> pos)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    FRESULT fr;<br><br>    <span class="hljs-keyword">if</span> (!IS_STD(fh))<br>    &#123;<br>        fr = f_lseek((FIL *)fh, pos);<br>        <span class="hljs-keyword">if</span> (fr == FR_OK)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 刷星句柄关联的缓冲区</span><br><span class="hljs-type">int</span> _sys_ensure(FILEHANDLE fh)<br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回文件当前长度</span><br><span class="hljs-type">long</span> _sys_flen(FILEHANDLE fh)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> FATFS_EN</span><br>    <span class="hljs-keyword">if</span> (!IS_STD(fh))<br>        <span class="hljs-keyword">return</span> f_size((FIL *)fh);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 在usart.c中定义了，注释防止重复定义</span><br><span class="hljs-comment">// void _sys_exit(int status)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">////while(1);</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-type">int</span> _sys_tmpnam(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> fileno, <span class="hljs-type">unsigned</span> maxlength)<br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 将一个字符写入控制台</span><br><span class="hljs-type">void</span> _ttywrch(<span class="hljs-type">int</span> ch)<br>&#123;<br>    USART1_SendChar(ch);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span><br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newname)</span><br>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义main函数argv的内容</span><br><span class="hljs-type">char</span> *_sys_command_string(<span class="hljs-type">char</span> *cmd, <span class="hljs-type">int</span> len)<br>&#123;<br>    <span class="hljs-comment">// 可以把命令行内容放入大小为len的cmd缓存区然后返回</span><br>    <span class="hljs-comment">// 也可以直接返回一个字符串</span><br>    <span class="hljs-comment">// return &quot;./foo -f bar&quot;;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 在loslib.c中已有定义，防止重复定义，这里注释掉</span><br><span class="hljs-comment">// time_t time(time_t * time)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//return 0;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-type">clock_t</span> <span class="hljs-title function_">clock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="排查错误"><a href="#排查错误" class="headerlink" title="排查错误"></a>排查错误</h2><p>因为我用的是正点原子的USART的代码，它们家是没有勾<strong>Use MicroLIB</strong> 模式的，一些配置会重复，所以我们要自己改一些东西，不然编译没法通过。</p><ul><li>打开usart.c，更改以下部分内容：</li></ul><blockquote><ol><li>注释<strong>FILE __stdout;</strong></li></ol></blockquote><p>因为移植了Lua解释器，所以我们的<strong>堆栈分配</strong>应该相应的分配更大一些。</p><ul><li>打开启动文件（<strong>startup_stm32f40_41xxx.s</strong>），更改以下部分内容：</li></ul><blockquote><ol><li>修改栈：<strong>Stack_Size      EQU     0x00001000 &#x2F;&#x2F;4k &#x2F;&#x2F;不行就改成0x00004000</strong></li><li>修改堆：<strong>Heap_Size       EQU     0x00002c00 &#x2F;&#x2F;11k &#x2F;&#x2F;不行就改成0x00004000</strong></li></ol></blockquote><ul><li>打开<strong>luaconf.h</strong></li></ul><blockquote><ol><li>添加 <strong>#define LUA_32BITS</strong></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You</span><br><span class="hljs-comment">** can also define LUA_32BITS in the make file, but changing here you</span><br><span class="hljs-comment">** ensure that all software connected to Lua will be compiled with the</span><br><span class="hljs-comment">** same configuration.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/* #define LUA_32BITS */</span><br> <span class="hljs-meta">#<span class="hljs-keyword">define</span> LUA_32BITS</span><br></code></pre></td></tr></table></figure><p>OK！这时候再编译应该不会有报错，是可以通过的！</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 将C函数注册成Lua可调用的函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_led_on</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br>LED0 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 将C函数注册成Lua可调用的函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_print_hello</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello this is lua!\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 将C函数注册成Lua可调用的函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">luaL_Reg</span> <span class="hljs-title">mylib</span>[] =</span><br>&#123;<br>&#123;<span class="hljs-string">&quot;led_on&quot;</span>,lua_led_on&#125;,<br>&#123;<span class="hljs-string">&quot;print_hello&quot;</span>,lua_print_hello&#125;,<br>&#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">/* 编写Lua脚本 */</span><br><span class="hljs-comment">/* 这个程序中，我们点亮了led，同时打印了Hello this is lua!\r\n */</span><br><span class="hljs-comment">/* 接着，程序的主导权就会归还给c继续执行c程序 */</span><br><span class="hljs-comment">/* 当然你也可以直接在这里写个 while 循环，这样后面的c程序都不再执行，直至退出循环 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> LUA_SCRIPT_GLOBAL_ON[]=<span class="hljs-string">&quot;\</span><br><span class="hljs-string">led_on()\</span><br><span class="hljs-string">print_hello()\</span><br><span class="hljs-string">&quot;</span>;<br><br><span class="hljs-comment">/* 运行Lua脚本 */</span><br><span class="hljs-comment">/* 将这个函数丢到程序里面去，比方说main函数里头 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_file_script</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>lua_State *L;<br>L = luaL_newstate();<br>luaopen_base(L);<br>luaL_setfuncs(L, mylib, <span class="hljs-number">0</span>); <span class="hljs-comment">// 使我们注册的函数生效</span><br>luaL_dostring(L, LUA_SCRIPT_GLOBAL_ON); <span class="hljs-comment">// 执行我们写的Lua文本脚本程序</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lua还有更多的可玩性，上面的仅仅只是其中一种（<strong>luaL_dostring</strong>）！</p><p>下面再介绍一种（<strong>luaL_dofile</strong>）！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_led_on</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br>LED0 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lua_print_hello</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello this is lua!\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">luaL_Reg</span> <span class="hljs-title">mylib</span>[] =</span><br>&#123;<br>&#123;<span class="hljs-string">&quot;led_on&quot;</span>,lua_led_on&#125;,<br>&#123;<span class="hljs-string">&quot;print_hello&quot;</span>,lua_print_hello&#125;,<br>&#123;<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_file_script</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">uint8_t</span> res;<br>lua_State *L;<br>L = luaL_newstate(); <span class="hljs-comment">//创建Lua虚拟机</span><br>luaopen_base(L); <span class="hljs-comment">// 配置基本环境</span><br>luaL_openlibs(L); <span class="hljs-comment">// 注册所使用到的各种Lua库</span><br>luaL_setfuncs(L, mylib, <span class="hljs-number">0</span>); <span class="hljs-comment">// 注册函数</span><br><br>res = luaL_dofile(L, <span class="hljs-string">&quot;1:/test.lua&quot;</span>); <span class="hljs-comment">// 这里我事先把test.lua存储到了外部flash里，所以这里可以写具体位置去读取并运行这个文件</span><br><span class="hljs-keyword">if</span>(res) <span class="hljs-comment">// 返回1，说明读取失败，返回0，为读取成功</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;err\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ok\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Lua调用C函数的注意事项：<br>对于可被Lua调用的C函数而言，其接口必须遵循Lua要求的形式，即<br><strong>typedef int (lua_CFunction)(lua_State* L);</strong><br>接收一个参数Lua_State*，即Lua的状态，返回值表示压入栈中的结果个数。</p></blockquote><p>如果想要注册有传入参数且有返回值的函数，可以参考以下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Add</span><span class="hljs-params">(lua_State *L)</span><br>&#123;<br><span class="hljs-type">int</span> count;<br><span class="hljs-type">int</span> x,y,res;<br><br>x = lua_tointeger(L,<span class="hljs-number">1</span>);<span class="hljs-comment">//获取Lua传递的参数</span><br>y = lua_tointeger(L,<span class="hljs-number">2</span>);<br><br>res = x + y;<span class="hljs-comment">//计算x+y</span><br><br>lua_pushnumber(L,res);<span class="hljs-comment">//结果压入栈中，供Lua提取</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//返回参数个数！！这是通知LUA调用者有一个值返回</span><br>&#125;<br><br><span class="hljs-comment">//Lua中调用</span><br>local res<br>res = Add(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>print(<span class="hljs-string">&quot;Result = &quot;</span>,res)<br></code></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><h3 id="Author-kkl"><a href="#Author-kkl" class="headerlink" title="Author: @kkl"></a>Author: @kkl</h3>]]></content>
    
    
    <categories>
      
      <category>Study Page</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
      <tag>单片机</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
